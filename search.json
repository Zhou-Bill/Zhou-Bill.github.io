[{"title":"AND(A,B,OR(C,D,E)) 转换","url":"/2023/04/04/AND(A,B,OR(C,D,E))/","content":"\n## 背景\n\n一天，朋友问我 `AND(A,B,OR(C,D,E))` 该怎么转换成 `A&B&(C|D|E)`, 当时回复他用栈就可以了吧，后来自己实现了一下，\n才发现没这么简单。下面是我实现的思路：\n\n* 先把符号入栈，这里的符号指的是 `AND` 或者是 `OR` 转换成 `&` 或 `|`, 我们每次拿栈顶的符号进行括号内的转换就行了\n* 遇到`（` 就将`里面的值` 加进数组中，遇到 `)`就将`这个数组`入栈， 我们称这个叫数据栈\n* 最后将数据栈与符号栈结合\n\n以下是完整代码：\n\n## 代码\n\n```js\n// console.log(convertString('AND(A,B,OR(C,D,E))')); // \"A&B&(C|D|E)\"我想实现这个convertstring有什么好的思路吗\nfunction merge(a, b) {\n  function mergeExpr(arr, sep, level) {\n    if (arr.length === 0) {\n      return ''\n    }\n    const target = arr.splice(0, 1)[0]\n    const current = target + (arr.length > 0 ? sep : '')\n    return current + (arr.length > 0 ? '(' + mergeExpr(arr, b[level + 1], level + 1) + ')' : '')\n  }\n  return mergeExpr(a, b[0], 0)\n}\n\nconst convertString = (string) => {\n  const length =  string.length\n\n  const MAP = {\n    'AND': '&',\n    'OR': '|'\n  }\n\n  // 记录符号\n  const stack1 = []\n\n  //记录数据， 每一个（） 里面的数据 都是一个数组， 所以他是一个二维数组\n  const stack2 = []\n\n  // 表示栈中的层级 没遇到一个（ 就加一， 遇到 ） 就减一\n  let level = -1;\n  let tempString = ''\n  for (let i = 0; i < length - 1; i++) {\n    const nextChar =  string[i + 1]\n    const currentChar =  string[i]\n\n    if (currentChar === '(' || currentChar === ',' || currentChar === ')') {\n      continue\n    }\n    tempString = tempString + currentChar\n\n    // 如果下一个是字母 是 （  那么就是一个完整的字符串, 也就是 AND 或者 OR\n    if (nextChar === '(') {\n      level = level + 1\n      stack2.push([])\n      stack1.push(MAP[tempString])\n      tempString = ''\n      continue\n    } else if (nextChar === ',') {\n      const topData = stack2[level]\n      topData.push(tempString)\n      tempString = ''\n    } else if (nextChar === ')') {\n      const topData = stack2[level]\n      topData.push(tempString)\n      tempString = ''\n      level = level - 1\n    }\n  }\n\n  const k = []\n  for (let i = 0; i < stack1.length; i++) {\n    const character = stack1[i]\n    k.push(`${stack2[i].join(character)}`)\n  }\n  return merge(k, stack1.slice(0, -1))\n}\n\nconst a = convertString('AND(A,B,OR(C,D,E,AND(F,G)))')\nconst b = convertString('OR(AND(A,B,C),D,E)')\nconst c = convertString('AND(A,B,J,OR(C,D,E,AND(F,G),K))')\n\nconsole.log(a)\nconsole.log(b)\nconsole.log(c)\n\n```","tags":["js"],"categories":["js"]},{"title":"taro 升级遇见的坑","url":"/2023/02/14/taro 升级遇见的坑/","content":"\n# taro 升级遇见的坑\n\n**背景**：公司的小程序`UI库`已经多年不更新了，部分UI 有`bug`，也懒得到原仓库修改，于是便有了这次的升级，将采用**[@antmjs/vantui](https://github.com/AntmJS/vantui)**  这个新的`ui 库`， 目前`taro` 为 `3.6.1`\n\n使用以下命令升级, 等待依赖下载完成。\n\n```jsx\ntaro update project\n```\n\n### 1. 遇到了平台不兼容问题\n\n因为我们包里面使用已`.weapp.ts` 表示微信小程序。 已`.ts` 表示`pc` 或者其他平台，升级后导致\n\n`MultiPlatformPlugin` 这个插件 使用失败\n\n原来的使用方法是\n\n```jsx\nchain.resolve.plugin('MultiPlatformPlugin').tap((args) => {\n  return [\n    ...args,\n    {\n       include: ['@gm-mobile', 'gm_api'],\n    },\n  ]\n})\n```\n\n需要更改成，即修改`webpack` `extentions`, 去除 `MultiPlatformPlugin`\n\n```jsx\nchain.resolve.extensions.prepend('.weapp.ts')\nchain.resolve.extensions.prepend('.weapp.tsx')\n```\n\n修改了`babel.config.js` , 以及 `package.json`  的 `browserslist` \n\nbabel 会根据你设置的浏览器，根据预设值，去使用对应的插件，将代码转换，算是打个补丁\n\n```jsx\n// babel.config.js\npresets: [\n  ['taro', {\n    framework: 'react',\n    ts: true\n  }]\n],\n```\n\n```json\n// package.json\n\"browserslist\": [\n\t\t\"last 3 versions\",\n\t\t\"Android >= 4.1\",\n\t\t\"ios >= 8\"\n\t],\n```\n\n### 2.  升级后发现字体，padding 等分辨率 有很大差别\n\n原因是： taro 后面基础设计图的尺寸修改成 750, 导致了样式偏大或偏小\n\n解决方法： [参考 Taro 配置](https://docs.taro.zone/docs/next/config-detail#designwidth)\n\n```jsx\ndesignWidth(input) {\n  if (input.file && input.file.indexOf('@antmjs/vantui') > -1) {\n   return 750\n  }\n  return 375\n},\ndeviceRatio: {\n  375: 2 / 1,  // 之前已375 为基础尺寸\n  640: 2.34 / 2,\n  750: 1,\n  828: 1.81 / 2\n},\n```\n\n### 3. 升级后发现打包后的产物变大了\n\ntaro 默认使用`webpack4`  作为打包工具, 打包的产物包含了`babel/helper` 等 \n\n解决方法： 使用`webpack5`, 但你需要`安装webpack5`, 依赖里面没有，导致报错了，安装后正常\n\n```jsx\nyarn add webpack\n```\n\n```jsx\n// cpnfig/index.js\n\ncompiler: {\n  type: 'webpack5',\n  prebundle: {\n    enable: false\n  },\n},\n```\n\n### 4. 升级后发现moment 打包会把其他语言也打包进去\n\n项目中之前是用了 `ContextReplacementPlugin` 去忽略其他语言的加载，但后面失效了。找了很久没找到解决方案，最后在`issue` 里面获得启发\n\n解决方法：调用`webpackChain(chain, webpack)`\n\n```jsx\n// config/index.js\nchain\n\t .plugin('IgnorePlugin')\n   .use(new webpack.ContextReplacementPlugin(/moment[/\\\\]locale$/, /zh-cn/))\n\n// moment 需要过滤，表示package.json 引用的是main 字段\nchain.resolve.mainFields.clear();\nchain.merge({\n  resolve: {\n    mainFields: ['module', 'main', 'jsnext:main']\n  }\n})\n```\n\n### 5. **引入本地含svg的iconfont报错**\n\n[相关issue](https://github.com/NervJS/taro/issues/13008)\n\n查找了下`postcss-url` 说可以忽略，但是没找到`taro` 的配置","tags":["taro"],"categories":["taro"]},{"title":"typescript 获取url 参数，类型应该怎么写","url":"/2022/05/20/typescript 获取url 参数，类型应该怎么写/","content":"\n## 前言\n\n有天面试的时候，面试官问如何写 获取url 参数类型应该怎么写？\n\n* 当时回答用的是 `infer`，跟`泛型`还有`递归`，但是面试官说哪里需要用到 `泛型`, 说参数不就是一个`string`吗，后来就不了了之了。\n* 但回家想了一下，确实应该使用`泛型`，我的解决思路是没有问题的\n\n\n## 解决思路\n\n* 比如当前 `url` 为 `https://www.baidu.com?key12=0123123&key1=1`, 那么我们要获取`key12` 跟 `value: 0123123`\n* 先截取字符串`?`之后的值，得到的结果是 `key12=0123123&key1=1` \n* 然后截取 `${key}=${value}` 这个字符串, 得到的结果是 `key = key12`, `value = 0123123&key1=1`, 你可以发现`value` 仍然包含其他值 `key` `value` 值， 那么这里我们递归解决就行了\n* 判断逻辑是 如果么有包含 `&` 那么我们就构建对象，`{ [k in key]: value }`\n* 最后递归合并对象即可\n\n## 完整代码\n\n```jsx\ntype Merge<F, S> = {[key in keyof F | keyof S]: key extends keyof S ? S[key] : key extends keyof F ? F[key] : never};\n\ntype getKeys<T extends string> = T extends `${infer K}?${infer Rest}` ? Rest : ''\n\ntype keyToValue<T extends string> = T extends `${infer key}=${infer value}` \n  ? value extends `${infer V}&${infer rest}`\n    ? Merge<{[k in key]: V}, keyToValue<rest>> \n    : { [k in key]: value }\n  : {}\n\ntype A = getKeys<'https://www.baidu.com?key12=0123123&key1=1'>\ntype B = keyToValue<A>\n\nconst url = 'https://www.baidu.com?key12=0123123&key1=1'\n\nfunction getParameter<T extends string>(url: T): keyToValue<getKeys<T>> {\n  const [ , format] = url.split(\"?\");\n  const data = format.split(\"&\")\n  const result = {} as keyToValue<getKeys<T>>\n  data.forEach((_item) => {\n    const [key, value] = _item.split(\"=\")\n    result[key] = value\n  })\n  return result\n}\n\nconst q = getParameter(url)\n \n```\n\n### 在线demo\n\n[demo](https://www.typescriptlang.org/play?#code/C4TwDgpgBAshBOBzCAeAYgGigZQHxQF4oBvAbQGsIQoBLAOykpAHsAzKNKAH0arZwC6ALl7UIAD2AQ6AEwDOo-tigB+HBSoCoIplAlTZCpv05q0GkFpF0IANwQBfANwAoF6EhRkwANJU5KAAqepLS8lBywPD0iPhEwfphCgAGACTE9KwIUD4OKumZ2QBKEJEOyapQJZHaUADkdW4e0EyBzABqAIYANgCuqAmhhhFRMXFQgwbhaRl0WfCiDgQFc9m2Pf3lUC5Qlet90InDM4UL7Q4AZCvzUPClwOU7u5VwSKhk5LQMTMJQ51itDobVB3SK4fBPXYiYhQChfUS-fb9KAOJ7Q1HucDQACChC8EF8-hQdQAFsBgGA5EIAPTUgDuDIAdAAjTo0GS9RkAY2YAFsVEwAIwAJgIAAYRQBmKUXIUEQV1XCYzwAITxgK6BxQ2KVzUUrDVRGM7BVbh5dBqvXg3TxpPJlJp9KZrPZnJ5-KFoolwulPtlVEF8saLlYvToXOANGYDG8AAVOvBOryCQggiEpgpItE6LEABRW7oiQIASh0VDamv6KG8fhAAUC4JIT3NNVIUCwrGY8F5nWAWiIBcZcjA3RowFzACIVBPi65di3gFAZL3OnjO93e0OR2PJxcZ83ozVQb1uouiMQHFBOkZy0CtTWiQ2lbtl8BOoz1wBRTpckm53MAPpjhAvLFoQ+DEJCUALrCTBYEiED9lAQFSLyW6juOE4EDOc7PLmx6nleCidHQIDFhYSEIU8DjFk8dzAFaDAEcALgYjBACOeJxgmSYpvA+bWsWQA)","tags":["typescript"],"categories":["typescript"]},{"title":"在自己的vps上安装Jenkins","url":"/2022/05/20/在自己的vps 上安装Jenkins/","content":"\n## 安装jdk\n\n首先查看是否含有`jdk`\n\n```bash\n// 执行\njavac\n\n// 或者\njava -version\n```\n\n如果没有安装\n\n```bash\nyum install -y java-1.8.0-openjdk-devel.x86_64\n```\n\n找到jdk 位置\n\n```bash\nwhich java\n```\n\n## 安装jenkins\n\n官方下载，但是`下载失败了`, 因为被墙了\n\n```bash\nsudo wget -O /etc/yum.repos.d/jenkins.repo \\\n    https://pkg.jenkins.io/redhat-stable/jenkins.repo\nsudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key\nsudo yum upgrade\n# Add required dependencies for the jenkins package\nsudo yum install java-11-openjdk\nsudo yum install jenkins\n```\n\n其他方式下载\n\n\n```bash\nwget https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/jenkins-2.332.3-1.1.noarch.rpm\n```\n\n```bash\nrpm -ivh jenkins-2.332.3-1.1.noarch.rpm\n```\n\n\n## 启动jenkins\n\n```bash\n# 启动jenkins\nsystemctl start jenkins\n# 查看jenkins\nsystemctl status jenkins\n# 重启jenkins\nsystemctl restart jenkins\n# 停止jenkins\nsystemctl stop jenkins\n```\n\n初始端口是`8080`, 可以通过修改`vim /etc/sysconfig/jenkins` 配置文件更改端口号\n\n\n## FAQ\n\n打开网站`ip:[端口]` 配置`jenkins`, 如果是线上ECS 服务器 有可能访问不成功, 请检查下面几个原因\n\n* 是否已安装jdk，命令：`Java -version`\n* 查看防火墙状态： `systemctl status firewalld.service`\n* 查看端口号是否开放`netstat -natp`\n* 如果是`阿里云等服务器` 需要将`端口号加入到安全组`\n\n\n## 安装 nginx\n\n\n* 安装额外的软件仓库 `sudo yum install epel-release -y`\n* 安装nginx `sudo yum install nginx -y`\n\n\n## 在服务器上设置 git\n\n```bash\ngit config --global user.name \"Bill\"\ngit config --global user.email \"735051883@qq.com\"\n```\n\n## 设置ssh\n\n```bash\nssh-keygen -t rsa -C \"735051883@qq.com\"\n```\n\n## 验证是否通过\n\n```bash\nssh -T git@github.com\n```\n\n\n### 坑：在jenkins 上建立项目，无法连接github\n\n是因为在`jenkins` 上连接`github` 是用了`jenkins` 用户的`ssh`, 重新生成秘钥，添加到`github`上即可\n或者从`~/.ssh` 复制过去也行\n\n```bash\nsu root\ncd /var/lib/jenkins/.ssh\nssh-keygen -t rsa -C your-email@sample.com\n# 注意下一步提示保存位置的时候，要再输入\n/var/lib/jenkins/.ssh/id_rsa\n# Enter file in which to save the key (/root/.ssh/id_rsa): /var/lib/jenkins/.ssh/id_rsa\n# 改变用户\nchown jenkins:jenkins id_rsa id_rsa.pub\ncat id_rsa.pub\n```\n\n或者\n```bash\nsudo mv ~/.ssh/id_rsa.pub /var/lib/jenkins/.ssh/\nsudo mv ~/.ssh/id_rsa /var/lib/jenkins/.ssh/\nsudo mv ~/.ssh/knows_host /var/lib/jenkins/.ssh/\nchown jenkins:jenkins id_rsa id_rsa.pub knows_host\n```\n\n\n## 配置nginx\n\n```bash\ncd /etc/nginx/conf.d\n\nvi cra-app.conf\n```\n\n使用以下配置\n```nginx\nserver {\n  listen        80;\n  server_name   localhost;\n  root          /home/www/cra-app;\n  index         index.php index.html;\n\n  location / {\n    try_files $uri $uri/ /index.php?$query_string;\n  }\n}\n```\n\n**注意： 虚拟机需要关闭 selinux**, 否则上面配置会没法显示;\n\n\n```bash\n# 查看seLinux 状态\ngetenforce\n```\n\n关闭它\n\n```bash\nsudo vim /etc/selinux/config \n# SELINUX=enforcing改为   SELINUX=disabled\n```\n\n这里记录一下`nginx` **root** 与**alias** 的区别 \n\n#### 当我们这样设置 root 的时候：\n\n```nginx\nlocation /i/ {\n    root /data/w3;\n}\n```\n\n当请求 `/i/top.gif` ，`/data/w3/i/top.gif` 会被返回。\n\n\n#### 当我们这样设置 alias 的时候：\n\n```bash\nlocation /i/ {\n    alias /data/w3/images/;\n}\n\n```\n\n当请求 `/i/top.gif` ，`/data/w3/images/top.gif` 会被返回。\n\n乍一看两者很像，但细一看，就能看出两者的区别，`root` 是直接拼接 `root + location` 而 `alias` 是用 `alias` 替换 `location`，所以 `root` 中最后的路径里有 `/i/`，而 `alias` 中最后的路径里没有  `/i/` 。\n\n所以如果你这样使用 allias 定义一个路径：\n\n```nginx\nlocation /images/ {\n    alias /data/w3/images/;\n}\n```\n\n其实使用 root 会更好：\n\n```nginx\nlocation /images/ {\n    root /data/w3;\n}\n```\n\n#### server 和 location 中的 root\n\nserver 和 location 中都可以使用 root，举个例子：\n\n```nginx\nhttp { \n  server {\n    listen 80;\n    server_name www.yayujs.com;\n    root /home/www/website/;\n    location / {\n        root /home/www/ts/;\n        index index.html;\n    }\n  }\n}\n\n```\n\n如果两者都出现，是怎样的优先级呢？\n简单的来说，就是就近原则，如果 location 中能匹配到，就是用 location 中的 root 配置，忽略 server 中的 root，当 location 中匹配不到的时候，则使用 server 中的 root 配置。","tags":["jenkins"],"categories":["jenkins"]},{"title":"React Router 源码学习","url":"/2022/05/03/react-router 学习/","content":"\n## BrowserRouter\n\n先看一些例子\n\n```jsx\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <BrowserRouter>\n        <Routes>\n          <Route path=\"/\" element={<Layout />}>\n            <Route index element={<Home/>} />\n            <Route path=\"/courses\" element={<CourseLayout />}>\n              <Route index element={<CourseIndex/>} />\n              <Route path=\"/courses/:id\" element={<Course/>} />\n            </Route>\n          </Route>\n          {/* <Route path=\"*\" element={<NotMatch/>} /> */}\n        </Routes>\n      </BrowserRouter>\n    </BrowserRouter>\n  )\n}\n\n```\n\n源码实现\n\n* 使用 `history` 库 创建 `BrowserHistory`\n* 监听当前`history`变化, 即当 url 中的location 发生变化时, 会重新setState\n* 讲这些参数传到`<Router />`组件中， `<Router />` 组件 其实就是包含两个 `provider` 的 context\n\n```jsx\nexport function BrowserRouter({\n  basename,\n  children,\n  window,\n}: BrowserRouterProps) {\n  let historyRef = React.useRef<BrowserHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({ window });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\n```\n\n* <Router /> 组件简易实现\n\n传下去的children 就是 <Routes />, 后面需要对 `Routes`下的children 进行遍历\n\n```jsx\nconst Router = (props) => {\n  const { \n    basename, \n    children, \n    location: locationProps \n    navigator\n  } = props;\n\n  // 对当前locationProps 做处理，最后返回, 这里我直接用‘’ 表示\n  const location = {\n    pathname: '',\n    search: '',\n    hash: '',\n    state: '',\n    key: '',\n  }\n\n  // navigator 就是 history\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider\n        children={children}\n        value={{ location, navigationType }}\n      />\n    </NavigationContext.Provider>\n  )\n}\n```\n\n* 再来看 <Routes />\n\n```jsx\nexport function Routes({\n  children,\n  location,\n}: RoutesProps): React.ReactElement | null {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n```\n\n这里说明一下`<Route>` 就是一个空方法，但在下面遍历的时候会判断当前组件是不是`<Route />` 后面也是会直接收集`element` 属性\ncreateRoutesFromChildren 是对<Routes> 进行children 遍历，获取路由，这里会进行递归操作，如果<Route /> 进行嵌套的话，`element.props.children` 就会进行递归遍历\n在遍历过程中会**判断当前组件是不是<Route />，如果不是会报错**\n已上面例子为例： 就会生成以下结果：\n\n```jsx\n[\n  {\n    caseSensitive: '',\n    element: <Layout />,\n    index: '',\n    path: '/',\n    children: [\n      { \n        caseSensitive: '',\n        element: <Home />,\n        index: true,\n        path: undefined,\n      },\n      {\n        caseSensitive: '',\n        element: <CourseLayout />,\n        index: undefined,\n        path: \"/courses\",\n        children: [\n          // 略\n        ]\n      }\n    ]\n  }\n]\n```\n\n```jsx\n\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, (element) => {\n    if (!React.isValidElement(element)) {\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    }\n\n    // 判断当前children 是不是<Route /> 组件, 如果不是会报错，\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    let route: RouteObject = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n```\n\n* 在来看 useRoutes 这个hook, 这个hook 生成了一个ReactNode, 是一个 RouterContext.Provider 生成的节点\n\n  * 从上面得到的`routes`列表以及 `url 上的location` 可以得到符合当前地址的所有路由，数组顺序为路由的辈分关系\n  比如上面的 `/courses` 连接, 会得到一下匹配的路由\n\n  ```jsx\n  matches = [\n    {\n      params: {},\n      pathname: \"/\",\n      pathnameBase: \"/\",\n      route: [\n        { \n          caseSensitive: '',\n          element: <Layout />,\n          index: '',\n          path: '/',\n          children: [\n            // 略\n          ]\n        }\n      ]\n    },\n    { \n      params: {},\n      pathname: \"/courses\",\n      pathnameBase: \"/courses\",\n      route: [\n        { \n          caseSensitive: '',\n          element: <CourseLayout />,\n          index: undefined,\n          path: \"/courses\",\n          children: [\n            // 略\n          ]\n        }\n      ]\n    },\n    { \n      params: {},\n      pathname: \"/courses/\",\n      pathnameBase: \"/courses\",\n      route: [\n        { \n          caseSensitive: '',\n          element: <CourseIndex />,\n          index: true,\n          path: undefined,\n        }\n      ]\n    }\n  ]\n  ``` \n\n  * 生成节点, 这里的outlet 可以当做children，在官网上可以用 `<Outlet />` 表示 `children`\n    \n    * 如果有`element`, 那么用`provider` 包裹一下，**注意：这里是从孙子节点到爷爷节点反序构建节点的**\n\n    ```jsx\n    export function _renderMatches(\n      matches: RouteMatch[] | null,\n      parentMatches: RouteMatch[] = []\n    ): React.ReactElement | null {\n      if (matches == null) return null;\n      \n      return matches.reduceRight((outlet, match, index) => {\n        return (\n          <RouteContext.Provider\n            children={\n              match.route.element !== undefined ? match.route.element : outlet\n            }\n            value={{\n              outlet,\n              matches: parentMatches.concat(matches.slice(0, index + 1)),\n            }}\n          />\n        );\n      }, null as React.ReactElement | null);\n    }\n    ```\n    * 可以这么理解\n\n    ```jsx\n    // 第一次\n    let first = (\n      <RouteContext.Provider>\n        children={\n          <CourseIndex />\n        }\n        value={{ \n          outlet: null,\n          matches: matches.slice(0, 3)\n        }}\n      >\n      </RouteContext.Provider>\n    )\n    \n    // 第二次\n    let second = (\n      <RouteContext.Provider>\n        children={\n          <CourseLayout />\n        }\n        value={{ \n          outlet: first,\n          matches: matches.slice(0, 2)\n        }}\n      >\n      </RouteContext.Provider>\n    )\n\n    // 第三次\n     let third = (\n      <RouteContext.Provider>\n        children={\n          <Layout />\n        }\n        value={{ \n          outlet: second,\n          matches: matches.slice(0, 1)\n        }}\n      >\n      </RouteContext.Provider>\n    )\n    ```\n\n## 在嵌套的路由中渲染 children\n\n* [文档地址](https://reactrouter.com/docs/en/v6/api#outlet)\n* 嵌套路由中使用`children`, 是使用 `API` 中的 `<Outlet />`,\n* 我们知道上面在匹配`matches` 的时候, 会进行`<RouteContext.Provider />`封装，同时传递 `outlet` 给他的子组件，那么`<OutLet /> `可以消费他的`context` \n* <Outlet /> 实现\n\n```jsx\nconst OutletContext = React.createContext<unknown>(null);\n\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n```\n\n## Link 组件实现\n\n* Link 其实是用 `<a />` 标签 做的,\n* 当我们传入自定义`onClick` 事件，会在点击时运行，后续会判断一下`event.defaultPrevented`， 表明当前事件是否被调用了，如果没有则调用内置`internalOnClick` 事件\n\n```jsx\nexport const Link = React.forwardRef<HTMLAnchorElement, LinkProps>(\n  function LinkWithRef(\n    { onClick, reloadDocument, replace = false, state, target, to, ...rest },\n    ref\n  ) {\n    let href = useHref(to);\n    let internalOnClick = useLinkClickHandler(to, { replace, state, target });\n    function handleClick(\n      event: React.MouseEvent<HTMLAnchorElement, MouseEvent>\n    ) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented && !reloadDocument) {\n        internalOnClick(event);\n      }\n    }\n\n    return (\n      <a\n        {...rest}\n        href={href}\n        onClick={handleClick}\n        ref={ref}\n        target={target}\n      />\n    );\n  }\n);\n```\n\n`useLinkClickHandler` 的实现\n\n其实就是调用了 `history.push` 或者是 `history.replace` 做跳转\n\n```jsx\nexport function useLinkClickHandler<E extends Element = HTMLAnchorElement>(\n  to: To,\n  {\n    target,\n    replace: replaceProp,\n    state,\n  }: {\n    target?: React.HTMLAttributeAnchorTarget;\n    replace?: boolean;\n    state?: any;\n  } = {}\n): (event: React.MouseEvent<E, MouseEvent>) => void {\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to);\n\n  return React.useCallback(\n    (event: React.MouseEvent<E, MouseEvent>) => {\n      if (\n        // 表示用户点击了鼠标左键\n        event.button === 0 &&\n        (!target || target === \"_self\") &&\n        !isModifiedEvent(event) \n      ) {\n        event.preventDefault();\n\n        // 判断一下当前应该用 history.replace 还是 history.push\n        let replace =\n          !!replaceProp || createPath(location) === createPath(path);\n\n        navigate(to, { replace, state });\n      }\n    },\n    [location, navigate, path, replaceProp, state, target, to]\n  );\n}\n\n```\n\n`useNavigation` 实现\n\n一开始 `<BrowserHistory />` 下的`<Router />` 使用 `<NavigationContext.Provider />` 下发 `navigator`,\n最后返回 `navigate` 方法，实际上就是 `history.replace` 或者是 `history.push`\n\n```jsx\nexport type Navigator = Pick<History, \"go\" | \"push\" | \"replace\" | \"createHref\">;\n```\n\n```jsx\nexport function useNavigate(): NavigateFunction {\n  // 这里拿到 navigator， 实际就是 history， 就是一开始 createBrowserHistory\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !== \"/\") {\n        path.pathname = joinPaths([basename, path.pathname]);\n      }\n      // 最后这里 进行 history.replace 或者是 history.push\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    },\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n}\n```\n\n\n\n","tags":["react-router"],"categories":["react-router"]},{"title":"记录一下从rc-tree 里面学到了什么东西","url":"/2022/04/22/记录一下从rc-tree 里面学到了什么东西/","content":"\n[rc-tree](https://github.com/react-component/tree)\n\n该文章主要对 `TreeNode` 的 `onChecked` 时，如何跟上级还有下级做联动所记录的 \n\n## 先看传入到tree下的 treeData 结构\n\n```js\nconst treeData = [\n  { \n    title: '1', \n    key: '1', \n    children: [\n      { \n        title: '1-1', \n        key: '1-1',\n        children: [\n          {\n            title: '1-1-1', \n            key: '1-1-1',\n          }\n        ] \n      }\n    ]\n  },\n  {\n    title: '2', \n    key: '2',\n    children: [\n      { \n        title: '2-1', \n        key: '2-1',\n        children: [\n          {\n            title: '2-1-1', \n            key: '2-1-1',\n          }\n        ] \n      }\n    ]\n  }\n]\n```\n\n## Tree 使用了Provider 向下级组件传递onNodeChecked 事件\n\n源码中用 `class` 组件的形式写的， 下面给个例子： \n\n\n```tsx\nexport const TreeContext = React.createContext(null);\n```\n\n```jsx\nconst Tree = () => {\n  const onNodeChecked = () => {}\n\n  return (\n    <TreeContext.Provider\n      value={{\n        onNodeChecked\n      }}\n    >\n      <NodeList>\n    <TreeContext.Provider>\n  )\n}\n\n```\n\n消费provider, 类组件例子\n\n```jsx\nconst ContextTreeNode: React.FC<TreeNodeProps> = props => (\n  <TreeContext.Consumer>\n    {context => <InternalTreeNode {...props} context={context} />}\n  </TreeContext.Consumer>\n);\n```\n\n函数组件，消费context\n```jsx\nconst TreeNode = () => {\n  const context = useContext(TreeContext)\n\n  return (\n    <div />\n  )\n}\n```\n\n### 在Tree 接收到treeData 这个props 的时候会进行数据转换\n\n在源码中，在 `getDerivedStateFromProps` 这个生命周期对treeData 进行转换。\n\n```jsx\nclass Tree extends Component {\n  static getDerivedStateFromProps(props, prevState) {\n    const { treeData, fieldNames } = props;\n    const newState = {  }\n\n    if (treeData) {\n      newState.treeData = treeData;\n      const entitiesMap = convertDataToEntities(treeData, { fieldNames });\n      newState.keyEntities = {\n        ...entitiesMap.keyEntities,\n      };\n    }\n  }\n\n}\n\n```\n\n##### convertDataToEntities 将 treeData 的key 当作键名，value 是当前节点，另外添加他的父节点，最后数据结构应该是这样：\n\n以上面treeData 为例子\n\n```jsx\n{\n  1: { \n    title: '1', \n    key: '1', \n    parentNode: null,\n    children: [\n      { \n        title: '1-1', \n        key: '1-1',\n        children: [\n          {\n            title: '1-1-1', \n            key: '1-1-1',\n          }\n        ] \n      }\n    ]\n  },\n  '1-1':  { \n    title: '1-1', \n    parentNode: '1',\n    key: '1-1',\n    children: [\n      {\n        title: '1-1-1', \n        key: '1-1-1',\n      }\n    ] \n  }\n  '1-1-1': { \n    parentNode: '1-1',\n    title: '1-1-1', \n    key: '1-1-1',\n  }\n}\n```\n\n* 我们尝试自己写一下这个方法\n\n```jsx\n// 建立双链表形式的map数据, \nconst convertDataToEntities = (treeData) => {\n  const result = {};\n\n  formatedTreeData(treeData, result, 0, 0);\n  console.log(result);\n\n  return {\n    keyEntities: result\n  }\n}\n\nconst formatedTreeData = (treeData, hash, parentKey, level) => {\n  const parentNode = hash[parentKey] || null;\n\n  treeData.forEach((_item) => {\n    hash[_item.key] = {\n      ..._item,\n      parentNode: parentNode,\n      level: level,\n    }\n    if (_item.children) {\n      formatedTreeData(_item.children, hash, _item.key, level + 1)\n    }\n  })\n}\n\n// const { keyEntities } = convertDataToEntities(treeData)\n```\n\n接下来实现 onNodeChecked, 选中当前节点时他的下级节点，以及上级节点联动关系\n\n* 先根据 `keyEntities` 获取当前树的最大深度, 因为我们当前keyEntities 已经保存有树的深度了，所以只要一次遍历就可以获取到最大的深度\n  在遍历过程中同时对每一层节点进行保存， 即第一层有哪些节点，第二层有哪些节点，我们命名为`levelMap`\n\n* 然后维护chekedKeys 这个已选中的节点\n* 从最开始那层 从上而下，遍历每一层节点， 如果当前checkedKeys 包含 当前levelMap[level][item] 那么他的children 应该也需要添加到checkedKeys 里面\n* 从最后那层 由下而上，遍历每层节点，如果当前checkedKeys 包含当前节点的所有children，那么他的父级节点需要被添加到checkedKeys 里面\n\n```jsx\nconst onNodeChecked = (e, checkedNode, isChecked) => {\n  const { levelMap, maxLevel } = getLevelEntities(keyEntities);\n\n  if (isChecked) {\n    // const keys = [...checkedKeys, checkedNode.key];\n    const keys = ['1-2']\n    const { halfChecked, checkedKeys } = fillConductCheck(keys, levelMap, maxLevel);\n    console.log(checkedKeys); // 会发现 [1-1-1, 1-1, 1]\n  }\n\n}\n\nconst getLevelEntities = (keyEntities) => {\n  let maxLevel = 0\n\n  const levelMap = {}\n\n  Object.keys(keyEntities).forEach((_item) => {\n    const current = keyEntities[_item];\n    const { level } = current;\n    maxLevel = Math.max(maxLevel, level);\n\n    if (typeof levelMap[level] === 'undefined') {\n      levelMap[level] = [];\n    }\n    levelMap[level].push(current);\n  })\n\n  return { levelMap, maxLevel }\n}\n```\n\n![getLevelEntities结果](./%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E4%BB%8Erc-tree%20%E9%87%8C%E9%9D%A2%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/1.png)\n\n```jsx\nconst fillConductCheck = (keys, levelEntities, maxLevel) => {\n  const checkedKeys = new Set(keys);\n  const halfCheckedKeys = new Set();\n\n  // 从上而下 勾选\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities[level] || new Set();\n    entities.forEach(entity => {\n      const { key, children = [] } = entity;\n\n      if (checkedKeys.has(key)) {\n        children\n          .forEach(childEntity => {\n            checkedKeys.add(childEntity.key);\n          });\n      }\n    });\n  }\n\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities[level] || new Set();\n    entities.forEach(entity => {\n      const { parentNode, node } = entity;\n\n      // Skip if no need to check\n      if (!entity.parentNode || visitedKeys.has(entity.parentNode.key)) {\n        return;\n      }\n\n      let allChecked = true;\n      let partialChecked = false;\n\n      (parentNode.children || [])\n        .forEach(({ key }) => {\n          const checked = checkedKeys.has(key);\n          if (allChecked && !checked) {\n            allChecked = false;\n          }\n          if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n            partialChecked = true;\n          }\n        });\n\n      if (allChecked) {\n        checkedKeys.add(parentNode.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parentNode.key);\n      }\n\n      visitedKeys.add(parentNode.key);\n    });\n  }\n\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: halfCheckedKeys,\n  };\n}\n```\n\n\n\n","tags":["antd","组件"]},{"title":"学习webpack源码(2)","url":"/2022/02/22/学习webpack源码(2)/","content":"\n## 调试\n\n在vscode 中创建调试文件，进行debug, 点击debug，自动创建即可\n\n```js\n{\n  // 使用 IntelliSense 了解相关属性。 \n  // 悬停以查看现有属性的描述。\n  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n  \n    {    \n        \"type\": \"node\",   \n          \"request\": \"launch\",   \n          \"name\": \"debugWebpack\",   \n          \"program\": \"${workspaceFolder}/bin/webpack.js\",  \n          \"console\": \"integratedTerminal\",   \n          \"cwd\": \"${workspaceFolder}\",   \n          \"args\": [        \n            //  \"${workspaceFolder}/examples/examples.js\",   \n            // webpack example 目录，我们选其中一个进行调试即可， 详细 example/README.md\n            \"${workspaceFolder}/examples/commonjs/example.js\",   \n        ]\n    }\n  ]\n}\n```\n\n接之前一篇文章, 创建`compiler`\n1. 接下来可以配合官方文档进行阅读[compiler hook](https://webpack.docschina.org/api/compiler-hooks/)按照官方顺序就是compiler整个生命周期\n\n## 梳理 compiler 生命周期\n1. 首先进行环境初始化, 即`compiler.hook.environment.call()`, 但全局搜索没有做订阅\n2. 环境初始化后会到 `compiler.hook.afterEnvironment.call()`, 说明环境初始化完成， `IgnoringWatchFileSystem`, 应该是做忽略某些文件的监听\n3. 从`lib/webpack` 中的 `new WebpackOptionsApply().process(options, compiler);` 这里其实是对 `option` 的配置进行plugin 的加载，且对compiler 对应周期进行注册监听事件。\n所以这里会经历一个 `entryOption` 的周期， \n例如：`entry 入口`, \n\n```js\n// 处理入口文件, SyncBailHook , 当返回为非undefined时停止往下执行\nnew EntryOptionPlugin().apply(compiler);\n// 执行入口文件回调\ncompiler.hooks.entryOption.call(options.context, options.entry);\n```\n\n```js\n// EntryOptionPlugin\nclass EntryOptionPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.entryOption.tap(\"EntryOptionPlugin\", (context, entry) => {\n\t\t\tEntryOptionPlugin.applyEntryOption(compiler, context, entry);\n\t\t\treturn true;\n\t\t});\n\t}\n  /** 省略其余code */\n}\n```\n\n其余配置也差不多， 然后会执行`compiler.hooks.afterPlugins.call(compiler);` 说明所有的插件已经加载完毕。\n最后调用`compiler.hooks.afterResolvers.call(compiler);` 表示compiler 中3种类型的解析器已经全部设置完成，`new WebpackOptionsApply().process(options, compiler);` 执行完毕\n\n4. 然后 执行 `compiler.hook.initialize.call()` \n5. 最后回到 `lib/webpack` 执行 `compiler.run()`\n\n\n## Compiler \n\n上面已经通过 `new Compiler(options.context)` 创建compiler, 然后调用`compiler.run()` \n进入`lib/compiler.js` 可以看到创建了多个hooks, [关于tapable, 我觉得这篇文章挺好](https://zhuanlan.zhihu.com/p/100974318)\n\n1. `run` 方法执行， 经历了两个`hooks (hooks.beforeRun, hooks.run)`, 最后执行 `this.compiler()`\n\n```js\ncompile(callback) {\n  // 创建 normalFactory, 跟 contextFactory, 创建完成之后调用 hooks.normalModuleFactory.call(); hooks.contextModuleFactory.call()\n  const params = this.newCompilationParams();\n  this.hooks.beforeCompile.callAsync(params, err => {\n    if (err) return callback(err);\n\n    this.hooks.compile.call(params);\n\n    const compilation = this.newCompilation(params);\n\n    const logger = compilation.getLogger(\"webpack.Compiler\");\n\n    logger.time(\"make hook\");\n    this.hooks.make.callAsync(compilation, err => {\n      logger.timeEnd(\"make hook\");\n      if (err) return callback(err);\n\n      logger.time(\"finish make hook\");\n      this.hooks.finishMake.callAsync(compilation, err => {\n        logger.timeEnd(\"finish make hook\");\n        if (err) return callback(err);\n\n        process.nextTick(() => {\n          logger.time(\"finish compilation\");\n          compilation.finish(err => {\n            logger.timeEnd(\"finish compilation\");\n            if (err) return callback(err);\n\n            logger.time(\"seal compilation\");\n            compilation.seal(err => {\n              logger.timeEnd(\"seal compilation\");\n              if (err) return callback(err);\n\n              logger.time(\"afterCompile hook\");\n              this.hooks.afterCompile.callAsync(compilation, err => {\n                logger.timeEnd(\"afterCompile hook\");\n                if (err) return callback(err);\n\n                return callback(null, compilation);\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n}\n```\n\n2.创建 `NormalModuleFactory`, 跟 `contextModuleFactory`, 创建完成之后调用 `hooks.normalModuleFactory.call()`,`hooks.contextModuleFactory.call()`\n`NormalModuleFactory` 用来生成模块的\n\n3. 之后调用 `hooks.beforeCompile`， `beforeCompile` 在[LazyCompilationPlugin](https://github.com/webpack/webpack/blob/main/lib/hmr/LazyCompilationPlugin.js#L331) 下注册了, 这里跟hmr 热更新相关。 同时在[DllReferencePlugin](https://github.com/webpack/webpack/blob/main/lib/DllReferencePlugin.js#L51), 它是用来拆分bundle，提升构建速度的 [具体可以看这](https://webpack.docschina.org/plugins/dll-plugin/)\n\n4. 然后调用 `hook.compile`, 在这[DllReferencePlugin](https://github.com/webpack/webpack/blob/main/lib/DllReferencePlugin.js#L88), [ExternalsPlugin](https://github.com/webpack/webpack/blob/main/lib/ExternalsPlugin.js#L29), [DelegatedPlugin](https://github.com/webpack/webpack/blob/main/lib/DelegatedPlugin.js#L34)三个文件中注册了方法\n\n5. 创建 `compilation` 实例，该实例可以用于factorizeModule, buildModule, addModule， 以及对module的依赖收集, 执行 `compiler.hooks.thisCompilation.call` 以及\n`compiler.hooks.compilation.call`\n\n6. 执行`compiler.hooks.make` 正式进入到编译阶段\n   \n  1. 找到 `tapAsync` 函数， 通过调用`addEntry` 添加入口文件\n  ```js\n  compiler.hooks.make.tapAsync(\"EntryPlugin\", (compilation, callback) => {\n    compilation.addEntry(context, dep, options, err => {\n      callback(err);\n    });\n  });\n  ```\n  2. \n  ```js\n  addEntry(context, entry, optionsOrName, callback) {\n\t\t// TODO webpack 6 remove\n\t\tconst options =\n\t\t\ttypeof optionsOrName === \"object\"\n\t\t\t\t? optionsOrName\n\t\t\t\t: { name: optionsOrName };\n\n\t\tthis._addEntryItem(context, entry, \"dependencies\", options, callback);\n\t}\n  ```\n  3. 然后 `_addEntryItem`, 会判断是否是多入口等等，然后执行`compilation.hooks.addEntry.call` 表示添加入口文件完毕, 最后执行`addModuleTree`\n  ```js\n  this.addModuleTree(\n    {\n      context,\n      dependency: entry,\n      contextInfo: entryData.options.layer\n        ? { issuerLayer: entryData.options.layer }\n        : undefined\n    },\n    (err, module) => {\n      if (err) {\n        this.hooks.failedEntry.call(entry, options, err);\n        return callback(err);\n      }\n      this.hooks.succeedEntry.call(entry, options, module);\n      return callback(null, module);\n    }\n  );\n  ```\n  4. 来看看 `addModuleTree` 函数, `addModuleTree` 里面会执行一个 `handleModuleCreation`\n\n  ```js\n  const Dep = /** @type {DepConstructor} */ (dependency.constructor);\n  // 这里会找到直接找到normalModuleFactory\n  const moduleFactory = this.dependencyFactories.get(Dep);\n  this.handleModuleCreation(\n\t\t\t{\n\t\t\t\tfactory: moduleFactory,\n\t\t\t\tdependencies: [dependency],\n\t\t\t\toriginModule: null,\n\t\t\t\tcontextInfo,\n\t\t\t\tcontext\n\t\t\t},\n\t\t\t(err, result) => {\n\t\t\t\tif (err && this.bail) {\n          // error\n\t\t\t\t} else if (!err && result) {\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t} else {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n  ```\n\n  5. 然后 `handleModuleCreation` 会执行 `factorizeModule`, 先不用管回调\n\n  ```js\n  this.factorizeModule(\n    {\n      currentProfile,\n      factory,\n      dependencies,\n      factoryResult: true,\n      originModule,\n      contextInfo,\n      context\n    },\n    (err, factoryResult) => {\n      /** 省略部分代码， 只需要知道后续会进行 this.addModule(newModule, () => {}) */\n      const newModule = factoryResult.module;\n      this.addModule(newModule, () => {\n        // 下面会执行模块创建以及 依赖收集\n        this._handleModuleBuildAndDependencies(\n          originModule,\n          module,\n          recursive,\n          callback\n        );\n      })\n    }\n  )\n  ```\n\n  6. `this.factorizeModule` 其实就是简单的将当前模块 添加到一个异步队列中\n  ```js\n  // this.factorizeModule 通过new AsyncQueue 创建\n  this.factorizeQueue.add(options, callback);\n  ```\n\n  7. `factorizeQueue.add` 它是一个异步执行 队列，当有一个任务加入到队列中，最后会执行`setImmediate(root._ensureProcessing);`,\n  但值得注意的是`root` 这个参数设计的有点巧妙，是一种父子关系, `this.processDependenciesQueue 的children 包含 this.addModuleQueue, this.factorizeQueue , this.buildQueue` 最后会执行 `setImmediate(root._ensureProcessing);` 当前root 是`this.processDependenciesQueue`。 setImmediate 会在下一次事件循环中调用\n  ```js\n  /** @type {AsyncQueue<Module, Module, Module>} */\n\t\tthis.processDependenciesQueue = new AsyncQueue({\n\t\t\tname: \"processDependencies\",\n\t\t\tparallelism: options.parallelism || 100,\n\t\t\tprocessor: this._processModuleDependencies.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<Module, string, Module>} */\n\t\tthis.addModuleQueue = new AsyncQueue({\n\t\t\tname: \"addModule\",\n\t\t\tparent: this.processDependenciesQueue,\n\t\t\tgetKey: module => module.identifier(),\n\t\t\tprocessor: this._addModule.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<FactorizeModuleOptions, string, Module | ModuleFactoryResult>} */\n\t\tthis.factorizeQueue = new AsyncQueue({\n\t\t\tname: \"factorize\",\n\t\t\tparent: this.addModuleQueue,\n\t\t\tprocessor: this._factorizeModule.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<Module, Module, Module>} */\n\t\tthis.buildQueue = new AsyncQueue({\n\t\t\tname: \"build\",\n\t\t\tparent: this.factorizeQueue,\n\t\t\tprocessor: this._buildModule.bind(this)\n\t\t});\n  ```\n\n  8. ensureProcessing 会遍历当前实例的children，简单说就是遍历 addModuleQueue, factorizeQueue, buildQueue 三个AsyncQueue 然后从这三个实例的队列中找任务去执行\n  ```js\n  _ensureProcessing() {\n    // this = this.processDependenciesQueue,\n    // children 包含 this.addModuleQueue, this.factorizeQueue, this.buildQueue\n\t\tthis._willEnsureProcessing = false;\n\t\tif (this._queued.length > 0) return;\n\t\tif (this._children !== undefined) {\n\t\t\tfor (const child of this._children) {\n\t\t\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\t\t\tconst entry = child._queued.dequeue();\n\t\t\t\t\tif (entry === undefined) break;\n\t\t\t\t\tthis._activeTasks++;\n\t\t\t\t\tentry.state = PROCESSING_STATE;\n\t\t\t\t\tchild._startProcessing(entry);\n\t\t\t\t}\n\t\t\t\tif (child._queued.length > 0) return;\n\t\t\t}\n\t\t}\n\t\tif (!this._willEnsureProcessing) this._needProcessing = false;\n\t}\n  ```\n\n  9. child._startProcessing, 因为一直从入口过来， 此时的child 是factorize\n  ```js\n  _startProcessing(entry) {\n\t\tthis.hooks.beforeStart.callAsync(entry.item, err => {\n\t\t\tif (err) {\n\t\t\t\t// error 处理\n\t\t\t}\n\t\t\tlet inCallback = false;\n\t\t\ttry {\n\t\t\t\t// compliation._addModule 或者 compliation._factorizeModule 或者 compliation._buildModule\n        // 此时调用的是 compliation._factorizeModule\n\t\t\t\tthis._processor(entry.item, (e, r) => {\n\t\t\t\t\tinCallback = true;\n\t\t\t\t\tthis._handleResult(entry, e, r);\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tif (inCallback) throw err;\n\t\t\t\tthis._handleResult(entry, err, null);\n\t\t\t}\n\t\t\tthis.hooks.started.call(entry.item);\n\t\t});\n\t}\n  ```\n\n  10. `_factorizeModule` 调用了 NormalModuleFactory.create\n  调用了 `NormalModuleFactory.hooks.beforeResolve.callAsync`, `NormalModuleFactory.hooks.factorize.callAsync`\n  在`NormalModuleFactory.hooks.factorize.tapAsync`中调用了 `resolve.callAsync`,  在 `resolve.tapAsync` 主要目的是resolve 模块找到模块对应的`loader`\n  以及loader的路径，描述文件等，这里会执行 `enhance-loader`, 并且创建 `parse` 和 `generator` 赋值到`resolveData.createData `\n\n  ```js\n  Object.assign(data.createData, {\n    layer:\n      layer === undefined ? contextInfo.issuerLayer || null : layer,\n    request: stringifyLoadersAndResource(\n      allLoaders,\n      resourceData.resource\n    ),\n    userRequest,\n    rawRequest: request,\n    loaders: allLoaders,\n    resource: resourceData.resource,\n    context:\n      resourceData.context || getContext(resourceData.resource),\n    matchResource: matchResourceData\n      ? matchResourceData.resource\n      : undefined,\n    resourceResolveData: resourceData.data,\n    settings,\n    type,\n    parser: this.getParser(type, settings.parser),\n    parserOptions: settings.parser,\n    generator: this.getGenerator(type, settings.generator),\n    generatorOptions: settings.generator,\n    resolveOptions\n  });\n  ```\n\n  11. 继续执行 `nmf.hooks.afterResolve.callAsync` 和 `nmf.hooks.createModule.callAsync`\n\n  ```js\n  this.hooks.afterResolve.callAsync(resolveData, (err, result) => {\n    const createData = resolveData.createData;\n    this.hooks.createModule.callAsync(createData, resolveData,\n\t\t\t(err, createdModule) => {\n        if(!createModule) {\n          createdModule = new NormalModule(createData);\n        }\n        // SideEffectsFlagPlugin 这里做sideEffect\n        createdModule = this.hooks.module.call(\n          createdModule,\n          createData,\n          resolveData\n        );\n        // 执行完成后调用 hooks.factorize.callAsync 回调 传入当前module 信息, 也就是factory.create 的callback 再callback 中执行AsyncQueue.handleResult\n        return callback(null, createdModule);\n    })\n  })\n  ```\n\n  12. AsyncQueue.handleResult 执行了 加进异步队列的 callback 即 6.5 的回调 addModule, 此时又做了一次6.6 之后的循环 只是改成了`addModule`\n\n  13. `addModule` 经过上面一轮 后执行 \n  ```js\n  this._handleModuleBuildAndDependencies(\n    originModule,\n    module,\n    recursive,\n    callback\n  );\n  ```\n  \n  14. 在 `_handleModuleBuildAndDependencies` 会执行 `this.buildModule` 再回调中会构建依赖\n\n\n\n\n![流程图](./学习webpack源码(2)/2.png)","tags":["webpack"],"categories":["webpack"]},{"title":"学习webpack源码","url":"/2022/01/17/学习webpack源码/","content":"\n## webpack 执行文件\n\n`/bin/webpack` 这个文件相对简单，其实就是判断一下`webpack-cli` 是否已经安装，没有安装就调用命令安装，要是已经安装则使用`webpack-cli`\n\n### 1. 声明 `webpack-cli` 信息对象\n\n```js\nconst cli = {\n\tname: \"webpack-cli\",\n\tpackage: \"webpack-cli\",\n\tbinName: \"webpack-cli\",\n\tinstalled: isInstalled(\"webpack-cli\"),\n\turl: \"https://github.com/webpack/webpack-cli\"\n};\n```\n\n### 2. 判断 `webpack-cli` 是否有安装, 只要判断目录下`node_module` 是有`webpack-cli` 这个文件夹即可\n\n```js\nconst isInstalled = packageName => {\n\tif (process.versions.pnp) {\n\t\treturn true;\n\t}\n\n\tconst path = require(\"path\");\n\tconst fs = require(\"graceful-fs\");\n\n\tlet dir = __dirname;\n\n\tdo {\n\t\ttry {\n\t\t\tif (fs.statSync(path.join(dir, \"node_modules\", packageName)).isDirectory()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (_error) {\n\t\t\t// Nothing\n\t\t}\n\t} while (dir !== (dir = path.dirname(dir)));\n\n\treturn false;\n};\n```\n\n### 3. 判断 `webpack-cli` 是否有安装，如果有则调用`runCli`, 没有则 执行`runCommand`\n\n```js\nif (!cli.installed) {\n\tconst path = require(\"path\");\n\tconst fs = require(\"graceful-fs\");\n\tconst readLine = require(\"readline\");\n\n\tconst notify =\n\t\t\"CLI for webpack must be installed.\\n\" + `  ${cli.name} (${cli.url})\\n`;\n\n\tconsole.error(notify);\n\n\t/** 判断是使用yarn 还是node 还是其他的包管理工具 */\n\tlet packageManager;\n\n\tif (fs.existsSync(path.resolve(process.cwd(), \"yarn.lock\"))) {\n\t\tpackageManager = \"yarn\";\n\t} else if (fs.existsSync(path.resolve(process.cwd(), \"pnpm-lock.yaml\"))) {\n\t\tpackageManager = \"pnpm\";\n\t} else {\n\t\tpackageManager = \"npm\";\n\t}\n\n\tconst installOptions = [packageManager === \"yarn\" ? \"add\" : \"install\", \"-D\"];\n\n\tconsole.error(\n\t\t`We will use \"${packageManager}\" to install the CLI via \"${packageManager} ${installOptions.join(\n\t\t\t\" \"\n\t\t)} ${cli.package}\".`\n\t);\n\n\tconst question = `Do you want to install 'webpack-cli' (yes/no): `;\n\n\tconst questionInterface = readLine.createInterface({\n\t\tinput: process.stdin,\n\t\toutput: process.stderr\n\t});\n\n\tprocess.exitCode = 1;\n\tquestionInterface.question(question, answer => {\n\t\tquestionInterface.close();\n\t\t/** 命令行输入y 时，安装`webpack-cli`, 否则提示需要安装webpack-cli */\n\t\tconst normalizedAnswer = answer.toLowerCase().startsWith(\"y\");\n\n\t\tif (!normalizedAnswer) {\n\t\t\tconsole.error(\n\t\t\t\t\"You need to install 'webpack-cli' to use webpack via CLI.\\n\" +\n\t\t\t\t\t\"You can also install the CLI manually.\"\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\t\tprocess.exitCode = 0;\n\n\t\trunCommand(packageManager, installOptions.concat(cli.package))\n\t\t\t.then(() => {\n\t\t\t\trunCli(cli);\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tconsole.error(error);\n\t\t\t\tprocess.exitCode = 1;\n\t\t\t});\n\t});\n} else {\n\trunCli(cli);\n}\n```\n\n### 4. runCammand 执行命令\n\n```js\nconst runCommand = (command, args) => {\n\tconst cp = require(\"child_process\");\n\treturn new Promise((resolve, reject) => {\n\t\tconst executedCommand = cp.spawn(command, args, {\n\t\t\tstdio: \"inherit\",\n\t\t\tshell: true\n\t\t});\n\n\t\texecutedCommand.on(\"error\", error => {\n\t\t\treject(error);\n\t\t});\n\n\t\texecutedCommand.on(\"exit\", code => {\n\t\t\tif (code === 0) {\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\treject();\n\t\t\t}\n\t\t});\n\t});\n};\n\n```\n\n### 5. 最后 runCli, 执行`webpack-cli`\n\n```js\nconst runCli = cli => {\n\tconst path = require(\"path\");\n\t/** webpack-cli, 这里require.resolve 是获取webpack-cli.package.json 的目录路径 */\n\tconst pkgPath = require.resolve(`${cli.package}/package.json`);\n\tconst pkg = require(pkgPath);\n\trequire(path.resolve(path.dirname(pkgPath), pkg.bin[cli.binName]));\n};\n```\n\n## webpack-cli\n\n1. 上面所说运行`webpack-cli` 中的`package.json` 下的 `bin`, 即 `./bin/cli.js`\n2. `./bin/cli.js` 执行了 `runCli()` 从 `../lib/bootstrap` 中加载啊\n3. 然后执行了`cli = new WebpackCli()`, 然后调用了`cli.run()`\n4. `new WebpackCli()` 的构造函数中使用了 [commander](https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md)\n5. `cli.run` 调用了 `this.program.action` 回调 调用 `await loadCommandByName(commandToRun, true);`,然后在调用了 `makeCommand`, `makeCommand` 调用了 `loadWebpack`, 并且 `getBuiltInOptions` 创建了`webpack` 的`option` 也就是 `webpack.config.js`, 最后在`makeCommand` 调用了`command.action` 触发回调，调用了`await this.runWebpack(options, isWatchCommandUsed);`。\n总结一下流程 `this.program.action -> loadCommandByName -> makeCommad( loadWebpack, runWebpack )`\n6. runWebpack 执行了 createCompiler 然后返回 `this.webpack(option)`\n\n```js\nconst webpack = require('webpack');\nconst config = require('./webpack.config');\ncompiler = webpack(config)\ncompiler.run((err) => {\n\tconsole.log(err)\n})\n```\n\n## webpack 源码\n\n### 主入口\n```js\n// webpack.js\n// webpack 函数简易结构\ncosnt webpack = (option, callback) => {\n\t/** 先忽略掉watch */\n\tconst create = () => {\n\t\tlet compiler = createCompiler(option);\n\t\treturn { compiler };\n\t}\n\t/** 判断有没有回调，最终都是返回compiler */\n\tif (callback) {\n\t\tconst { compiler } = create()\n\t\tcompiler.run(() => {\n\t\t\tcallback()\n\t\t})\n\t\treturn compiler\n\t} else {\n\t\tconst { compiler } = create();\n\t\treturn compiler\n\t}\n\n\treturn compiler\n}\n```\n\n### createCompiler\n\n```js\n// lib/webpack.js\nconst createCompiler = rawOptions => {\n\t/** 序列化一下option */\n\tconst options = getNormalizedWebpackOptions(rawOptions);\n\t// 设置一下默认值比如context 设为当前运行目录\n\tapplyWebpackOptionsBaseDefaults(options);\n\t/** compiler 最主要的函数在于run 函数 */\n\tconst compiler = new Compiler(options.context);\n\tcompiler.options = options;\n\n\t// 加载plugins , 先加载我们配置文件下的plugin\n\tif (Array.isArray(options.plugins)) {\n\t\tfor (const plugin of options.plugins) {\n\t\t\tif (typeof plugin === \"function\") {\n\t\t\t\tplugin.call(compiler, compiler);\n\t\t\t} else {\n\t\t\t\tplugin.apply(compiler);\n\t\t\t}\n\t\t}\n\t}\n\t// 给option默认值\n\tapplyWebpackOptionsDefaults(options);\n\t/** 触发环境设置hooks */\n\tcompiler.hooks.environment.call();\n\tcompiler.hooks.afterEnvironment.call();\n\t// 给config 的 key/value 转换成插件 plugin\n\tnew WebpackOptionsApply().process(options, compiler);\n\tcompiler.hooks.initialize.call();\n\treturn compiler;\n};\n```\n\n![流程图](./学习webpack源码/1.png)\n","tags":["webpack"],"categories":["webpack"]},{"title":"typecript 类型体操","url":"/2022/01/05/typescript 类型体操/","content":"\n[原网站](https://github.com/type-challenges/type-challenges/blob/master/README.zh-CN.md)\n\n## 简单（easy）\n\n> pick\n\n```ts\ninterface Todo {\n  title: string\n  description: string\n  completed: boolean\n}\n\ntype TodoPreview = MyPick<Todo, 'title' | 'completed'>\n\nconst todo: TodoPreview = {\n    title: 'Clean room',\n    completed: false,\n}\n```\n\n<details>\n<summary><mark>说明 </mark></summary>\n\n```ts\ntype Pick<T extends Object, K extends keyof T> = {\n  [P in K]: T[P]\n}\n```\n</details>\n\n> ReadOnly\n\n```ts\ninterface Todo {\n  title: string\n  description: string\n}\n\nconst todo: MyReadonly<Todo> = {\n  title: \"Hey\",\n  description: \"foobar\"\n}\n\ntodo.title = \"Hello\" // Error: cannot reassign a readonly property\ntodo.description = \"barFoo\" // Error: cannot reassign a readonly property\n```\n<details>\n<summary><mark>说明 </mark></summary>\n\n```ts\ntype ReadOnly<T extends Object> = {\n  readonly [P in keyof T]: T[P]\n}\n```\n</details>\n\n\n> 元组转换成对象\n\n```ts\nconst tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const\n\ntype result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}\n```\n\n<details>\n<summary><mark>说明 </mark></summary>\n\n```ts\ntype TupleToObject<T extends readonly string[]> = {\n  [P in T[number]]: P\n}\n```\n</details>\n\n> 第一个元素\n\n```ts\ntype arr1 = ['a', 'b', 'c']\ntype arr2 = [3, 2, 1]\n\ntype head1 = First<arr1> // expected to be 'a'\ntype head2 = First<arr2> // expected to be 3\n```\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype First<T extends any[]> = T extends [infer Result,...infer Rest] ? Result : never;\n```\n</details>\n\n> 获取元素长度\n\n```ts\ntype tesla = ['tesla', 'model 3', 'model X', 'model Y']\ntype spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']\n\ntype teslaLength = Length<tesla> // expected 4\ntype spaceXLength = Length<spaceX> // expected 5\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Length<T extends readonly any[]> = T['length'];\n```\n</details>\n\n> Exclude\n\n```ts\n/** \n * 实现内置的Exclude <T，U>类型，但不能直接使用它本身。\n * 从联合类型T中排除U的类型成员，来构造一个新的类型。\n*/\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Exclude<T, U> = T extends U ? never : T\n```\n</details>\n\n> Awaited\n\n```ts\n假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。\n\n比如：Promise<ExampleType>，请你返回 ExampleType 类型。\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype MyAwaited<T> = T extends Promise<infer P> ? MyAwaited<P> : T;\n```\n</details>\n\n> IF\n\n实现一个 `IF` 类型，它接收一个条件类型 `C` ，一个判断为真时的返回类型 `T` ，以及一个判断为假时的返回类型 `F`。 `C` 只能是 `true` 或者 `false`， `T` 和 `F` 可以是任意类型。\n\n```ts\ntype A = If<true, 'a', 'b'>  // expected to be 'a'\ntype B = If<false, 'a', 'b'> // expected to be 'b'\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype If<C extends boolean, T, F> = T extends true ? T : F;\n```\n</details>\n\n> Concat\n\n在类型系统里实现 `JavaScript` 内置的 `Array.concat` 方法，这个类型接受两个参数，返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。\n\n```ts\ntype Result = Concat<[1], [2]> // expected to be [1, 2]\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Concat<T extends any[], P extends any[]> = [...T, ...P]\n```\n</details>\n\n\n> Include\n\n在类型系统里实现 `JavaScript` 的 `Array.includes` 方法，这个类型接受两个参数，返回的类型要么是 `true` 要么是 `false`。\n\n```ts\ntype isPillarMen = Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'> // expected to be `false`\n```\n\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Include<T extends readonly any[], P> = T extends [infer First,...infer Other] ? (Equal<First,U> extends true ? true: Includes<Other,U>) :false \n```\n</details>\n\n> Push\n\n在类型系统里实现通用的 `Array.push` 。\n\n```ts\ntype Result = Push<[1, 2], '3'> // [1, 2, '3']\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Push<T extends any[], U> = [...T, U]\n```\n</details>\n\n\n> Unshift\n\n实现类型版本的 `Array.unshift`。\n\n```ts\ntype Result = Unshift<[1, 2], 0> // [0, 1, 2,]\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Unshift<T extends any[], U> = [U, ...T]\n```\n</details>\n\n> Parameters\n\n实现内置的 Parameters 类型，而不是直接使用它，可参考[TypeScript官方文档](https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype)。\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never;\n```\n</details>\n\n## 中等\n\n> 获取函数返回类型 ReturnType\n\n不使用 `ReturnType` 实现 `TypeScript` 的 `ReturnType<T>` 范型。\n\n```ts\nconst fn = (v: boolean) => {\n  if (v)\n    return 1\n  else\n    return 2\n}\n\ntype a = MyReturnType<typeof fn> // 应推导出 \"1 | 2\"\n```\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype MyReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : never\n```\n</details>\n\n\n> 实现 omit\n\n不使用 `Omit` 实现 `TypeScript` 的 `Omit<T, K>` 范型。\n\n`Omit` 会创建一个省略 `K` 中字段的 `T` 对象。\n\n```tsx\ninterface Todo {\n  title: string\n  description: string\n  completed: boolean\n}\n\ntype TodoPreview = MyOmit<Todo, 'description' | 'title'>\n\nconst todo: TodoPreview = {\n  completed: false,\n}\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype MyPick<T, K extends keyof T> = {\n  [key in K]: T[key]\n}\n\ntype MyExclude<T, P> = T extends P ? never : T\n\ntype MyOmit<T, K extends keyof T> = MyPick<T, MyExclude<keyof T, K>>\n```\n</details>\n\n> Readonly 2\n\n实现一个通用`MyReadonly2<T, K>`，它带有两种类型的参数`T`和`K`。\n\n`K`指定应设置为`Readonly`的`T`的属性集。如果未提供`K`，则应使所有属性都变为只读，就像普通的`Readonly<T>`一样。\n\n```ts\ninterface Todo {\n  title: string\n  description: string\n  completed: boolean\n}\n\nconst todo: MyReadonly2<Todo, 'title' | 'description'> = {\n  title: \"Hey\",\n  description: \"foobar\",\n  completed: false,\n}\n\ntodo.title = \"Hello\" // Error: cannot reassign a readonly property\ntodo.description = \"barFoo\" // Error: cannot reassign a readonly property\ntodo.completed = true // OK\n```\n\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype MyReadonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n\ntype MyPick<T, K extends keyof T> = { [P in K]: T[P] }\n\ntype MyExclude<T, K> = T extends K ? never : T;\n\ntype MyOmit<T, K extends keyof T> = { [P in MyExclude<keyof T, K>]: T[P]}\n \n type MyReadonly2<T, K extends keyof T = keyof T> =MyReadonly<MyPick<T, K>>  & MyOmit<T, K>\n```\n</details>\n\n> 深度Readonly\n\n实现一个通用的DeepReadonly<T>，它将对象的每个参数及其子对象递归地设为只读。\n\n您可以假设在此挑战中我们仅处理对象。数组，函数，类等都无需考虑。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。\n\n```ts\ntype X = { \n  x: { \n    a: 1\n    b: 'hi'\n  }\n  y: 'hey'\n}\n\ntype Expected = { \n  readonly x: { \n    readonly a: 1\n    readonly b: 'hi'\n  }\n  readonly y: 'hey' \n}\n\ntype Todo = DeepReadonly<X> // should be same as `Expected`\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype DeepReadonly<T extends Object> = {\n  readonly [P in keyof T]: keyof T[P] extends never ? T[P] : DeepReadonly<T[P]>\n}\n\n```\n</details>\n\n> 元组转合集\n\n实现泛型`TupleToUnion<T>`，它覆盖元组的值与其值联合。\n\n\n```ts\ntype Arr = ['1', '2', '3']\n\ntype Test = TupleToUnion<Arr> // expected to be '1' | '2' | '3'\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype TupleToUnion<T extends any[]> = T extends [infer First,...infer Other] ? First | TupleToUnion<Other> : never;\n\n// 或者\n\ntype TupleToUnion<T extends any[]> = T[number];\n\n```\n</details>\n\n> 最后一个元素\n\n实现一个通用`Last<T>`，它接受一个`数组T`并返回其最后一个元素的类型。\n\n```ts\ntype arr1 = ['a', 'b', 'c']\ntype arr2 = [3, 2, 1]\n\ntype tail1 = Last<arr1> // expected to be 'c'\ntype tail2 = Last<arr2> // expected to be 1\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype Last<T extends any[]> = T extends [...infer K, infer Other] ? Other : never\n\n//或者\ntype Last<T extends any[]> = T extends [any, ...infer Rest] ? T[Rest['length']] : never\n\n```\n</details>\n\n> 出堆\n\n实现一个通用Pop<T>，它接受一个数组T并返回一个没有最后一个元素的数组。\n\n```ts\ntype arr1 = ['a', 'b', 'c', 'd']\ntype arr2 = [3, 2, 1]\n\ntype re1 = Pop<arr1> // expected to be ['a', 'b', 'c']\ntype re2 = Pop<arr2> // expected to be [3, 2]\n```\n\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype Pop<T extends any[]> = T extends [...infer K, infer Other] ? K : never\n\n```\n</details>\n\n\n> promise.all\n\n\n```TS\nconst promise1 = Promise.resolve(3);\nconst promise2 = 42;\nconst promise3 = new Promise<string>((resolve, reject) => {\n  setTimeout(resolve, 100, 'foo');\n});\n\n// expected to be `Promise<[number, number, string]>`\nconst p = Promise.all([promise1, promise2, promise3] as const)\n\n// declare function PromiseAll(values: any): any\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n// 跟上面awaited 相似\ntype MyAwaited<T> = T extends Promise<infer P> ? MyAwaited<P> : T;\n/** declare 重定义function, (values: readonly [...T]) 函数参数 Promise<> */\ndeclare function PromiseAll<T extends any[]>(values: readonly [...T]): Promise<{\n  [K in keyof T]:  MyAwaited<T[K]>\n}>\n\n```\n</details>\n\n> Type Lookup\n\n在此挑战中，我们想通过在联合`Cat | Dog`中搜索公共`type`字段来获取相应的类型。换句话说，在以下示例中，我们期望`LookUp<Dog | Cat, 'dog'>`获得`Dog`，`LookUp<Dog | Cat, 'cat'>`获得`Cat`。\n\n```ts\n\ninterface Cat {\n  type: 'cat'\n  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'\n}\n\ninterface Dog {\n  type: 'dog'\n  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'\n  color: 'brown' | 'white' | 'black'\n}\n\ntype MyDog = LookUp<Cat | Dog, 'dog'> // expected to be `Dog`\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype LookUP<T, U> = T extends { type: string } ? (T['type'] extends U ? T : never )  : never\n\n```\n</details>\n\n> Trim Left\n\n实现 `TrimLeft<T>` ，它接收确定的字符串类型并返回一个新的字符串，其中新返回的字符串删除了原字符串开头的空白字符串。\n\n```ts\ntype trimed = TrimLeft<'  Hello World  '> // 应推导出 'Hello World  '\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype TrimLet<T extends string> = T extends `${' '| '\\n' | '\\t'}${infer Rest}` ? TrimLeft<Rest> : T;\n\n```\n</details>\n\n> Trim\n\n```ts\ntype trimed = Trim<'  Hello World  '> // expected to be 'Hello World'\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype SpaceChar = ' ' | '\\n' | '\\t'\ntype Trim<S extends string> = S extends (`${SpaceChar}${infer R}` | `${infer R}${SpaceChar}`) ? Trim<R> : S\n\n```\n</details>\n\n\n> Capitalize \n\n首字母大写\n\n```ts\ntype capitalized = Capitalize<'hello world'> // expected to be 'Hello world'\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Capitalize<T extends string> = T extends (`${infer first}${infer R}`) ? `${Uppercase<first>}${R}` : T;\n\n```\n</details>\n\n> Replace\n\n实现 `Replace<S, From, To`> 将字符串 `S` 中的第一个子字符串 `From` 替换为 `To` 。\n\n```ts\ntype replaced = Replace<'types are fun!', 'fun', 'awesome'> // 期望是 'types are awesome!'\n```\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Replace<S extends string, From extends string, To extends string> = From extends '' ? S : S extends `${infer start}${From}${infer end}` ? `${start}${To}${end}` : S\n\n```\n</details>\n\n> ReplaceAll\n\n实现 `ReplaceAll<S, From, To>` 将一个字符串 `S` 中的所有子字符串 `From` 替换为 `To`。\n\n```ts\ntype replaced = ReplaceAll<'t y p e s', ' ', ''> // 期望是 'types'\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n/**\n * 请注意以下两种情况\n *  Expect<Equal<ReplaceAll<'foobarfoobar', 'ob', 'b'>, 'fobarfobar'>>,\n *  Expect<Equal<ReplaceAll<'foboorfoboar', 'bo', 'b'>, 'foborfobar'>>,\n */\n\n// 错误\ntype ReplaceAll<S extends string, From extends string, To extends string> =  From extends '' ? S : S extends `${infer start}${From}${infer end}` ? ReplaceAll<`${start}${To}${end}`, From, To> : S\n\n// 正确\ntype ReplaceAll<S extends string, From extends string, To extends string> =  From extends '' ? S : S extends `${infer start}${From}${infer end}` ? `${start}${To}${ReplaceAll<`${end}`, From, To>}` : S\n\n```\n</details>\n\n\n> 追加参数\n\n实现一个范型 `AppendArgument<Fn, A>`，对于给定的函数类型 `Fn`，以及一个任意类型 `A`，返回一个新的函数 `G`。`G` 拥有 `Fn 的所有参数`并在末尾追加类型为 `A` 的参数。\n\n```ts\ntype Fn = (a: number, b: string) => number\n\ntype Result = AppendArgument<Fn, boolean> \n// 期望是 (a: number, b: string, x: boolean) => number\n\n```\n\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype AppendArgument<Fn extends (...args: any[]) => any, T> = Fn extends ((...args: infer P) => infer R) ? (...args: [...P, T]) => R : never \n\n```\n</details>\n\n> Permutation\n\nImplement permutation type that transforms union types into the array that includes permutations of unions.\n\n```ts\ntype perm = Permutation<'A' | 'B' | 'C'>; // ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Permutation<T, U = T> = [T] extends [never] ? [] : T extends U ? [T, ...Permutation<Exclude<U, T>>] : []\n\n```\n</details>\n\n> Length of string\n\nCompute the length of a string literal, which behaves like String#length.\n\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype StringToArr<T extends String> = T extends `${infer F}${infer R}` ? [F, ...StringToArr<R>] : [];\n\ntype StringLength<T extends String> = StringToArr<T>['length']\n\n```\n</details>\n\n> Flatten\n\nIn this challenge, you would need to write a type that takes an array and emitted the flatten array type.\n\n```ts\ntype flatten = Flatten<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, 5]\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype Flatten<T extends any[]> = T extends [infer First, ...infer Other] ? First extends any[] ? [...Flatten<First>, ...Flatten<Other>] : [First, ...Flatten<Other>] : []\n\n```\n</details>\n\n> Append to object\n\nImplement a type that adds a new field to the interface. The type takes the three arguments. The output should be an object with the new field.\n\n```ts\ntype Test = { id: '1' }\ntype Result = AppendToObject<Test, 'value', 4> // expected to be { id: '1', value: 4 }\n```\n\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype AppendToObject<T extends object, U extends string, V> = { [K in keyof T | U]: K extends keyof T ? T[K] : V }\n\n\n```\n</details>\n\n> Absolute \n\n数字绝对值\n\n```ts\ntype Test = -100;\ntype Result = Absolute<Test>; // expected to be \"100\"\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Absolute<T extends number | string | bigint> = `${T}` extends `-${infer X}` ? X : `${T}`\n\n```\n</details>\n\n> String to Union\n\nImplement the String to Union type. Type take string argument. The output should be a union of input letters\n\n```ts\ntype Test = '123';\ntype Result = StringToUnion<Test>; // expected to be \"1\" | \"2\" | \"3\"\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype StringToUnion<T extends string> =  T extends `${infer F}${infer R}` ? F | StringToUnion<R> : never \n\n```\n</details>\n\n> Merge \n\nMerge two types into a new type. Keys of the second type overrides keys of the first type.\n\n```ts\ntype Foo = {\n  a: number;\n  b: string;\n};\ntype Bar = {\n  b: number;\n  c: boolean;\n};\ntype Result = Merge<Foo, Bar>; \n\n// {\n// \ta: number;\n// \tb: number;\n// \tc: boolean;\n// }\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Merge<F, S> = {[key in keyof F | keyof S]: key extends keyof S ? S[key] : key extends keyof F ? F[key] : never};\n\n```\n</details>\n\n> CamelCase\n\n`for-bar-baz` -> `forBarBaz`\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Capitalize<T extends string> = T extends (`${infer first}${infer R}`) ? `${Uppercase<first>}${R}` : T;\ntype CamelCase<T extends string> = T extends `${infer start}-${infer end}` ? `${start}${CamelCase<Capitalize<end>>}` : T\n\ntype Result = CamelCase<'foo--bar----baz'> // \"fooBarBaz\"\n\ntype CamelCase<S extends string> =  S extends `${infer X}-${infer Y}` ? Y extends Capitalize<Y> ? `${X}-${CamelCase<Y>}` : `${X}${CamelCase<Capitalize<Y>>}` : S ;\n\n//foo-Bar---Baz\n\n```\n</details>\n\n> KebabCase \n\n`FooBarBaz` -> `foo-bar-baz`\n\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype KebabCase<S extends string, P extends string = \"\"> = \n  S extends `${infer L}${infer R}`\n    ? L extends Lowercase<L> \n      ? `${L}${KebabCase<R, \"-\">}`\n      : `${P}${Lowercase<L>}${KebabCase<R, \"-\">}`\n    : S;\n\ntype b = KebabCase<'foo-bar'>\n\n```\n</details>\n\n> Diff\n\nGet an Object that is the difference between O & O1\n\n```ts\ntype Foo = {\n  name: string\n  age: string\n}\ntype Bar = {\n  name: string\n  age: string\n  gender: number\n}\n\nExpect<Equal<Diff<Foo, Bar>, { gender: number }>>\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Diff<O, O1> = {\n  [P in (keyof O | keyof O1) as Exclude<P, keyof O & keyof O1>]: P extends keyof O\n    ? O[P]\n    : P extends keyof O1\n      ? O1[P]\n      : never;\n};\n```\n</details>\n\n\n> AnyOf\n\nImplement Python liked any function in the type system. A type takes the Array and returns true if any element of the Array is true. If the Array is empty, return false.\n\n```ts\ntype Sample1 = AnyOf<[1, \"\", false, [], {}]>; // expected to be true.\ntype Sample2 = AnyOf<[0, \"\", false, [], {}]>; // expected to be false.\n```\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n// solution 1\ntype False = 0 | '' | false | [] | null | undefined | Record<any, never>;\ntype AnyOf<T extends readonly any[]> = T[number] extends False ? false : true;\n\n// solution 2\ntype False = 0 | '' | false | [] | null | undefined | Record<any, never>;\ntype AnyOf<T extends readonly any[]> = T extends [infer F, ...infer R] \n? F extends False ? AnyOf<R> : true \n: false;\n```\n</details>\n\n\n> isNever \n\nImplement a type IsNever, which takes input type `T`. If the type of resolves to `never`, return `true`, otherwise `false`.\n\n```\ntype A = IsNever<never>  // expected to be true\ntype B = IsNever<undefined> // expected to be false\ntype C = IsNever<null> // expected to be false\ntype D = IsNever<[]> // expected to be false\ntype E = IsNever<number> // expected to be false\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype isNever<T> = [T] extends [never] ? true : false\n\n```\n</details>\n\n> isUnion\n\nImplement a type IsUnion, which takes an input type `T` and returns whether `T` resolves to a union type.\n\n```ts\ntype case1 = IsUnion<string>  // false\ntype case2 = IsUnion<string|number>  // true\ntype case3 = IsUnion<[string|number]>  // false\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype IsUnion<T, U = T> = T extends T\n  ? (U | T) extends (U & T) ? false : true\n  : never\n\n```\n</details>\n\n> ReplaceKeys \n\nImplement a type ReplaceKeys, that replace keys in union types, if some type has not this key, just skip replacing, A type takes three arguments.\n如果\n\n```ts\ntype NodeA = {\n  type: 'A'\n  name: string\n  flag: number\n}\n\ntype NodeB = {\n  type: 'B'\n  id: number\n  flag: number\n}\n\ntype NodeC = {\n  type: 'C'\n  name: string\n  flag: number\n}\n\n\ntype Nodes = NodeA | NodeB | NodeC\n\ntype ReplacedNodes = ReplaceKeys<Nodes, 'name' | 'flag', {name: number, flag: string}> // {type: 'A', name: number, flag: string} | {type: 'B', id: number, flag: string} | {type: 'C', name: number, flag: string} // would replace name from string to number, replace flag from number to string.\n\ntype ReplacedNotExistKeys = ReplaceKeys<Nodes, 'name', {aa: number}> // {type: 'A', name: never, flag: number} | NodeB | {type: 'C', name: never, flag: number} // would replace name to never\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype ReplaceKeys<T, K, V> = {\n  [key in keyof T]: key extends K \n    ? key extends keyof V \n      ? V[key]\n      : never\n    : T[key]\n}\n\n```\n</details>\n\n> Remove Index Signature\n\nImplement `RemoveIndexSignature<T>`, exclude the index signature from object types.\n\n```ts\ntype Foo = {\n  [key: string]: any;\n  foo(): void;\n}\n\ntype A = RemoveIndexSignature<Foo>  // expected { foo(): void }\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype RemoveIndexSignature<T> = {\n  [key in keyof T as string extends key ? never : key extends number ? never : key]: T[key]\n}\n\n```\n</details>\n\n\n> Percentage Parser\n\nImplement PercentageParser. According to the `/^(\\+|\\-)?(\\d*)?(\\%)?$/` regularity to match `T` and get three matches.\n\nThe structure should be: `[plus or minus, number, unit]` If it is not captured, the default is an empty string.\n\n```ts\ntype PString1 = ''\ntype PString2 = '+85%'\ntype PString3 = '-85%'\ntype PString4 = '85%'\ntype PString5 = '85'\n\ntype R1 = PercentageParser<PString1>  // expected ['', '', '']\ntype R2 = PercentageParser<PString2>  // expected [\"+\", \"85\", \"%\"]\ntype R3 = PercentageParser<PString3>  // expected [\"-\", \"85\", \"%\"]\ntype R4 = PercentageParser<PString4>  // expected [\"\", \"85\", \"%\"]\ntype R5 = PercentageParser<PString5>  // expected [\"\", \"85\", \"\"]\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype PickPrefix<T extends string, S extends string> = T extends `${S}${infer P}`\n    ? T extends `${infer R}${P}` ? R : never\n    : '';\n\ntype PickSuffix<T extends string, S extends string> = T extends `${infer P}${S}`\n    ? T extends `${P}${infer R}` ? R : never\n    : '';\n\ntype PercentageParser<T extends string> = T extends `${PickPrefix<T, '+' | '-'>}${infer B}${PickSuffix<T, '%'>}`\n    ? T extends `${infer A}${B}${infer C}`\n        ? [A, B, C]\n        : ['', '', '']\n    : ['', '', ''];\n\n```\n</details>\n\n> Drop Char\n\nDrop a specified char from a string.\n\n```ts\ntype Butterfly = DropChar<' b u t t e r f l y ! ', ' '> // 'butterfly!'\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype DropChar<S, C> = S extends `${infer X}${infer Y}` ? `${X extends C ? \"\" : X}${DropChar<Y, C>}` : \"\"  \n```\n</details>\n\n> MinusOne \n\nGiven a number (always positive) as a type. Your type should return the number decreased by one.\n\n```ts\ntype Zero = MinusOne<1> // 0\ntype FiftyFour = MinusOne<55> // 54\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n[拓展](https://github.com/type-challenges/type-challenges/issues/5768)\n```ts\ntype Pop<T extends any[]> = T extends [...infer head, any] ? head : never; \n\ntype MinusOne<T extends number, A extends any[] = []> = A['length'] extends T\n  ? Pop<A>['length']\n  : MinusOne<T, [...A, 0]>\n```\n</details>\n\n> PickByType\n\nFrom `T`, pick a set of properties whose type are assignable to `U`.\n\n```ts\ntype OnlyBoolean = PickByType<{\n  name: string\n  count: number\n  isReadonly: boolean\n  isEnable: boolean\n}, boolean> // { isReadonly: boolean; isEnable: boolean; }\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype PickByType<T, U> = {\n  [key in keyof T as T[key] extends U ? key : never]: T[key] \n}\n```\n</details>\n\n> StartsWith\n\nImplement `StartsWith<T, U>` which takes two exact string types and returns whether `T` starts with `U`\n\n```ts\ntype a = StartsWith<'abc', 'ac'> // expected to be false\ntype b = StartsWith<'abc', 'ab'> // expected to be true\ntype c = StartsWith<'abc', 'abcd'> // expected to be false\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype StartsWith<T extends string, U extends string> = T extends `${U}${infer Other}` ? true : false\n```\n</details>\n\n> EndsWith\n\nImplement `EndsWith<T, U>` which takes two exact string types and returns whether `T` ends with `U`\n\n```ts\ntype a = EndsWith<'abc', 'bc'> // expected to be true\ntype b = EndsWith<'abc', 'ab'> // expected to be false\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype EndsWith<T extends string, U extends string> = T extends `${infer Other}${U}` ? true : false\n```\n</details>\n\n> PartialByKeys\n\nImplement a generic `PartialByKeys<T, K>` which takes two type argument `T` and `K`.\n\n`K` specify the set of properties of `T` that should set to be optional. When `K` is not provided, it should make all properties optional just like the normal `Partial<T>`.\n\n```ts\ninterface User {\n  name: string\n  age: number\n  address: string\n}\n\ntype UserPartialName = PartialByKeys<User, 'name'> // { name?:string; age:number; address:string }\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Merge<A, B> = Pick<A & B, keyof A | keyof B>\ntype PartialByKeys<T , K = keyof T> = Merge<{[key in keyof T as key extends K ? key : never]?: T[key]}, {[key in keyof T as key extends K ? never : key]: T[key]}>\n```\n</details>\n\n\n> RequiredByKeys\n\nImplement a generic `RequiredByKeys<T, K>` which takes two type argument `T` and `K`.\n\n`K` specify the set of properties of `T` that should set to be required. When `K` is not provided, it should make all properties required just like the normal `Required<T>`.\n\n```ts\ninterface User {\n  name?: string\n  age?: number\n  address?: string\n}\n\ntype UserPartialName = RequiredByKeys<User, 'name'> // { name: string; age?: number; address?: string }\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Merge<A, B> = Pick<A & B, keyof A | keyof B>\ntype IsRequire<T, U> = {\n  [key in keyof T as key extends U  ? key : never]-?: T[key]\n}\n\ntype Origin<T, U> = {\n  [key in keyof T as key extends U  ? never : key]: T[key]\n}\n\ntype RequiredByKeys<T, U = keyof T> = Merge<IsRequire<T, U>, Origin<T, U>>\n\n```\n</details>\n\n\n> Mutable\n\nImplement the generic `Mutable<T>` which makes all properties in `T` mutable (not readonly).\n\n```ts\ninterface Todo {\n  readonly title: string\n  readonly description: string\n  readonly completed: boolean\n}\n\ntype MutableTodo = Mutable<Todo> // { title: string; description: string; completed: boolean; }\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Mutable<T> = {\n  -readonly [key in keyof T]: T[key]\n}\n\n```\n</details>\n\n> OmitByType\n\nFrom `T`, pick a set of properties whose type are not assignable to `U`.\n\n```ts\ntype OmitBoolean = OmitByType<{\n  name: string\n  count: number\n  isReadonly: boolean\n  isEnable: boolean\n}, boolean> // { name: string; count: number }\n```\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype OmitByType<T, U> = {\n  [key in keyof T as T[key] extends U ? never : key]: T[key]\n}\n\n```\n</details>\n\n> ObjectEntries \n\nImplement the type version of `Object.entries`\n\n```ts\ninterface Model {\n  name: string; \n  age: number;\n  locations: string[] | null;\n}\ntype modelEntries = ObjectEntries<Model> // ['name', string] | ['age', number] | ['locations', string[] | null];\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype ObjectEntries<T, K = keyof T> = K extends keyof T ? [K, Required<T>[K]] : never;\n\n```\n</details>\n\n> Shift\n\nImplement the type version of `Array.shift`\n\n```ts\ntype Result = Shift<[3, 2, 1]> // [2, 1]\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Shift<T extends any[]> = T extends [infer First, ...infer Other] ? Other : never\n\n```\n</details>\n\n> Tuple to Nested Object\n\nGiven a tuple type `T` that only contains string type, and a type `U`, build an object recursively.\n\n```ts\ntype a = TupleToNestedObject<['a'], string> // {a: string}\ntype b = TupleToNestedObject<['a', 'b'], number> // {a: {b: number}}\ntype c = TupleToNestedObject<[], boolean> // boolean. if the tuple is empty, just return the U type\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype TupleToNestedObject<T extends any[], U> = T['length'] extends 0 ? U : T extends [infer First, ...infer Other] \n  ? { [P in T[0]]: Other['length'] extends 0 ? U : TupleToNestedObject<Other, U> }\n  : never\n\n```\n</details>\n\n> Reverse\n\nImplement the type version of `Array.reverse`\n\n```ts\ntype a = Reverse<['a', 'b']> // ['b', 'a']\ntype b = Reverse<['a', 'b', 'c']> // ['c', 'b', 'a']\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Reverse<T extends any[]> = T extends [...infer Other, infer Last] ? [Last, ...Reverse<Other>] : []\n\n```\n</details>\n\n> Flip Arguments\n\nImplement the type version of lodash's `_.flip`.\n\nType `FlipArguments<T>` requires function type `T` and returns a new function type which has the same return type of T but reversed parameters.\n\n```ts\ntype Flipped = FlipArguments<(arg0: string, arg1: number, arg2: boolean) => void> \n// (arg0: boolean, arg1: number, arg2: string) => void\n```\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\ntype Reverse<T extends any[]> = T extends [...infer Other, infer Last] ? [Last, ...Reverse<Other>] : []\n\ntype FlipArguments<T extends (...args: any[]) => any > = T extends (...args: infer P) => infer Q\n  ? (...args: Reverse<P>) => Q\n  : never;\n\n```\n</details>\n\n> FlattenDepth\n\nRecursively flatten array up to depth times.\n\n```ts\ntype a = FlattenDepth<[1, 2, [3, 4], [[[5]]]], 2> // [1, 2, 3, 4, [5]]. flattern 2 times\ntype b = FlattenDepth<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, [[5]]]. Depth defaults to be 1\n```\n\n<details>\n<summary><mark>查看答案 </mark></summary>\n\n```ts\n\ntype FlattenOnce<T extends unknown[]> = T extends [infer First, ...infer Rest]\n? First extends unknown[]\n  ? [...First, ...FlattenOnce<Rest>]\n  : [First, ...FlattenOnce<Rest>]\n: [];\ntype t1 = FlattenOnce<[[2], [[3]], 4]>;\ntype FlattenDepth<T extends unknown[], N extends number = 1, C extends unknown[] = []>\n= C[\"length\"] extends N ? T\n: T extends FlattenOnce<T> ? T\n: FlattenDepth<FlattenOnce<T>, N, [...C, unknown]>;\n\n```\n</details>","tags":["typescript"],"categories":["typescript"]},{"title":"对近期工作的一些思考","url":"/2021/10/07/对近期工作的一些思考/","content":"\n## 业务工作\n\n之前要做一个类似于`装修模块的东西`，比如`app 首页，活动页等等`，如下图所示\n\n![图例](./对近期工作的一些思考/1.jpg)\n\n左边是一个`组件树`， 中间是`整个内容模块的展示`， 右边是`对所选中的内容进行编辑`\n\n## 技术栈\n\n因为之前同事是使用[brick-design](https://github.com/brick-design/brick-design) 做二次开发的，所以也就继续沿用了。\n\n用`lerna` 去管理这些包，比如`brick-design`， 还有一些`组件`。最后`build` 的时候会放到`私有源`上\n\n## 开发准备工作\n\n因为`brick-design` 作为工具库，所以我们要通过`yarn add` 的方式去安装，所以在开发时候需要使用到`npm link` 到`brick-design` 上。\n具体查看[npm link](https://www.jianshu.com/p/82076fc481a6)\n\n## brick-design 原理\n\n**brick-design原理:** 它是通过去维护整个`pageConfig`去实现组件自定义，`pageConfig`就是一个`用数据结构表达的一颗树`，每个节点都有一个`props`。\n\n数据结构如下：\n```jsx\nconst pageConfig = {\n\t\"1\": {\n\t\tcomponentName: 'Layout',\n\t\ttitle: '组件树',\n\t\tprops: {\n\t\t\tstyle: {\n\t\t\t\twidth: '100%',\n\t\t\t}\n\t\t},\n\t\tchildNodes: ['2']\n\t},\n\t\"2\": {\n\t\tcomponentName: 'CouponContainer', // 需要到 <BrickProvider config={} /> config 需要注册该组件, 不然会找不到该组件\n\t\ttitle: '优惠券容器',\n\t\tprops: {},\n\t\tchildNodes: ['3']\n\t},\n\t\"3\": {\n\t\tcomponentName: 'CouponItem',\n\t\ttitle: '优惠券1',\n\t\tprops: {\n\t\t\tname: '优惠券名',\n\t\t\tid: '优惠券id'\n\t\t},\n\t}\n}\n```\n\n在用这个`brick-design` 的时候感觉原理上跟`formily`类似，`pageConfig` 相当于`formily` 的`schema`, 他们两同样需要对自定义的组件作注册事件 \n[组件注册](https://github.com/brick-design/brick-design/blob/master/examples/react-example/src/configs/index.ts)\n\n#### 实现CouponContainer 和 CouponItem\n\n```jsx\ninterface Iprops {\n  children: React.ReactNode,\n\t/** 控制显示与隐藏 */\n  visible: 0 | 1,\n\t/** 下面这些是brick-design 的属性，就是给这个容器在选中状态的样式等其余属性 */\n  className: string,\n  onClick?: () => void,\n  onDrag?: () => void,\n  onDragEnd?: () => void,\n  onDragEnter?: () => void,\n  onDragStart?: () => void,\n  onMouseOver?: () => void,\n  getOperateState?: any,\n}\n\nconst Coupon: React.FC<Iprops> & { Item: typeof CouponItem } = (props: Iprops) => {\n  const { children, className, visible = true, ...other } = props;\n  const classNameStr = cx(\n    styles.container,\n    className,\n  );\n  const { onClick, onDrag, onDragEnd, onDragEnter, onDragStart, onMouseOver, getOperateState } = other;\n\n  const divProps = {\n    onClick, onDrag, onDragEnd, onDragEnter, onDragStart, onMouseOver,\n  };\n\t// 这里做个提示：使用当前props的theme 配合 React.children.map, 以及React.cloneElement 形成不一样的布局，比如商品两列布局，或者是一行一个，\n  return (\n    <>\n    {\n      !!visible && (\n        <div {...divProps} className={classNameStr}>\n          {children}\n        </div>\n      ) || null\n    }\n    </>\n  );\n};\n\n\ninterface ItemIprops {\n\tid?: number\n\tname?: string,\n\tclassName: string,\n\tonClick: () => void,\n\tonDrag: () => void,\n\tonDragEnd: () => void,\n\tonDragEnter: () => void,\n\tonDragStart: () => void,\n\tonMouseOver: () => void,\n\tdraggable?: false\n\tgetOperateState: any,\n}\n\nconst CouponItem: React.FC<ItemIprops> = (props: ItemIprops) => {\n  const { className, ...other} = props;\n  const { onClick, onDrag, onDragEnd, onDragEnter, onDragStart, onMouseOver, getOperateState, ...rest} = other;\n  const { id, name } = rest;\n  const divProps = {\n    onClick, onDrag, onDragEnd, onDragEnter, onDragStart, onMouseOver,\n  };\n  const isNotNull = useMemo(() => id, [id]);\n  return (\n    <div className={cx(styles.item)}>\n      <div {...divProps} className={className}>\n        <CouponsItem id={id} name={name} isNull={!isNotNull} />\n      </div>\n    </div>\n  );\n};\n\nCoupon.Item = CouponItem;\n```\n\n## 迷茫与改进\n\n* 一开始是跟同事一样的做法，就是先写一个 `pageConfig` 的一个模板，然后从后端请求接口后把当中的值一一塞进去。\n* 在右边装修内容的时候写成了一个个单独的组件，只要一改变就会触发`pageConfig`, 修改`当前选择的组件的props`, 甚至不需要按确认按钮，\n这样变得非常难处理，无法做数据验证等等。\n* 对于重复数据可继续选择问题， 即当我选择了一个id为1的优惠券时，我再新建一个子节点，我还能再继续选择这张优惠券，数据冗余。\n\n### 改进\n\n* 对于第一个问题，解决方案是根据后端返回的数据去构建一个`pageConfig`, 而不是根据模板去一一塞过去。 hooks 如下\n\n```js\nfunction useGetLayout() {\n\tconst { id } = usePageStatus();\n  const [detail, setDetail] = useState<DetailType | null>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n\n\t/** 获取布局 */\n\tuseEffect(() => {\n    let isValid = true;\n\t\tif (!id) {\n\t\t\treturn;\n\t\t}\n    async function fetchData() {\n      setLoading(true);\n      const { code, data } = await Api({id: id});\n      if (!isValid) {\n        return;\n      }\n      setLoading(false);\n      if (code === 1000) {\n        const isEmptyObject = Object.keys(data.adornContent).length === 0;\n        const tempData = {\n          ...data,\n          adornContent: isEmptyObject ? DEFAULT_DATA : data.adornContent\n        };\n        setDetail(tempData as unknown as DetailType);\n      }\n    }\n    fetchData();\n    return () => {\n      isValid = false;\n    };\n  }, [id]);\n\n\t/** 根据后端返回的布局内容去构建pageConfig， 一部分代码 */\n\tuseEffect(() => {\n\t\tif (!detail) {\n\t\t\treturn;\n\t\t}\n\t\tasync function setData() {\n\t\t\tconst { adornContent } = detail!;\n\t\t\tlet startKey = 0;\n\t\t\tconst firstChildKeys: string[] = [];\n\t\t\tlet pageConfig = {};\n\t\t\t/** 未排序数组 */\n\t\t\tconst dataSourceList: { key: keyof typeof adornContent, sort: number }[] = [];\n\t\t\tObject.keys(adornContent).map((_item: keyof typeof adornContent) => {\n\t\t\t\tdataSourceList.push({\n\t\t\t\t\tkey: _item,\n\t\t\t\t\tsort: adornContent[_item].sort\n\t\t\t\t});\n\t\t\t});\n\t\t\tconst sortedList = dataSourceList.sort((a, b) => a.sort - b.sort);\n\t\t\tfor (const _row of sortedList) {\n\t\t\t\tstartKey = startKey + 1;\n\t\t\t\tfirstChildKeys.push(startKey.toString());\n\t\t\t\tconst target = adornContent[_row.key];\n\t\t\t\tconst currentProps = target.props;\n\t\t\t\tconst childrenData = currentProps.childrenData || [];\n\t\t\t\tconst props = _row.key === 'top' ? {\n\t\t\t\t\timageUrl: currentProps.imageUrl\n\t\t\t\t\t} : {\n\t\t\t\t\t\tvisible: currentProps.visible || true,\n\t\t\t\t\t\ttheme: currentProps.theme || 0,\n\t\t\t\t\t\ttitle: currentProps.title,\n\t\t\t\t\t};\n\t\t\t\tconst childPropsData = _row.key === 'top' ? {} : {\n\t\t\t\t\tchildComponentName: `${CHILD_COMPONENT_NAME[_row.key]}`,\n\t\t\t\t\taddBtnText: '添加子节点',\n\t\t\t\t\tchildProps: {\n\t\t\t\t\t\totherProps: {\n\t\t\t\t\t\t\ttype: `${_row.key}Item`\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tlet tempConfig = {\n\t\t\t\t\tcomponentName: COMPONENT_NAME[_row.key],\n\t\t\t\t\ttitle: title[_row.key] || currentProps.title,\n\t\t\t\t\tprops: props,\n\t\t\t\t\totherProps: {\n\t\t\t\t\t\ttype: _row.key\n\t\t\t\t\t},\n\t\t\t\t\tcanDelete: false,\n\t\t\t\t\t...childPropsData,\n\t\t\t\t\tchildNodes: [],\n\t\t\t\t};\n\t\t\t\tconst childNodesKeys: string[] = [];\n\t\t\t\t/**\n\t\t\t\t * @tofix \n\t\t\t\t * 这里不应该这么写，但是后端的接口分了一块一块，那也没办法 \n\t\t\t\t * 这里应该先根据后端返回的结果先在前端处理一遍，变成 {key: [1, 2, 3]， key2: [2,3,4]} 这样的数据结构，然后请求后端接口，让后端一次返回所有数据\n\t\t\t\t * 而不是一块一块的去请求借口\n\t\t\t\t */\n\t\t\t\tif ( childrenData.length > 0) {\n\t\t\t\t\t/** 这里用key value 的形式对应formated data ，格式化请求前的数据*/\n\t\t\t\t\tconst formatedData = formatData[_row.key]?.(childrenData);\n\t\t\t\t\t/** 这里用key value 的形式对应api */\n\t\t\t\t\tconst requestData = await service[_row.key]?.(formatedData, { ctlType: 'none' });\n\t\t\t\t\t/** 这里用key value 的形式对应formated data ，格式化请求后的数据*/\n\t\t\t\t\tconst afterRequestFormatedData = afterRequestFormat[_row.key]?.(requestData);\n\t\t\t\t\tafterRequestFormatedData?.forEach((_item, _index) => {\n\t\t\t\t\t\tconst keyNum = `${startKey}-${_index + 1}`;\n\t\t\t\t\t\tchildNodesKeys.push(keyNum);\n\t\t\t\t\t\tconst sonConfig = {\n\t\t\t\t\t\t\tcomponentName: `${CHILD_COMPONENT_NAME[_row.key]}`,\n\t\t\t\t\t\t\ttitle: _item?.productName || _item.name,\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\t..._item,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\totherProps: {\n\t\t\t\t\t\t\t\ttype:  `${_row.key}Item`\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tchildNodes: []\n\t\t\t\t\t\t};\n\t\t\t\t\t\tpageConfig[keyNum] = sonConfig;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\ttempConfig = {\n\t\t\t\t\t...tempConfig,\n\t\t\t\t\tchildNodes: childNodesKeys\n\t\t\t\t};\n\t\t\t\tpageConfig[startKey] = tempConfig;\n\t\t\t}\n\t\t\tpageConfig = {\n\t\t\t\t0: {\n\t\t\t\t\t\"componentName\": \"MallLayout\",\n\t\t\t\t\ttitle: '组件树',\n\t\t\t\t\t\"props\": {\n\t\t\t\t\t\t\"style\": {\n\t\t\t\t\t\t\t\"width\": \"100%\",\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"childNodes\": firstChildKeys\n\t\t\t\t},\n\t\t\t\t...pageConfig,\n\t\t\t};\n\n\t\t\tconsole.log(\"pageConfig\", pageConfig);\n\t\t\tupdatePageConfig(pageConfig);\n\n\t\t}\n\t\tsetData();\n\t}, [detail]);\n}\n```\n\n* 针对第二个问题，改用formily，把编辑内容变成`form`, 或者`formily`  \n* 针对第三个问题，再写一个`hook`，针对`pageConfig`发生改变时，返回已有的`key:value`值,根据选择组件获取对应的`key`.即`sameKey[selectInfo.key]`,在table设置rowSelection 设置disabled既可, 数据接口如下：\n\n```jsx\n{\n\tcoupon: [1, 2],\n\thot: [251, 235],\n\tdiscount: [251, 235]\n}\n```\n\n## APP 端显示\n\napp 那边使用的是 `react-native`, \n那么写一个获取`layout` 布局以及 获取数据的`hook`, 这样做既可以把逻辑抽离，又优雅，到时候`迁移到小程序`上就方便多了\n\n因为我们的数据格式是： \n```jsx\n{\n\tcoupon: {\n\t\tsort: 1,\n\t\ttitle: '优惠券',\n\t\tchildrenData: [\n\t\t\t{ type: 1, id: 1 },\n\t\t\t{ type: 2, id: 2 }\n\t\t]\n\t},\n\thot: {\n\t\tsort: 2,\n\t\ttitle: '推荐',\n\t\tchildrenData: [231, 255]\n\t},\n\tdiscount: {\n\t\tsort: 3,\n\t\ttitle: '折扣',\n\t\tchildrenData: [231, 255]\n\t},\n}\n```\n\n先通过前端筛选数据，将空值筛选掉，然后提交给后端, 后端一样`key,value` 这样返回数据，\n\n```jsx\n// 前端提交给后端的数据格式\n{\n\tcoupon:[\n\t\t{ type: 1, id: 1 },\n\t\t{ type: 2, id: 2 },\n\t],\n\thot: [231, 255],\n\tdiscount: [231, 255]\n}\n\n// 后端返回给前端的数据格式, 如下\n{\n\tcoupon:[\n\t\t{ type: 1, id: 1, name: '优惠券1' },\n\t\t{ type: 2, id: 2,  name: '优惠券2' },\n\t],\n\thot: [\n\t\t{ title: '商品1', id: 231 },\n\t]\n}\n```\n\n**迷惑行为：**不知道为什么其他同事都是一块内容一个接口，让我感觉非常迷惑。 这样导致的结果就是，`一个页面n 多个接口`，`逻辑难以复用`, 且`太多if/else`。\n\n因为个人不太喜欢写`if/else`, 本人一般会用 `Map` 去代替`if/else`。\n\n最后, 只要遍历`activityData` 并写相对应的容器组件即可，比如 `Coupon`, `CommodityList`, \n\n```jsx\n// activityData\n[\n\t{\n\t\tsort: 1,\n\t\tname: 'coupon',\n\t\tdataSource: [\n\t\t\t{ type: 1, id: 1, name: '优惠券1' },\n\t\t\t{ type: 2, id: 2,  name: '优惠券2' },\n\t\t]\n\t},\n\t{\n\t\tsort: 2,\n\t\tname: 'hot',\n\t\tdataSource: [\n\t\t\t{ title: '商品1', id: 231 },\n\t\t]\n\t}\n]\n```\n\n```jsx\n<ScrollView style={styles.scrollView} scrollIndicatorInsets={{ right: 1 }}>\n\t{\n\t\tactivityData.map((_item: any, _index: number) => {\n\t\t\tconst componentName = ACTIVITY_TYPE.includes(_item.name) 'commodityList' : _item.name\n\n\t\t\tconst Component = ComponentMap[componentName];\n\t\t\tif (!Component) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\t// eslint-disable-next-line react/no-array-index-key\n\t\t\treturn <Component key={`${_item.name}-${_index}`} activityType={_item.name}  {..._item} />\n\t\t})\n\t}\n</ScrollView>\n```","tags":["react"]},{"title":"Antd Alert 组件","url":"/2021/09/13/antd alert/","content":"\n## Antd Alert 组件\n\n[源码地址](https://github1s.com/ant-design/ant-design/blob/master/components/alert/index.tsx#L153)\n\n这个组件相对简单，就是一个布局组件\n\n### 传参\n\n```jsx\n/** 简化后的属性 **/\nexport interface AlertProps {\n  type?: 'success' | 'info' | 'warning' | 'error';\n  message?: React.ReactNode;\n  description?: React.ReactNode;\n  onClose?: React.MouseEventHandler<HTMLButtonElement>;\n  afterClose?: () => void;\n  showIcon?: boolean;\n  icon?: React.ReactNode;\n}\n```\n\n其实也就是一个用`CSSMotion` 包裹住的`div` 组件， 里面渲染了`message`. `description`, 等\n\n```jsx\n<CSSMotion\n\tvisible={!closed}\n\tmotionName={`${prefixCls}-motion`}\n\tmotionAppear={false}\n\tmotionEnter={false}\n\tonLeaveStart={node => ({\n\tmaxHeight: node.offsetHeight,\n\t})}\n\tonLeaveEnd={afterClose}\n>\n\t{({ className: motionClassName, style: motionStyle }) => (\n\t<div\n\t\t\tref={ref}\n\t\t\tclassName={classNames(alertCls, motionClassName)}\n\t\t\tstyle={{ ...style, ...motionStyle }}\n\t\t\t{...props}\n\t>\n\t\t\t{isShowIcon ? renderIconNode() : null}\n\t\t\t<div className={`${prefixCls}-content`}>\n\t\t\t{message ? <div className={`${prefixCls}-message`}>{message}</div> : null}\n\t\t\t{description ? <div className={`${prefixCls}-description`}>{description}</div> : null}\n\t\t\t</div>\n\t\t\t{action ? <div className={`${prefixCls}-action`}>{action}</div> : null}\n\t\t\t{renderCloseIcon()}\n\t</div>\n\t)}\n</CSSMotion>\n```\n\n值得学习的地方是，`renderIconNode` 函数\n\n```jsx\nconst renderIconNode = () => {\n\tconst { icon } = props;\n\t// 这里源码中 iconMapOutlined 是一个map, 里面是一个 { [type: string]: AntdIcon } \n\tconst iconType = (description ? iconMapOutlined : iconMapFilled)[type] || null;\n\tif (icon) {\n\t\t/** 这里replaceElement 其实源码是用 React.cloneElement 去实现的， \n\t\t\t* 就是判断icon 是否是element 不是的话就用第二参数， 是的话就克隆element，然后添加其余属性 \n\t\t\t*/\n\t\treturn replaceElement(icon, <span className={`${prefixCls}-icon`}>{icon}</span>, () => ({\n\t\t\tclassName: classNames(`${prefixCls}-icon`, {\n\t\t\t\t[(icon as any).props.className]: (icon as any).props.className,\n\t\t\t}),\n\t\t}));\n\t}\n\t/** 这里如果是自己写的话, 是用一个div 去包裹着， 而不是像他那样创建一个element， 这里如果换成React.cloneElement是不是更加合适？ */\n\treturn React.createElement(iconType, { className: `${prefixCls}-icon` });\n  };\n```\n\n","tags":["antd","组件"]},{"title":"ant Switch 组件","url":"/2021/09/13/antd-switch/","content":"\n## Antd Switch\n\n[源码地址](https://github.com/ant-design/ant-design/blob/master/components/switch/index.tsx)\n\n\n## Switch 参数\n\n很明显，`Switch` 的作为一个受控组件， 那么他接受的组件应该有`checked`, `onChange` 这两个属性， 查看`Switch` 的`interface`\n\n### interface\n\n```jsx\n/** 简化后的interface */\nexport interface SwitchProps {\n  /** switch 大小 */\n  size?: SwitchSize;\n\t/** 开关状态 */\n  checked?: boolean;\n\t/** 开关状态 */\n  defaultChecked?: boolean;\n\t/** onChange 事件 */\n  onChange?: (checked: boolean, event: MouseEvent) => void;\n  checkedChildren?: React.ReactNode;\n  unCheckedChildren?: React.ReactNode;\n  disabled?: boolean;\n}\n```\n\n`antd` 源码中`Switch` 调用的是 `RcSwitch`\n\n```jsx\n/** 简化后的代码 */\nimport * as React from 'react';\nimport RcSwitch from 'rc-switch';\n\nconst Switch = React.forwardRef<unknown, SwitchProps>(props, ref) => {\n\tconst { disabled, ...rest } = props;\n\n\treturn (\n\t\t <RcSwitch\n\t\t\t{...props}\n\t\t\tdisabled={disabled || loading}\n\t\t\tref={ref}\n\t\t/>\n\t)\n}\n```\n\n## RcSwitch\n\n[源码地址](https://github1s.com/react-component/switch/blob/master/src/index.tsx)\n\n直接看 `RcSwitch` 的`render` 函数， 其实就是一个`button` 包裹着两个propsChildren\n\n```jsx\nconst RcSwitch = () => {\n\treturn (\n\t\t<button\n\t\t\t{...restProps}\n\t\t\taria-checked={innerChecked}\n\t\t\tdisabled={disabled}\n\t\t\tref={ref}\n\t\t\tonClick={onInternalClick}\n\t\t>\n\t\t\t{loadingIcon}\n\t\t\t<span className={`${prefixCls}-inner`}>\n\t\t\t\t{innerChecked ? checkedChildren : unCheckedChildren}\n\t\t\t</span>\n\t\t</button>\n\t)\n}\n```\n\n值得学习的是，rc-switch 用一个`hook 函数`，将`value`, `defaultValue`, `onChange` 三者抽离出来，这样就可以封装一个受控组件或者是一个非受控组件了\n其实 `useMergedState`  就是 `umi hook` 里面的 [useControllableValue](https://hooks.umijs.org/zh-CN/hooks/state/use-controllable-value\t)\n\n\n```jsx\nconst RcSwitch = () => {\n\tconst [innerChecked, setInnerChecked] = useMergedState<boolean>(false, {\n\t\tvalue: checked,\n\t\tdefaultValue: defaultChecked,\n\t});\n\n\t/** 就是一个onChange 函数，同时改变自身innerCheck 状态，如果props 有onChange，那么也触发父级事件 */\n\tfunction triggerChange(\n\t\tnewChecked: boolean,\n\t\tevent: React.MouseEvent<HTMLButtonElement> | React.KeyboardEvent<HTMLButtonElement>,\n\t) {\n\t\tlet mergedChecked = innerChecked;\n\n\t\tif (!disabled) {\n\t\t\tmergedChecked = newChecked;\n\t\t\tsetInnerChecked(mergedChecked);\n\t\t\tonChange?.(mergedChecked, event);\n\t\t}\n\n\t\treturn mergedChecked;\n\t}\n\treturn (\n\t\t<button\n\t\t\taria-checked={innerChecked}\n\t\t\tdisabled={disabled}\n\t\t\tref={ref}\n\t\t\tonClick={(e) => triggerChange(!innerChecked, e)}\n\t\t>\n\t\t\t{loadingIcon}\n\t\t\t<span className={`${prefixCls}-inner`}>\n\t\t\t\t{innerChecked ? checkedChildren : unCheckedChildren}\n\t\t\t</span>\n\t\t</button>\n\t)\n}\n```\n\n## useMergedState 或者 useControllableValue \n\n我们直接查看`useControllableValue` 这个hooks 是怎么实现的\n[源码](https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useControllableValue/index.ts)\n\n```jsx\ninterface StandardProps<T> {\n  value: T;\n  defaultValue?: T;\n  onChange: (val: T) => void;\n}\nfunction useControllableValue<T = any>(props: StandardProps<T>): [T, (val: T) => void];\nfunction useControllableValue<T = any>(\n  props?: Props,\n  options?: Options<T>,\n): [T, (v: T, ...args: any[]) => void];\nfunction useControllableValue<T = any>(props: Props = {}, options: Options<T> = {}) {\n\t/** 首先获取options 的默认参数， 一般为 value， onChange */\n  const {\n    defaultValue,\n    defaultValuePropName = 'defaultValue',\n    valuePropName = 'value',\n    trigger = 'onChange',\n  } = options;\n\n\t/** 获取 prop['value'] 的值 */\n  const value = props[valuePropName] as T;\n\n\t/** 如果value 在 props 中， 那么我们直接用 props[value] 的值， 不然就是用默认值 */ \n  const [state, setState] = useState<T>(() => {\n    if (valuePropName in props) {\n      return value;\n    }\n    if (defaultValuePropName in props) {\n      return props[defaultValuePropName];\n    }\n    return defaultValue;\n  });\n\n  /* init 的时候不用执行了， 当我们传入的props[value] 发生变化的时候，重新setState, 保证state 跟 props[value] 同步 */\n  useUpdateEffect(() => {\n    if (valuePropName in props) {\n      setState(value);\n    }\n  }, [value, valuePropName]);\n\n\t/** onChange 事件， 分为非受控组件，与受控组件 */\n  const handleSetState = useCallback(\n    (v: T, ...args: any[]) => {\n\t\t\t/** 这里判断一下 我们用组件的时候有没有传入value, 有的话就是受控组件， 没有的话就是非受控组件，非受控组件维护内部值 */\n      if (!(valuePropName in props)) {\n        setState(v);\n      }\n\t\t\t/** 受控组件， 判断一下是否有onChange, 如果有那么就调用props.onChange */\n      if (props[trigger]) {\n        props[trigger](v, ...args);\n      }\n    },\n    [props, valuePropName, trigger],\n  );\n\n  return [valuePropName in props ? value : state, handleSetState] as const;\n}\n```\n\n这个`hooks` 在antd 中经常被使用到\n\n\n\n\n","tags":["antd","组件"]},{"title":"ant Modal 组件","url":"/2021/09/08/antd Modal 组件/","content":"\n* 这里记录一下查看antd 组件库时学到的东西，或者是想法\n\n[源码地址](https://github1s.com/ant-design/ant-design/blob/master/components/modal/Modal.tsx#L200)\n\n## Modal\n\n其实我们可以简单想一下我们需要一个Modal 框那些属性是必要的，很容易想象的到就是`visible`, `onCancel`, `onOk` 这几个属性, 因为这几个属性是\n控制我们这个`Modal` 显示隐藏的\n\n所以就有了以下下简易传值\n\n```jsx\nconst { toggle, setToggle } = useToggle();\n<Modal \n    visible={toggle} \n    onCancel={() => setToggle(false)} \n    onOk={() => doSome()}\n>\n</Modal>\n```\n\n### Modal.tsx\n\n查看源码`Modal.tsx`,  这个组件很简单，其实就是使用了`rc-component` 的`rc-dialog`, 把我们传的`visble`, `onCancel` 等传到 `Dialog` 里面\n\n```jsx\nimport Dialog from 'rc-dialog'\n\ninterface Iprop {\n\tvisible: boolean,\n\tonCancel: () => void,\n\tonOk: () => void\n}\n\nconst Modal: React.FC<Iprops> = (props: Iprops) => {\n\tconst { visbile, onCancel, onOk } = props;\n\n\tconst handleCancel = () => {\n\t\tonCancel?.()\n\t}\n\tconst handleOk = () => {\n\t\tonOk?.()\n\t}\n\n\treturn (\n\t\t<Dialog \n\t\t\tvisible={visible}\n\t\t\tonCancel={handleCancel}\n\t\t\tonOk={handleOk}\n\t\t>\n\t)\n}\n\n```\n\n在`Modal` 中我们还有一些用法，比如：\n\n```jsx\nModal.confirm({\n\ttitle: 'hello,',\n\tcontent: 'world',\n\tonOk() {\n\t\tconsole.log('OK');\n\t},\n\tonCancel() {\n\t\tconsole.log('Cancel');\n\t},\n});\n```\n这样子可以直接调出`Modal`\n\n看看`Modal.confirm` 的实现[源码地址](https://github1s.com/ant-design/ant-design/blob/master/components/modal/index.tsx#L27)\n\n## Modal.confirm\n\n它用了一个高阶函数`confirm(withxxx(props))`, `withxxx`函数就是给props 附加一个`type`, 即 类似`Object.assign(props, { type: 'xxx' })`;\n\n```jsx\nModal.info = function infoFn(props: ModalFuncProps) {\n  return confirm(withInfo(props));\n};\n```\n\n* withInfo 函数\n```jsx\n/** withInfo 函数 */\nfunction withInfo(props: ModalFuncProps): ModalFuncProps {\n  return {\n    icon: <InfoCircleOutlined />,\n    okCancel: false,\n    ...props,\n    type: 'info',\n  };\n}\n```\n\n### 重头戏 Confirm 函数\n\n其实就是在`body` 下面 创建一个节点`const div = document.createElement('div');` 然后将`div` append 到body下， 最后调用 `React.render(Modal, div)`将model 渲染到div上, \n\n```jsx\nfunction confirm(config: ModalFuncProps) {\n  const div = document.createElement('div');\n  document.body.appendChild(div);\n  let currentConfig = { ...config, close, visible: true } as any;\n\n\t/** destroy 的时候将visbile 改成false，然后如果有onCancel 就执行onCancle, 将当前div remove掉 **/\n  function destroy(...args: any[]) {\n    const unmountResult = ReactDOM.unmountComponentAtNode(div);\n    if (unmountResult && div.parentNode) {\n      div.parentNode.removeChild(div);\n    }\n    const triggerCancel = args.some(param => param && param.triggerCancel);\n    if (config.onCancel && triggerCancel) {\n      config.onCancel(...args);\n    }\n    for (let i = 0; i < destroyFns.length; i++) {\n      const fn = destroyFns[i];\n    \n      if (fn === close) {\n        destroyFns.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n\t/** render 到div上  */\n  function render(props: { visible: boolean, onOk: () => void, onCancel: () => void }) {\n \n    setTimeout(() => {\n      ReactDOM.render(\n        <ConfirmDialog\n          {...props}\n        />,\n        div,\n      );\n    });\n  }\n\n\t/** close 的时候将visbile 改成false，然后如果有afterClose afterClose, 然后destroy掉 **/\n  function close(...args: any[]) {\n    currentConfig = {\n      ...currentConfig,\n      visible: false,\n      afterClose: () => {\n        if (typeof config.afterClose === 'function') {\n          config.afterClose();\n        }\n        destroy.apply(this, args);\n      },\n    };\n    render(currentConfig);\n  }\n\n\t/** 向外暴露update 方法，可以修改props等，修改完props然后render一下 */\n  function update(configUpdate: ConfigUpdate) {\n    if (typeof configUpdate === 'function') {\n      currentConfig = configUpdate(currentConfig);\n    } else {\n      currentConfig = {\n        ...currentConfig,\n        ...configUpdate,\n      };\n    }\n    render(currentConfig);\n  }\n\n  render(currentConfig);\n\n  destroyFns.push(close);\n\n\t/** 暴露update 和destroy 方法 */\n\t/** 可以用 const modal = Modal.info({title: '123'}) */\n\t/** 可以用 modal.update({title: '345'}) 去更新title*/\n\t/** 可以用 modal.destory() 去关闭modal*/\n  return {\n    destroy: close,\n    update,\n  };\n}\n```\n\n注意看这个`<ConfirmDialog />`\n## ConfirmDialog\n\n[源码](https://github1s.com/ant-design/ant-design/blob/master/components/modal/ConfirmDialog.tsx#L70)\n\n这个ConfirmDialog 里面的**确认**和**取消** 按钮都用了一个`<ActionButton  onOk={onOk}/>` 其实就是一个`<Button />`\n\n下面只看他如何处理`onOk` 方法\n\n```jsx\nconst ActionButton = () => {\n\tconst handlePromiseOnOk = (returnValueOfOnOk?: PromiseLike<any>) => {\n    const { close } = props;\n    if (!isThenable(returnValueOfOnOk)) {\n      return;\n    }\n    setLoading(true);\n\t\t/** promise 完成后直接close 掉 */\n    returnValueOfOnOk!.then(\n      (...args: any[]) => {\n        setLoading(false);\n        close(...args);\n        clickedRef.current = false;\n      },\n      (e: Error) => {\n        console.error(e);\n        setLoading(false);\n        clickedRef.current = false;\n      },\n    );\n  };\n\n  const onClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    const { actionFn, close } = props;\n\t\t// 这里处理按钮是否被点击了，如果是, 直接return掉\n    if (clickedRef.current) {\n      return;\n    }\n    clickedRef.current = true;\n\t\t/** 如果没有onOk 或者是onCancel 方法，直接调用modal.close() 方法，光比弹窗 */\n    if (!actionFn) {\n      close();\n      return;\n    }\n    let returnValueOfOnOk;\n\t\t/** 这里我的理解是 处理是否冒泡？ */\n    if (props.emitEvent) {\n      returnValueOfOnOk = actionFn(e);\n\t\t\t/** 判断是否是一个promise , 处理onOk 直接return new Promise() */\n      if (props.quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {\n        clickedRef.current = false;\n        close(e);\n        return;\n      }\n    } else if (actionFn.length) {\n\t\t\t/** onOk 是否有参数 function onOk(close) 的情况， */\n      returnValueOfOnOk = actionFn(close);\n      clickedRef.current = false;\n    } else {\n\t\t\t/** 无参数 */\n      returnValueOfOnOk = actionFn();\n      if (!returnValueOfOnOk) {\n        close();\n        return;\n      }\n    }\n\t\t/** 处理promise 方法 */\n    handlePromiseOnOk(returnValueOfOnOk);\n  };\n\n\treturn (\n\t\t<Button OnClick={onClick}>\n\t\t</Button>\n\t)\n}\n\n```\n\n\n\n\n\n\n","tags":["antd","组件"]},{"title":"系统命令行代理","url":"/2021/06/23/系统命令行代理/","content":"\n# windows 终端代理设置\n\n## cmd\n\n我的v2ray 的端口是1080是socks5, http用的是1081\n```bash\n#http\nset http_proxy=http://127.0.0.1:1081\nset https_proxy=http://127.0.0.1:1081\n```\n\n如果是socks5\n```bash\n#socks5\nset https_proxy=socks5://127.0.0.1:1080\nset http_proxy=socks5://127.0.0.1:1080\n```\n\n## powershell\n理论跟上面一样 换个地址罢了\n```bash\n$env:http_proxy=\"http://127.0.0.1:1080\"\n$env:https_proxy=\"http://127.0.0.1:1080\"\n```\n# git 下设置代理\n\n**如果是使用socks代理：就用socks5, 如果是http,那就改成http**\n```bash\ngit config --global http.proxy 'socks5://127.0.0.1:1080'\ngit config --global https.proxy 'socks5://127.0.0.1:1080'\n```\n\n# git 取消代理\n\n```bash\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n# Mac 下设置\n\n```\nvi ~/.zshrc\n```\n\n复制一下内容\n\n```js\nfunction proxy_on() {\n    export no_proxy=\"localhost,127.0.0.1,localaddress,.localdomain.com\"\n    export http_proxy=\"http://127.0.0.1:1087\"\n    export https_proxy=$http_proxy\n    #export all_proxy=socks5://127.0.0.1:7890 # or this line\n    echo -e \"已开启代理\"\n}\n\nfunction proxy_off(){\n    unset http_proxy\n    unset https_proxy\n    echo -e \"已关闭代理\"\n}\n```\n\n最后运行`source ~/.zshrc` 使文件生效\n\n## 使用\n\n只需要打开终端， 输入`proxy_on`即可， \n\n## 验证\n\n```bash\ncurl cip.cc\n```","tags":["代理"]},{"title":"正则表达式","url":"/2021/06/14/正则表达式/","content":"\n## 正则表达式\n\n正则表达式是描述一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n\n我们判断字符串是否含有子串，我们一般会用到`indexOf` 还有`includes`方法, 比如 `\"abc\".includes(\"ab\")` 或者 `\"abc\".indexOf(ab)`, 那么这两个有什么区别？\n\n\n\n**includes 返回的是Boolean值;**\n\n**而indexOf 返回的是子串在字符串首次出现的下标，若没有出现返回-1**\n\n\n除了以上两种方法，我们还有正则表达式，`/ab/.test(\"abc\")`\n\n### 先来看几个常用特殊的字符\n\n\n1.  `*` 代表前面的字符`0次`或`多次`， 例子 `/ac*/.test(\"abc\")`\n\n<details>\n<summary><mark>说明</mark></summary>\n\nac*能匹配“a”，也能匹配“ac”以及“acc”。*等价于{0,}。\n</details>\n\n2.  `+` 代表前面的字符`1次`或`多次`， `/ac+/.test(\"abc\")`\n\n<details>\n<summary><mark>说明 </mark></summary>\n\nac+ 能匹配“ac”以及“acc”, 但不能匹配\"a\", +等价于{1,}。\n</details>\n\n3.  `?` 代表前面的字符`0次`或`1次`,   例子 `/ac?/.test(\"abc\")`\n例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。\n4. `/d` 匹配数字\n5. `\\w` 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]\n6. `\\s` 匹配所有空白符，包括换行\n7. `\\S` 匹配非空白符，不包括换行。\n8. `[\\s\\S]` 匹配所有\n\n\n### 基础\n\n#### 字符组 []\n\n**字符组**：允许匹配一组可能出现的字符。比如 [Jj], 那么既可以匹配`J`，也能匹配`j`, 例子\n`/[Jj]ava[Ss]cript/.test(\"JavaScript\")`\n\n#### 区间\n\n在字符组中用`-`代表区间，即`[0-9]`表示的是`[0123456789]`, 同理`[a-z]`表示的是`a到z`任意的数字\n\n#### 字符转义\n\n上面所说，`[]`表示字符组， 而`-` 表示区间连接符，那么如果要匹配`[]` 那么就需要使用转义符 `\\`，\n<details>\n<summary><mark>答案 </mark></summary>\n\n`/\\[\\]/.test(\"[]\")`\n</details>\n\n#### 取反 [^]\n\n`true` 取反 就是`false`, 在正则这里的取反是指 **不会出现的字符**\n\n比如： 匹配不包含数字的字符串 `/[^0-9]/.test(\"abc\")`,\n\n**注意：^符号要在中括号内，不然^代表的是匹配以^后跟随的的字符开头的字符串**，`/^gg/.test(\"gg = good game\")`, 这里表示的是以`gg开头`的匹配式。\n\n这里顺带说一下 `$`, 表示以`$`前面的字符组做结尾的匹配式 `/world$/.test(\"hello world\")`\n\n<details>\n    <summary>不含小写字母的数据</summary>\n\n    `/[^a-z]/.test(\"0123123ADFADJFKL\")`\n</details>\n\n#### 重复\n\n在一个字符组后加上`{N}` 就可以表示在它之前的字符组出现`N`次。例如 `/\\d{3}/` ,表示数字重复3次\n\n假设要匹配 电话号码，那么应该怎么做， 电话号码的格式是`020-12345678`\n\n<details>\n    <summary>匹配电话号码</summary>\n\n    `/\\d{3}-\\d{8}/`\n</details>\n\n\n##### 重复区间 {M,N}\n\n可能有时候，我们不知道具体要匹配字符组要重复的次数，比如身份证有15位也有18位的。那么这时候就可以用重复区间， \n\n`语法：{M,N}，M是下界而N是上界。`\n\n\n> 练习 匹配所有的手机号\n\n```tsx\n\n我们知道手机号必须为11位数，并符合下列几个规则：\n\n第一位数字必须以1开头，第二位数字可以是[3,4,5,7,8]中的任意一个，后面9个数是[0-9]中的任意一个数字\n```\n\n<details>\n    <summary>匹配所有的手机号</summary>\n\n    `/1[34578]\\d{9}/`\n</details>\n\n\n### 贪婪匹配与非贪婪匹配\n\n贪婪模式：在整个表达式匹配成功的前提下，尽可能多的匹配 (`*`)；\n\n非贪婪模式：在整个表达式匹配成功的前提下，尽可能少的匹配 (`?`)；\n\n例子： `<div>12312</div><div>hello world</div>`\n\n贪婪匹配： `\"<div>12312</div><div>hello world</div>\".match(/<div>.*</div>/)`, 会匹配到 `<div>12312</div><div>hello world</div>`\n\n非贪婪匹配： `\"<div>12312</div><div>hello world</div>\".match(/<div>.*?</div>/)`, 会匹配到 `<div>12312</div>`, 这是因为非贪婪匹配，匹配到第一个子串就结束了,不再往后匹配了\n\n### 分组\n\n**分组：使用的是（），分组一般用在提取匹配的字符串的子串**。 举个例子： `020-12345678` 这是我们的电话号码，但我想提取他的`区号`和`真实的电话号码`，那么我们只需要`/(\\d{3})-(\\d{8})/`即可\n\n**练习1：** 如果我想要提取`<div>hello world</div>`\n<details>\n    <summary> 答案</summary>\n\n    \"<div>hello world</div>\".match(/<div>(.*?)<\\/div>/)\n\n    比较：\n    1. <div>.*?</div>\n    2. <div>(.*?)</div>\n</details>\n\n**练习2：** 如果 我们拥有日期的格式为 `2020-05-20` 或者 `2020 05 20` 或者 `2020/05/20` 这样的格式，我们想要获取他的`年月日` 应该怎么写\n\n<details>\n    <summary> 答案</summary>\n    /(\\d{4})[\\-\\s\\/](\\d{2})[\\-\\s\\/](\\d{2})/\n\n    测试一下\n\n    \"2020-05-20\".match(/(\\d{4})[\\-\\s\\/](\\d{2})[\\-\\s\\/](\\d{2})/)\n\n    中间分隔符是[\\-\\s\\/], 我们换成[\\s\\S]是否也可以？\n\n</details>\n\n\n那如果日期的格式是 2020-5-20 或者是 2021-2-2 那应该怎么改造他\n<details>\n    <summary> 答案</summary>\n    /(\\d{4})[-](\\d{1,2})[-](\\d{1,2})/\n\n</details>\n\n### 非捕获分组\n\n有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。即我不要这个分组。\n**非捕获分组： (?:表达式)**\n\n例子： 现在有 电话号码 `020-12345678` 或者`tel:12345678`, 我只要要他的电话号码，那么`(?:\\d{3}|tel)[-:](\\d{8})`\n\n\n### 分组回溯引用\n\n分组回溯引用的意思就是，我能使用之前匹配的分组, 用`\\1`表示第一个分组， `\\2`表示第二个分组，如此类推\n\n例如，要匹配一段 HTML 代码，比如：`<font>hello world</font>`，我们会写成 `/<\\w+>.*?<\\/\\w+>/`, 这样能匹配`<font>hello world</font>`， 但是如果数据改成这样：`<font>hello world</bar>`, `font` 和 `bar` 不是一对正常的标签，所以上面的表达式不太正确， 这个时候就可以使用**分组回溯引用**, `/<(\\w+)>.*?<\\/\\1>/`\n\n**练习：** 如果要匹配符合 `ab ba` 这种关系的单词, 应该怎么写?\n\n匹配`abba`, `asffs`\n\n<details>\n    <summary> 答案</summary>\n    (\\w+)(\\w+)\\2\\1\n\n</details>\n\n### 正向先行断言\n\n**正向先行断言**：`(?=表达式)`，指在某个位置向右看，表示所在位置右侧必须能匹配表达式，但匹配的表达式不会出现在结果组里面\n\n例如：\n\n我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你\n\n如果要取出`喜欢`两个字，要求这个喜欢后面有你，这个时候就要这么写：`喜欢(?=你)`，这就是正向先行断言。\n\n看这段正则表达式`(?=.*?[a-z])(?=.*?[A-Z]).+`, 这段正则能够匹配**包含至少一个大小写字母的字符串**， 把正则拆开就是 \n\n*  `(?=)` 说明是`后面必须是什么东西`，\n*  `.*?` 表示 `任意东西`\n*  `[a-z]` 表示 `a-z` 的小写字母\n\n结合就是 必须包含`a到z`的任意字符串\n\n> 练习: 密码强度验证规则如下:\n\n* 至少一个大写字母\n* 至少一个小写字母\n* 至少一个数字\n* 至少8个字符\n\n<details>\n    <summary> 答案</summary>\n    /(?=.*?[a-z])(?=.*?[A-Z])(?=.*?[0-9]).{8}/\n\n</details>\n\n### 反向先行断言\n\n**反向先行断言**：`(?!表达式)`的作用是保证右边不能出现某字符。\n\n用上面的例子就是，如果要取出`喜欢`两个字，**要求这个喜欢后面没有你**，这个时候就要这么写：`喜欢(?!你)`，这就是反向先行断言。\n\n我觉得：正向先行断言跟反向先行断言基本类似，**只是一个取反的操作**\n\n> 练习： 排除qq邮箱\n\n<details>\n    <summary> 答案</summary>\n    /@(?!qq).*/\n\n    @后面没有qq\n</details>\n\n> 用正向现行断言以及反向现行断言 千分位格式化数字\n\n`\"100000\".replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')`\n\n解析: `/\\B(?=(\\d{3})+(?!\\d))`\n\n* `\\B`, 首先先理解 `\\b`, 在字符串中 `\"here is a word\"`, 在这个字符串中其实用很多`\\b`, 就是单词与单词之间有`\\b`，所以如果用 `/\\bhere\\b/` 可以匹配到`here`这个单词,但如果字符串是`hereisaword`, 这样就匹配不了`here`了，我们可以简单是想象成**空格符**。\n`\\B`是只非字间, 和 `\\d`与`\\D`, `\\w` 与 `\\W` 的取反关系一样\n* `(?=(\\d{3}))`: 先分组，3个数字为一组，加正向先行断言也就是 **必须包含3个数字为一组的字符串**\n* `+` 一次或多次\n* `(?!\\d)`: 反向先行断言，**后面必须不能包含数字**\n* 结合就是 `3个数字为一组的子串后面必须没有数字`\n\n### 正向后行断言\n\n先行断言和后行断言只有一个区别，即**先行断言从左往右看，后行断言从右往左看。**\n\n**正向后行断言**：`(?<=表达式)`，指在某个位置向左看，表示所在位置左侧必须能匹配表达式\n\n例如：如果要取出`喜欢`两个字，要求**喜欢的前面有我，后面有你**，这个时候就要这么写：`(?<=我)喜欢(?=你)`。\n\n### 反向后行断言\n\n**反向后行断言**：`(?<!表达式)`，指在某个位置向左看，表示所在位置左侧不能匹配表达式\n\n用上面的例子就是， 我喜欢你， 喜欢前面没有我\n\n例子： 匹配一个 $ 符号: `(?<!\\$)\\$[^\\$]*\\$(?!.)`\n\n解析： \n* `(?<!\\$)\\$`: `$` 前面没有`$`\n* `\\$(?!$)`: `$` 的后面没有`$`\n* `[^\\$]*`: 除了`$` 的任意字符\n\n\n\n### 应用\n\n* 日期转化, 获取年月日，时分秒\n* 获取url中的参数\n* trim() 函数\n* 模板\n\n```tsx\nfunction getUrlParams(url) {\n    const pattern = new RegExp(/(\\w+)=(\\w+)/, 'gi')\n    let res = {};\n    str.replace(reg, (match, p1, p2) => {\n        res[p1] = p2;\n        return `${p1}=${p2}`\n    })\n    return res;\n}\n\ngetUrlParams(\"https://www.baidu.com?username=admin&password=88888888&code=1234\")\n```\n\n> trim()\n\n```tsx\nfunction trim(str, type: \"left\" | \"right\" | \"both\" | \"all\") {\n    if (type === 'left') {\n        return str.replace(/(^\\s*)/g, \"\");\n    }\n    if (type === 'right') {\n        return str.replace(/(\\s*$)/g, \"\")\n    }\n    if (type === 'both') {\n        return str.replace(/(^\\s*)|(\\s*$)/g, \"\"); \n    }\n    return str.replace(/(\\s*)/g, \"\");\n}\n```\n\n> 简易模板引擎\n\n```tsx\n\nconst data = {name: 'Bill', age: 111};\nconst template = `\n    <div>\n        <p>my name is {{name}}</p>\n        <p>年龄 {{age}}</p>\n    </div>\n`\nfunction generate(template, mapData) {\n    const reg = new RegExp(/\\{\\{(.*?)\\}\\}/, \"g\");\n    const res = template.replace(reg, (match, p1) => mapData[p1])\n    return res;\n}\nconst a = generate(template, data);\ndocument.body.innerHTML += a\n\n```\n\n\n...完\n\n","tags":["正则"],"categories":["正则"]},{"title":"git 操作","url":"/2021/04/08/git/","content":"\n## 三大工作区\n\n* **工作区**：工作区可以理解成两个分区，一个是**已控制的区域**，另一个是`新文件或文件变动区`\n* **暂存区**：可以理解成 执行了`git add` 之后的操作\n* **版本库**：可以理解成执行了`git commit` 之后的操作\n\n记录一下 git 的常用操作\n\n## 简单操作\n\n* `git add .`\n* `git commit -m \"\"`\n* `git pull`\n* `git push`\n\n以上是常用操作，就不多解释了\n\n## reset 回滚\n\ngit 回滚可以从3大工作区来回切换\n\n* `git reset --soft 版本号` 指的是从`版本库`回到`暂存区`\n* `git reset HEAD .` 表示从`暂存区`回到 `工作区(新文件或文件变动区)`\n\n* `git reset -mix 版本号` 表示从`版本号` 回到`工作区(新文件或文件变动区)`\n\n* `git reset --hard 版本号` 表示从`版本号`回到`工作区（以控制的区域）`\n\n![具体图](./git/git_reset.jpg)\n\n\n## 变基(rebase)\n\n简单说就是可以简化提交记录，\n\n使用场景\n\n* 合并提交记录\n\n\n\n","tags":["git"],"categories":["git"]},{"title":"路径总和 II","url":"/2020/09/26/路径总和-II/","content":"\n[路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)\n\n## 题目描述\n\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n\n说明: 叶子节点是指没有子节点的节点。\n\n### 示例\n\n给定如下二叉树，以及目标和 sum = 22\n\n```jsx\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n\n```\n\n返回\n\n```\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n```\n\n### 题目分析\n\n其实这道题跟[路径总和](https://zhou-bill.github.io/2020/07/07/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/)这道题很相似\n* 其实就是将**每次遍历的数**放到 `prefix` 中，判断当前 节点是否有子节点 还有 `sum - value === 0`, 是的话，放入到 `res` \n* 有 左节点 进入递归\n* 有 右节点 进入递归\n\n## 实现\n\n```jsx\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {number[][]}\n */\nvar pathSum = function(root, sum) {\n    let res = [];\n    let prefix = []\n    if(!root) {\n        return res\n    }\n    dfs(root, sum, res, prefix);\n    return res;\n};\n\nvar dfs = function(root, sum, res, prefix) {\n    const value = root.val;\n    const remain = sum - value;\n    // 如果叶子节点都没有而且 sum - value == 0, 那么我们将prefix 加进数组\n    if(!root.left && !root.right && remain === 0) {\n        res.push([...prefix, value])\n        return ;\n    }\n    // 没有子节点 且 remain !== 0 那就停止递归\n    if(!root.left && !root.right && remain !== 0) {\n        return;\n    }\n    // 有左子节点\n    if(root.left) {\n        dfs(root.left, remain, res, [...prefix, value])\n    }\n    // 有右子节点, 进入递归\n    if(root.right) {\n        dfs(root.right, remain, res, [...prefix, value]);\n    }\n}\n```\n\n## 总结\n\n像这种需要保留 状态集的可以用`prefix` 装着，最后当符合条件的时候再 把 `prefix` 装到 `result`","tags":["algorithm-二叉树","algorithm-深度搜索优先"]},{"title":"面试总结","url":"/2020/09/10/面试总结/","content":"## vdom \n\n将多次dom修改的结果一次性更新到页面上，从而减少了页面的渲染次数，减少了修改dom之后的回流与重绘，提高了渲染性能\n**VDOM的厉害之处不在于他运行有多快，而在于它在不需要人工优化的情况下，提供一个过得去的性能优化**\n\n## 说一说之前的面试体验吧\n\n* 有一些纯属浪费时间，技术栈不太符合的也叫你过去面试，以后需要在先问技术栈再决定去不去面试，不然把自己搞的又累又浪费时间\n* 面试本来就是双向选择，所以对面试官不要怂，说不定他比你还垃圾，毕竟**面试造火箭，工作拧螺丝**\n* 经过这几轮面试， 主要可能问到的是 \n    * 算法（排序， 动态规划）， \n    * react 源码（fiber, react 事件原理, 时间片（time slicing）， setState 在setTimeout 执行为什么是同步的, hook 实现原理也就是闭包， hook ref.current）(前端面试星球小程序有答案)\n    * react diff 算法\n        * 分3种，1 tree duff 2 component diff  3 element diff \n    * 网络问题 （tcp/ip, https, http1.0 与 http 1.1）\n        * tcp/ip 三次捂手， 四次挥手\n        * https 基于ssl /tls  对称加密（简单说就是把各自秘钥传给对方），非对称加密\n        * http1.0（一个http 请求连一个tcp, 所以时间耗在3次握手，4次回收）, http 1.1（增加 keep-alive）, http2.0 (头部压缩，二进制流，帧中有报文信息，通过排序重新组合还原报文) 的区别\n    * nodejs (中间件) 插件\n    * umi 底层， 约定式路由实现， dva， cli 集合 （webpack, ssr， UI库） 等等是怎么实现的\n    * 设计模式 （工厂， 单例， 观察者模式， 发布订阅）\n\n## 说一说未来\n\n* 针对算法 动态规划，DFS, BFS, 二分法，链表， 二叉树，\n* react 源码，继续深入，这次要先看结构，再深入源码\n* vue 3.0 原理， 深入学习vue生态 （vuex, vue-router, echart）\n* 图表实现 （canvas， three.js）\n* nodejs \n* 一个后端 语言 nodejs / python\n\n\n## 书\n\n* 设计模式\n* 红宝书\n* 图解http\n\n## 学习本就是输入输出的事情， 学是输入，教别人是输出，多记录多回顾"},{"title":"手写源码系列","url":"/2020/09/08/手写源码系列/","content":"\n## 防抖\n\n```jsx\nfunction debound(fn, wait) {\n    let time;\n    return function(...args) {\n        if(time) {\n            clearTimeOut(time)\n        } \n\n        time = setTimeOut(() => {\n            fn.apply(this, args)\n        }, wait)\n    }\n}\n```\n\n## 节流\n\n节流的意思 是在单位时间内只执行一次\n```jsx\nfunction throttle(fn, wait) {\n    let time = null;\n\n    return function(...args) {\n        if(!time) {\n            // 当前没有事件\n            time = setTimeOut(() => {\n                time = null;\n                fn.apply(this, args)\n            }, wait)\n        }\n    }\n}\n\n```\n\n## promise\n\n[参考链接](https://github.com/lgwebdream/FE-Interview/issues/29)\n\n","tags":["源码"],"categories":["源码"]},{"title":"webpack梳理","url":"/2020/09/05/webpack-配置梳理/","content":"\n## 关于webpack\n\nwebpack 其实就是一个打包工具， 他可以把css, js, 图片等等的东西都打包成一个bundle，从entry开始递归分析他的依赖图，把应用到的每一个模块打包成一个或多个bundle\n\nwebpakc 主要依赖下面几个配置\n\n* `entry`: 主入口文件\n* `output`: 输入文件的位置\n* `modules`: 里面配置的是loader， 我们可以想象loadder 为一名翻译官，把各种类型文件都翻译成浏览器可以识别的东西\n* `plugins`: 插件，我觉得webpack 的强大之处在于他的插件，plugin 可以针对在webpack不同的时期做不同的工作，比如`CleanWebpackPlugin`可以在打包之前删除清理指定目录\n\n\n## webpack 基础配置\n\n```jsx\nconst path = require('path');\n\nexport default {\n    entry: './src/index.js', // 入口文件\n    output: {\n        filename: '[name].js',\n        path: path.resolve(__dirname, 'dist'),\n    },\n    resolve: {\n        modules: ['node_modules'], // 告诉 webpack 解析模块时应该搜索的目录。\n        // 配置别名\n        alias: {\n            '@': path.resolve(__dirname, 'src'), // 指定src的别名为 ‘@’\n        },\n        ententions: ['.js', '.css'], // 添加文件猴嘴\n    },\n    // 定义开发环境下的webpack-dev-server 其实就是动态更新\n    // 此时没有加载 HotModuleReplacementPlugin 的时候是通过loaction.reload（）重新加载网页的，但有个缺点就是不能记录状态\n    devServer：{\n        contentBase: path.resolve(__dirname, 'dist'),\n        open: true,\n        port: 8000,\n        hot: true\n    },\n    treeShaking: true, // 这里表示将没用过的代码自动删除掉\n    optimization：{\n        splitChunks: {\n            cacheGroups: {\n                vendor: {\n                    test: /node_modules/,\n                    priority: 1,  // 数字越大，优先级越高\n                    minChunks: 2, // 表示至少有两个js同事引用的时候，就会打包成vendor。js\n                    minSizes: 0, // 表示最小的大小\n                }\n            }\n        },\n    },\n    modules: {\n        noParse: /jquery/,  // webpack 优化， 不去递归jquery的依赖库\n        rules: [\n           {\n                test: /\\.css$/,\n                use: [\n                    // 请记住loader 的运行顺序是从下到上，从右到左，\n                    // 另一种模式是内敛模式， import Styles from 'style-loader!css-loader?module!./styles.css', 忠中模式通过 ! 分割loadder，\n                    // 'style-loader!css-loader?module!./styles.css'.split(\"!\") => [\"style-loader\", \"css-loader\"]\n                    { loader: 'style-loader' },\n                    {\n                        loader: 'css-loader',\n                        options: {\n                        modules: true\n                        }\n                    }\n                ]\n            },\n            {\n                test: /\\.js$/,\n                exclude: /(node_modules|bower_components)/,\n                // 如果使用happypack的话，多线程打包，此时下面就要修改该成\n                // use: 'Happypack/loader?id=js'\n                use: { \n                    loader: 'babel-loader',\n                    option: {\n                        cacheDirectory: true,  // 开启js 打包优化\n                        presets: ['@babel/preset-env', '@babel/preset-react'],\n                        plugins: [require('@babel/plugin-transform-object-rest-spread')]\n                    },\n                    \n                }\n                \n            }\n        ]\n    },\n    mode: 'development',  // 指定环境，\n    plugins: [\n        // 编译的时候指定全局变量，我们可以根据这个去定义当前环境是开发环境还是线上环境，定义不通的行为，比如url\n        new webpack.DefinePlugin({\n            PRODUCTION: JSON.stringify(true),  // 此时传过去的 PRODUCTION 是 字符串 “true”\n            VERSION: JSON.stringify(\"5fa3b9\"), // \n        }),\n        // 多线程打包, 要是对css也启动多线程的话，再创建一个happypack， id为css\n        new Happypack({\n            id: 'js',\n            use: [{ \n                loader: 'babel-loader',\n                option: {\n                    cacheDirectory: true,  // 开启js 打包优化\n                    presets: ['@babel/preset-env', '@babel/preset-react'],\n                    plugins: [require('@babel/plugin-transform-object-rest-spread')]\n                },\n            }]\n        }),\n        // ignorePlugin， 针对某个包的依赖不进行打包，比如moment， locale 是moment的语言包，要是我们只使用zh-cn 那么我们可以忽略掉其他，所以此时忽略掉locale\n        new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/),\n        \n        // 下面是热更新\n        new webpack.NamedModulesPlugin(), // 告诉webpack  哪个模块更新了\n        new webpack.HotModuleReplacementPlugin(); // 进行热更新\n    ]\n}\n```\n\n### 热更新\n\n```jsx\nimport test from './test';\n\nif(module.hot) {\n    module.hot.accept('./test', () => {\n        console.log('文件已更新');\n        require('./test');\n    })\n}\n```\n\n我们总结一下上面关于打包优化的几种方式吧\n\n* 配置resolve 减少目录的搜索路径\n* 同样的在loader 中设置 include 和 `exclude` 指定loader 编译的目录\n* 设置modules 下的 `noParse`属性， 这个可以在打包的时候不检查`某js` 的依赖，这样就可以减少打包时间了\n* 配置DllPlugin 用动态链接库的形式打包，这样的话会根据目录下的manifest.json 进行二次打包， **二次打包不会再对已生成的动态链接库进行打包**\n* 使用happyPack 用多线程打包\n\n\n## tapable\n\nwebpack 本质上是一种事件流机制，它的工作流程就是把各个插件串联起来， 他的核心就是tapable, tapable 有点像nodejs 的event库， 就是观察者模式\n\n先来看看一个简单的events 库\n\n```js\nclass EventBus {\n    constructor() {\n        this.maps = {}\n    }\n\n    on(name, fn) {\n        this.maps[name] = fn;\n    }\n\n    fire(name, data) {\n        this.maps[name] && this.maps[name](data);\n    }\n}\n\n// 测试\n\nconst eventBus = new EventBus();\neventBus.on(\"click\", (data) => {\n    console.log(\"click\", data)\n})\n\neventBus.fire(\"click\", {a: 1, b: 2})\n```\n\n### 简单的观察者模式\n\n发布订阅其实很简单， 我可以想象成天文台， 当温度改变时， 天文台的数据改变（changes）的时候，我们用户需要做什么，他下雨了，我们需要收衣服，\n\n* 被观察者是 天文台，\n* 观察者 是我们用户， 具体做法是我们要收衣服， 就是对应下面的update， 简单说就是具体的做法就是观察者了\n\n```jsx\nclass Subject {\n    constructor() {\n        this.watchers = []\n    }\n\n    addWatch(watcher) {\n        console.log(this.watcher)\n        this.watchers.push(watcher)\n    }\n\n    removeWatcher(watcher) {\n        let index = this.watchers.indexOf(watcher);\n        if(index > -1) {\n            this.watchers.splice(index, 1)\n        }\n    }\n\n    notify() {\n        this.watchers.forEach((watcher) => watcher.update())\n    }\n}\n\nclass Watcher {\n    subscribeTo(subject) {\n        subject.addWatch(this);\n    }\n\n    update() {}\n}\n\nlet subject = new Subject()\nlet watcher = new Watcher()\nwatcher.update = function() {\n  console.log('observer update')\n}\nwatcher.subscribeTo(subject)  //观察者订阅主题\n\nlet watcher2 = new Watcher()\nwatcher2.update = function() {\n  console.log('我是另一个观察者，我要做其他事情')\n}\nwatcher2.subscribeTo(subject) \n\nsubject.notify()\n\n```\n\n### 实现 SyncHook\n我们以上面的例子，实现一个`SyncHook`\n\n```jsx\nclass SyncHook {\n    constructor(args) {\n        this.tasks = []\n        \n    }\n\n    // 绑定时间\n    tap(name, fn) {\n        this.tasks.push(fn)\n    }\n\n    // 运行函数, 在tapabel\n    call(...args) {\n        this.tasks.forEach((task) => task(...args));\n    }\n}\n\nlet hook = new SyncHook(['name']) // ['name'] 指的是我在创建hook的时候， 我tap需要传递的参数\nhook.tap(\"test\", (name) => {\n    console.log('test', name)\n})\nhook.tap(\"test2\", (name) => {\n    console.log(\"test2\", name)\n})\nhook.call(\"hello\"); // 这里的hello 对应的是上面的name\n\n```\n\n\n## webpack 原理\n\nwebapck其实就是自己实现了一个require方法，这里需要对`AST`进行一部分的了解， **AST**就是抽象语法树， 简单说就是将 js 转换成 语法树，转换成 **方法， 变量等等的属性**\n\n我们看看AST 的步骤\n\n* `AST` 将 `js` 转换成 语法树\n* 修改语法树的值\n* 将 `AST` 转换成浏览器可以识别的 语法\n\n`AST` 依赖包\n\n* babylon 将 源码 解析成 `AST(抽象语法树)`\n* @babel/traverse 遍历 AST 中的节点\n* @babel/types    替换 AST 节点\n* @babel/generator  将替换的结果生成成js\n\n\n我们想想webpack 的运行过程， 我们首先配置 `webpack.config.js`， 然后运行的是 `webpack --config webpack.config.js` 然后webpack 会根据 `entry`入口文件\n进行分析，对它进行`AST`解析， 如果`entry入口文件`还有`require`, 那么继续进行依赖遍历。\n\n\n### loader\n\n其实loader 就是一个方法，我们看两个例子, 一个是less-loader, 另一个是style-loader\n其中 `loader-utils` 获取loader 的参数就是 loader 的 options\n\n#### less-loader\n\n```jsx\n// less-loader\n\n/**\n * 我们less-loader 当然要转换成css，那么我们使用的是less.render\n * 下面使用less那么肯定需要 npm install less -=save-dev\n * @param {string} source  这里的source就是指 less源码\n*/\nconst loaderUtils = require('loader-utils');\nfunction loader(source) {\n    let css = \"\";\n    // loaderUtils.getOption(this) 可以拿到他的参数\n    less.render(source, (err, lessSource) => {\n        css = lessSource.css\n    })\n    return css;\n}\n```\n\n#### style-loader \n\n```jsx\n/**\n * 我们style-loader 的作用是将css 写在html 的head 下面的style标签下\n*/\nfunction loader(source) {\n    let styles = `\n        const el = document.createElement(\"style\");\n        const css = ${source.replace(/\\s*/g, \"\")}\n        el.innerHTML = css;\n        document.head.appendChild(css);\n    `\n    return styles\n}\n\n```\n\n### plugin\n\nwebpack 是基于tapable事件流， 你把 plugin 想象成在webapck 中不同的生命周期做不同的事情，我们看看webpack 的hooks吧\n\n\n* entryOption   入口hooks\n* compile       编译时期\n* afterCompile  完成编译后\n* afterPlugins  插件完成编译后\n* run           运行\n* emit          生成编译文件时\n* done          执行完成\n\n\n### 自定义plugin\n\n```jsx\nclass Plugin() {\n    \n    apply(compiler) { // 此时的compiler 是webpack实例\n        compiler.hooks.done.tap(\"run\", () => {\n            console.log(\"此时是webpack 运行时运行的时间\")\n        })\n        compiler.hooks.done.tap(\"name\", () => {\n            console.log(\"此时是注册事件，指的是在整个wepack执行完成之后的回调函数\")\n        })\n    }\n}\n```","tags":["webpack"],"categories":["webpack"]},{"title":"841. 钥匙和房间","url":"/2020/08/31/841-钥匙和房间/","content":"\n[841. 钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)\n\n\n## 题目描述\n\n简单说： 就是给定一个二维数组rooms， `rooms[i]` 代表的是房间，房间内有n把钥匙 `rooms[i][j]`, 获得所有房间内的钥匙后能不能把房间都打开\n\n\n### 示例1\n\n```html\n输入: [[1],[2],[3],[]]\n输出: true\n解释:  \n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n```\n\n### 示例2\n\n```html\n输入：[[1,3],[3,0,1],[2],[0]]\n输出：false\n解释：我们不能进入 2 号房间。\n```\n\n## 分析\n\n### 方法一\n\n直接暴力破解， 就是遍历数组，把数组中的值放到 `Set` 里面，然后最后遍历一次状态数组即可\n\n### 方法二\n\n用递归\n\n* 建立状态机。\n* 建立递归函数\n    * 当 当前房间的状态为 `true` 的时候，那么 表示这个房间已经进来过了，所以不用再继续遍历了\n    * 当 当前房间的状态为 `false`的时候，那么表示当前房间没去过，把当前房间设置为`true`, 然后遍历当前房间的钥匙，继续递归\n* 最后，遍历上面的状态机，如果有一个为false, 那么`返回false`，只有全部为true才`返回false`\n\n\n## 代码\n\n```js\n/**\n * @param {number[][]} rooms\n * @return {boolean}\n */\nvar canVisitAllRooms = function(rooms) {\n    let length = rooms.length;\n    let result = Array(length).fill(false);\n\n    setStatus(result, rooms, 0);\n\n    for(let i = 0; i < result.length; i++) {\n        if(!result[i]) {\n            return false\n        }\n    }\n    return true\n};\n\nvar setStatus = function(result, rooms, roomId) {\n    if(result[roomId]) {\n        return ;\n    }\n\n    const roomData = rooms[roomId];\n    result[roomId] = true\n    for(let i = 0; i < roomData.length; i++) {\n        setStatus(result, rooms, roomData[i])\n    }\n\n}\n```\n","tags":["algorithm-递归","algorithm-深度遍历搜索"]},{"title":"对antd-pro一些理解","url":"/2020/08/26/对antd-pro一些理解/","content":"\n[umi文档](https://umijs.org/)\n\n执行 `npm create umi` 创建 `antd-pro` 项目\n\n\n## 路由\n\n整个 umi 建立的项目可以自定义路由，也可以约定式路由，我就直接对自定义路由展开\n配置可以写在 `config/config.ts` 下或者写在根目录下 `.umirc.ts` 的**routes**中\n\n```jsx\n{\n    path: '/',\n    component: '../layouts/BlankLayout',\n    routes: [\n    {\n        path: '/',\n        component: '../layouts/UserLayout',\n        Routes: ['src/pages/Authorized'],\n        authority: ['admin', 'user'], // 权限角色\n        routes: [\n            {\n                name: '/test',\n                icon: 'smile',\n                path: '/test',\n                component: './test',\n            },\n            {\n                name: '/test2',\n                authority: ['admin', 'user'], // 权限角色\n                routes: [\n                    {\n                        name: '',\n                        icon: 'smile',\n                        path: '/test2/step1'\n                    }\n                ]\n            }\n           \n        ],\n    }\n}\n```\n\n### 侧边栏/导航栏\n\n**注意：**我们暂时不对它内置路由到底是怎么实现的，但我想的其原理就是对`react-router`进行配置吧\n\n路由设置完之后对**导航栏进行配置**, [文档](https://procomponents.ant.design/components/layout#%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96)\n\n另外[umi文档中的插件](https://umijs.org/zh-CN/plugins/plugin-layout#logo) 也是可以进行导航栏的废纸的\n\n#### @ant-design/pro-layout\n\n[文档](https://procomponents.ant.design/components/layout#%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96)\n\n```jsx\n<ProLayout\n    // 这里的route是在上面配置自动获取的，不配置那么就不会显示在导航栏中\n    route={props.route}  \n>\n</ProLayout>\n```\n\n## 权限\n\n说一下antd-pro的权限, 我们可以看到 `utils/authority.ts`, 作用是获取/设置`localstorage`中的用户角色，然后通过路由中的 `Route`跟`authority` 判断其是否有准入条件。 \n\n**v4.1.0貌似有bug，不会经过`pages/Authority.tsx`判断权限**\n\n* 先通过 `pages/Authority.tsx` 文件判断**用户登录**以及**权限路由**\n    * 用户已登录， 获取当前`location.pathname`在路由表中的权限，一直向上找，跟`localstorage`获取的权限判断，没权限 跳转到 `403`\n    * 用户没登录，跳转登录页\n    * 然后再经过路由下的 `Component`, 或者说是他的`Children`\n\n### 查看封装的<Authorized/> 组件\n\n项目多次使用该组件， 使用方法如下：\n\n```js\nconst notMatch = (\n    <div>not Match</div>\n)\n/**\n * @param {string | string[] | Promise<boolean>} authority\n * @param { React.ReactNode } notMatch\n * \n*/\n\n<Authorized authority={authorized!.authority} noMatch={noMatch}>\n    {children}\n</Authorized>\n```\n\n#### Authorized 实现\n\n```jsx\n// 此时的 RenderAuthorize 来自 src/Authorithy/index\n// 重新包装了一下Authority，使得 currentAuthority = ['admin', 'user'] 在整个周期都能使用\n// getAuthority 就是获取当前权限\nlet Authorized = RenderAuthorize(getAuthority()); // 此时还是从新包装了一下Authorited\n```\n* RenderAuthorize\n\n```jsx\nconst RenderAuthorize = renderAuthorize(Authorized);\n```\n\n返回闭包，同时导出CURRENT, 当前`current` 也就是 `getAuthority()`的值， 也可以理解成一个`HOC`吧\n\n```jsx\n/**\n * use  authority or getAuthority\n * @param {string|()=>String} currentAuthority\n */\nfunction renderAuthorize(Authorized) {\n    return function (currentAuthority) {\n        if (currentAuthority) {\n            if (typeof currentAuthority === 'function') {\n                CURRENT = currentAuthority();\n            }\n\n            if (Object.prototype.toString.call(currentAuthority) === '[object String]' || Array.isArray(currentAuthority))\n                {\n                    CURRENT = currentAuthority;\n                }\n            } else {\n                CURRENT = 'NULL';\n            }\n\n        return Authorized;\n    };\n}\nexport { CURRENT }\nexport default (Authorized) => renderAuthorize(Authorized);\n```\n\n* <Authorized>\n\n这个组件逻辑很简单， 需要看`check`函数，传入的`authority` 是 ['admin'] 为例子\n如果通过`check` 那么返回`children`, 否则返回 `<notMatch>`\n\n```jsx\nconst Authorized: React.FunctionComponent<AuthorizedProps> = ({\n  children,\n  authority,\n  noMatch = (\n    <Result\n      status=\"403\"\n      title=\"403\"\n      subTitle=\"Sorry, you are not authorized to access this page.\"\n    />\n  ),\n}) => {\n  const childrenRender: React.ReactNode = typeof children === 'undefined' ? null : children;\n  //\n  const dom = check(authority, childrenRender, noMatch);\n  return <>{dom}</>;\n};\n\n```\n\n* 在来看看check函数\n\n下面的CURRENT 就是上面的`renderAuthorize` 导出的CURRENT\n\n```jsx\n/**\n * @param {string| stirng[]} authority 这里的authority 就是 ['admin'], 也就是准入条件\n * @param { React.ReactNode } target 也就是 children\n * @param { React.ReactNode } Exception notMatch\n*/\nfunction check<T, K>(authority: IAuthorityType, target: T, Exception: K): T | K | React.ReactNode {\n  return checkPermissions<T, K>(authority, CURRENT, target, Exception);\n}\n```\n\n* 再来看看 checkPermissions\n\n1. 如果准入权限为空，那么直接渲染`target`\n2. 要是`authority`跟`currentAuthority`都是数组的时候，那看看有没有交集有交集那就返回`target`\n3. 要是`authority`为字符串，那么看看我们的current中有没有这个权限就可以了\n4. 要是`authority`为`promise`那么就进入promise的操作\n5. 要是`authority`为方法，那就执行一下， 参数为`current`\n\n```js\n/**\n * 通用权限检查方法\n * Common check permissions method\n * @param { 权限判定 | Permission judgment } authority\n * @param { 你的权限 | Your permission description } currentAuthority\n * @param { 通过的组件 | Passing components } target\n * @param { 未通过的组件 | no pass components } Exception\n */\nconst checkPermissions = <T, K>(\n  authority: IAuthorityType,\n  currentAuthority: string | string[],\n  target: T,\n  Exception: K,\n): T | K | React.ReactNode => {\n  // 没有判定权限.默认查看所有\n  // Retirement authority, return target;\n  if (!authority) {\n    return target;\n  }\n  // 数组处理\n  if (Array.isArray(authority)) {\n    if (Array.isArray(currentAuthority)) {\n      if (currentAuthority.some((item) => authority.includes(item))) {\n        return target;\n      }\n    } else if (authority.includes(currentAuthority)) {\n      return target;\n    }\n    return Exception;\n  }\n  // string 处理\n  if (typeof authority === 'string') {\n    if (Array.isArray(currentAuthority)) {\n      if (currentAuthority.some((item) => authority === item)) {\n        return target;\n      }\n    } else if (authority === currentAuthority) {\n      return target;\n    }\n    return Exception;\n  }\n  // Promise 处理\n  if (authority instanceof Promise) {\n    return <PromiseRender<T, K> ok={target} error={Exception} promise={authority} />;\n  }\n  // Function 处理\n  if (typeof authority === 'function') {\n    const bool = authority(currentAuthority);\n    // 函数执行后返回值是 Promise\n    if (bool instanceof Promise) {\n      return <PromiseRender<T, K> ok={target} error={Exception} promise={bool} />;\n    }\n    if (bool) {\n      return target;\n    }\n    return Exception;\n  }\n  throw new Error('unsupported parameters');\n};\n```\n\n\n## 登录组件\n\n`pages/user/login` 查看 `index.tsx`\n\n`Login`页面有一个 <LoginForm> 包裹着两个 `<Tab>`, `<Tab>`下面又是一下Input组件，只是被重新包装了\n\n```jsx\n// 我们可以看出 UserName, Password 等等都是LoginForm导出的\nconst { Tab, UserName, Password, Mobile, Captcha, Submit } = LoginForm;\n```\n\n我们看下 `Login` 这个页面的大体结构\n\n* 用一个`<LoginForm />` 包裹着两个`<Tab>`, `<Tab>` 底下是登录按钮还有其他的登录方式\n* 其中一个`<Tab>对应的是账号密码登录`， 另一个是`短信验证码登录`\n* 下面的`status`, `loginType` 是 `redux`的状态，表示登录失败后会有报错信息\n* `<LoginForm>` 的 `activeKey` 只有两个 `account`, `mobile` 代表账号登录跟短信登录\n\n\n```jsx\n<LoginForm activeKey={type} onTabChange={setType} onSubmit={handleSubmit}>\n  <Tab key=\"account\" tab=\"账户密码登录\">\n    {status === 'error' && loginType === 'account' && !submitting && (\n      <LoginMessage content=\"账户或密码错误（admin/ant.design）\" />\n    )}\n    <UserName/>\n    <Password/>\n  </Tab>\n  <Tab key=\"mobile\" tab=\"手机号登录\">\n    {status === 'error' && loginType === 'mobile' && !submitting && (\n      <LoginMessage content=\"验证码错误\" />\n    )}\n    <Mobile/>\n    <Captcha/>\n  </Tab>\n  <div>\n    <Checkbox checked={autoLogin} onChange={(e) => setAutoLogin(e.target.checked)}>\n      自动登录\n    </Checkbox>\n    <a>忘记密码</a>\n  </div>\n  <Submit loading={submitting}>登录</Submit>\n  <div className={styles.other}>\n    其他登录方式\n    <AlipayCircleOutlined className={styles.icon} />\n    <TaobaoCircleOutlined className={styles.icon} />\n    <WeiboCircleOutlined className={styles.icon} />\n    <Link className={styles.register} to=\"/user/register\">\n      注册账户\n    </Link>\n  </div>\n</LoginForm>\n```\n\n### <LoginForm>\n\n* 首先先创建一个 `Context`， 这个context 主要是给 `<LoginTab>` 使用的\n\n\n#### LoginTab 实现\n简单看就是 \n\n```jsx\n// antd 官网\n<Tabs defaultActiveKey=\"1\" onChange={callback}>\n  <TabPane tab=\"Tab 1\" key=\"1\">\n    Content of Tab Pane 1\n  </TabPane>\n  <TabPane tab=\"Tab 2\" key=\"2\">\n    Content of Tab Pane 2\n  </TabPane>\n  <TabPane tab=\"Tab 3\" key=\"3\">\n    Content of Tab Pane 3\n  </TabPane>\n</Tabs>\n```\n\n\n```js\nconst LoginTab: React.FC<LoginTabProps> = (props) => {\n  useEffect(() => {\n    const uniqueId = generateId('login-tab-'); //治理生成唯一的tab id\n    const { tabUtil } = props;\n    if (tabUtil) {\n      tabUtil.addTab(uniqueId);\n    }\n  }, []);\n  const { children } = props;\n  return <TabPane {...props}>{props.active && children}</TabPane>;\n};\n\nconst WrapContext: React.FC<TabPaneProps> & {\n  typeName: string;\n} = (props) => (\n  <LoginContext.Consumer>\n    {(value) => <LoginTab tabUtil={value.tabUtil} {...props} />}\n  </LoginContext.Consumer>\n);\n```\n\n我们看看provider 的用法\n\n```jsx\n// 此时这里用上了hook然后加载的时候会加载一个tab，当切换的时候会添加另一个tab\nconst [tabs, setTabs] = useState<string[]>([]);\n// 这个active貌似没什么用\nconst [active, setActive] = useState({});\n// 此时声明当前的tab是哪一个 是 account 还是 mobile\nconst [type, setType] = useMergeValue('', {\n  value: props.activeKey,\n  onChange: props.onTabChange,\n});\n<LoginContext.Provider\n  value={{\n    tabUtil: {\n      addTab: (id) => {\n        setTabs([...tabs, id]);\n      },\n      removeTab: (id) => {\n        setTabs(tabs.filter((currentId) => currentId !== id));\n      },\n    },\n    updateActive: (activeItem) => {\n      if (!active) return;\n      if (active[type]) {\n        active[type].push(activeItem);\n      } else {\n        active[type] = [activeItem];\n      }\n      setActive(active);\n    },\n  }}\n>\n<LoginContext.Provider>\n\n```","tags":["react","antd"],"categories":["react","antd"]},{"title":"电话号码的字母组合","url":"/2020/08/26/电话号码的字母组合/","content":"\n[电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)\n\n## 题目描述\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n<div style=\"display: flex; flex-direction: row; justify-content: flex-start;\">\n    <img src=\"./电话号码的字母组合/1.png\"  alt=\"电话\" style=\"width: 200px; height: 200px;\"/>\n</div>\n<!-- ![电话](./电话号码的字母组合/1.png) -->\n\n\n### 示例\n\n```html\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n```\n\n## 思路\n\n![全排列](./电话号码的字母组合/2.jpg)\n\n* 将 数字跟字母 建立映射关系 `{2: 'abc'}`,\n* 数字的长度，就是遍历的深度，递归时，深度减一，当深度为0的时候，停止递归，返回结果，当深度为1的时候，添加到结果\n* 当需要继续递归的时候，保留之前的结果，此结果为了下一次遍历字母的时候，为每一个结果都要添加新的字符\n\n* 以 `\"23\"` 为例子， 转换字母 `array = ['abc', 'def']`\n* `prefix = [], result = []`, 我们循环 `array`, 每次抽出 `array[0]`, 对`array[0]`进行遍历\n    * 当 `prefix` 里面没东西的时候，我们直接将 `array[0]`的值丢进去， 此时 `prefix = ['a', 'b', 'c']`, 进入下一次递归\n* 继续上面的操作， 此时我们的 `array = ['def']`, 抽`array[0]`, 对他进行遍历，`prefix = ['a', 'b', 'c'], result = [], dept = 1`\n    * 现在要对 `def` 遍历，跟 `prefix` 组合成 `['ad', 'bd', 'cd', 'ae', 'be', 'ce', 'af', 'bf', 'cf']`, 此时dept = 1 可以将结果放到 `result`了，继续递归\n* 此时`dept = 0` 退出递归\n\n\n## 代码\n\n```jsx\nvar letterCombinations = function(digits) {\n    let length = digits.length;\n    let result = [];\n    let string = [];\n    let map = {\n        '2': 'abc',\n        '3': 'def',\n        '4': 'ghi',\n        '5': 'jkl',\n        '6': 'mno',\n        '7': 'pqrs',\n        '8': 'tuv',\n        '9': 'wxyz',\n    }\n\n    for(let i = 0; i < length; i++) {\n        string.push(map[digits[i]])\n    }\n    contribute(result, string, [], length);\n    \n    return result;\n};\n\nvar contribute = function(result, array, prefix, dept) {\n    if(dept == 0) {\n        return prefix\n    }\n    let current = array[0];\n    let temp = []\n    let prefixLength = prefix.length;\n    // current = \"def\"; prefix = [a, b, c]\n    for(let i = 0; i < current.length; i++) {\n        if(prefixLength == 0) {\n            temp.push(current[i]);\n            if(dept == 1) {\n                result.push(current[i]);\n            }\n            continue;    \n        }\n        \n        for(let j = 0; j < prefixLength; j++) {\n            let s = prefix[j] + current[i];\n            temp.push(s);\n            if(dept == 1) {\n                result.push(s);\n            }\n        }       \n    }\n    contribute(result, array.slice(1), temp, --dept)\n    \n}\n```","tags":["algorithm-递归","algorithm-深度遍历搜索","algorithm-全排列"]},{"title":"奇偶链表","url":"/2020/08/25/奇偶链表/","content":"\n[奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)\n\n## 题目描述\n\n给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。\n\n请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。\n\n### 示例\n\n```html\n输入: 1->2->3->4->5->NULL\n输出: 1->3->5->2->4->NULL\n```\n\n### 分析\n\n* 先建立 `odd` 和 `even` 指针，分别指向的是**奇链表**, **偶链表**\n* 建立 `p` 和 `q`, 指向 `odd` 和 `even`\n* 遍历 `head` 链表，`odd.next 指向 head`, `even.next = head.next`, 就是说一次遍历直接跳两个元素\n* 修改 head 指向 `head = head.next.next`, 但此时需要判断 `head.next`是否为`null`\n* 修改 `odd` 和 `even`, `odd = odd.next; even = even.next`;\n* 最后修改 `odd.next` 指向 `even` 的开头即可\n\n\n## 题解\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar oddEvenList = function(head) {\n    let odd = new ListNode(\"head\", null);\n    let even = new ListNode(\"head\", null);\n\n    let p = odd;\n    let q = even;\n\n    while(head) {\n        odd.next = head;\n        even.next = head.next ? head.next : null\n        head = head.next && head.next.next ? head.next.next : null;\n        odd = odd.next;\n        even = even.next;\n    }  \n    odd.next = q.next;\n    return p.next;\n\n};\n```","tags":["algorithm-链表"]},{"title":"递增子序列","url":"/2020/08/25/递增子序列/","content":"\n[递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)\n\n## 题目描述\n\n给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。\n\n### 示例1\n\n```html\n输入: [4, 6, 7, 7]\n输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n```\n\n### 示例2\n\n```html\n输入: [4, 3, 2, 1]\n输出: []\n```\n\n## 题目分析\n\n我们以`[4, 6, 7, 7]`为例子\n\n![树](./递增子序列/树.jpg)\n\n* 一开始我们的数组为`array = [4,6,7,7]`, 结果集为`result = []`, 暂存结果集为 `prefix = []`, 遍历数组\n* 遍历开始，值为`4`, 放入暂存结果集，此时`prefix = [4]`, 我们**暂时不考虑顺序和是否重复**，把剩下的数组继续递归遍历\n* 此时 `array = [6, 7, 7]`, 把 `6` 取出来，`prefix = [4, 6]`, 此时 prefix 的长度 >= 2 放入 result，此时 `result = [[4, 6]]`, 把剩下的`[7,7]`继续递归，回溯之后这层可以整 `result = [[4,6],[4,7],[4,7]]`， 不过这是回溯之后的结果\n* 此时 `array = [7, 7]`, `prefix = [4, 6]`, `reuslt = [[4, 6]]`; 执行操作像上面一步\n\n\n## 实现代码\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar findSubsequences = function(nums) {\n    let result = [];\n    contribute(result, nums, [])\n    return result\n};\n\nvar contribute = function(result, array, prefix) {\n    let length = array.length;\n    if(length == 0) {\n        return result;\n    }\n    let isInlcude = [];\n\n    for(let i = 0; i < length; i++) {\n        if(isInlcude.includes(array[i])) { // 去重\n            continue;\n        }\n        const last = prefix.length > 0 ? prefix[prefix.length - 1] : null;\n        // 如果prefix 的最后一个数 比当前数要大，那就不符合，例如 prefix = [4, 5]; 此时last 应该是5，array[i] = 1, 5>1不符合题意 \n        if(last !== null && last > array[i]) { \n            continue;\n        }\n        const temp = prefix.concat(array[i]);\n        isInlcude.push(array[i])\n        if(temp.length > 1) {\n            result.push(temp);\n        }\n        contribute(result, array.slice(i + 1, array.length), temp);\n    }\n    return result\n}\n```","tags":["algorithm-递归","algorithm-深度遍历搜索","algorithm-全排列"]},{"title":"回文子串","url":"/2020/08/19/回文子串/","content":"\n[回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)\n\n## 题目描述\n\n给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。\n\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n\n### 示例\n\n**示例1**\n\n```html\n输入：\"abc\"\n输出：3\n解释：三个回文子串: \"a\", \"b\", \"c\"\n```\n\n**示例2**\n\n```html\n输入：\"aaa\"\n输出：6\n解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"\n```\n\n## 解决思路\n\n### 方法1 暴力破解\n\n我们用**ababa**做例子, 对字符串做遍历，i 表示字符串的第n个数\n\n* `i = 0`, 字符 `a`, 判断一下是否是回文，是的话`count + 1`。 此时我们保留上一次的字符`['a']`\n* `i = 1`, 字符 `b`, 此时我们对上一次字符数组的所有子串都添加`b`, 注意这里也要加上自身`b`, 也就是 `['b', 'ab']` 去判断一下是否是回文，此时再将上面数组保留下来。\n* `i = 2`, 字符 `c`, 我们继续做上面的操作, 先记录自身`c`, 再对上面保留下来的字符做`c`字符添加，也就是 `['c', 'bc', 'abc']`, 对数组做回文判断，如此类推\n\n我们总结一下，看下每次操作的数组\n1. `['a']`\n2. `['b', 'ab']`\n3. `['c', 'bc', 'abc']`\n4. `['b', 'cb', 'bcb', 'abcb']`,\n5. `['a', 'ba', 'cba', 'bcba', 'abcb']`\n\n```js\n// 完整代码\n/**\n * @param {string} s\n * @return {number}\n */\nvar countSubstrings = function(s) {\n    let count = 0;\n    let length = s.length;\n\n    if(length === 0) {\n        return count\n    }\n\n    let prev = [s[0]];\n    count = 1;\n    \n    for(let i = 1; i < length; i++) {\n        let current = [s[i]];\n        count++;\n\n        for(let j = 0; j < prev.length; j++) {\n            let temp = prev[j] + s[i];\n            if(ishuiwen(temp)) {\n                count++;\n            }\n            current.push(temp);\n        }\n        prev = current;\n    }\n    return count;\n};\n\nvar ishuiwen = function(s) {\n    let start = 0;\n    let end = s.length - 1;\n\n    while(start < end) {\n        let ss = s[start];\n        let es = s[end];\n\n        if(ss !== es) {\n            return false\n        }\n\n        start++;\n        end--\n    } \n    return true\n}\n```\n\n### 方法二 动态规划\n\n[题解](https://leetcode-cn.com/problems/palindromic-substrings/solution/shou-hua-tu-jie-dong-tai-gui-hua-si-lu-by-hyj8/)\n\n上面 `s[i][j]` 指的是 `s[i:j]` 的子串, 比如 i = 1, j = 3, 以`ababa` 例子, `s[i:j] => s[1:3]` 就是字符串中的`bab`\n","tags":["algorithm-动态规划"]},{"title":"有序链表转换二叉搜索树","url":"/2020/08/18/有序链表转换二叉搜索树/","content":"\n[有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n**这道题跟[将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)有点相似**\n\n## 题目描述\n\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1\n\n### 示例1\n\n```html\n给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n\n```\n\n\n## 分析\n\n* 先把**链表**遍历出来，然后进行下面的操作\n* [具体分析可以看](https://chow_bill.gitee.io/2020/07/03/108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/)\n\n\n## 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    let array = getSortedList(head);\n    let res = toBST(array);\n    return res;\n};\n\nvar getSortedList = function(head) {\n    let result = [];\n    let p = head;\n\n    while(p != null) {\n        result.push(p.val);\n        p = p.next;\n    }\n\n    return result;    \n}\n\nvar toBST = function(array) {\n    let length = array.length;\n\n    if(length == 0) {\n        return null\n    }\n\n    let mid = Math.floor(length / 2);\n    let left = array.slice(0, mid);\n    let right = array.slice(mid + 1, length);\n\n    let root = new TreeNode(array[mid]);\n    root.left = toBST(left);\n    root.right = toBST(right);\n\n    return root;\n}\n```\n","tags":["algorithm-二叉树","algorithm-递归"]},{"title":"有效括号","url":"/2020/08/14/有效括号/","content":"\n[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n\n## 题目描述\n\n给定一个只包括 `'('，')'，'{'，'}'，'['，']'` 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n\n**注意**空字符串可被认为是有效字符串。\n\n### 示例\n\n示例1： \n\n```html\n输入: \"()\"\n输出: true\n```\n\n示例2： \n\n```html\n输入: \"()[]{}\"\n输出: true\n```\n\n示例3： \n\n```html\n输入: \"([)]\"\n输出: false\n```\n\n示例4： \n\n```html\n输入: \"{[]}\"\n输出: true\n```\n\n## 思路\n\n* 遍历 `s`\n* 当遇到`[`, `(`, `{` 这些括号的时候就入栈。\n* 当遇到`]`, `)`, `}` 这些括号的时候就出栈，出栈 判断与当前`s[i]` 是否匹配为闭合的括号, 即是否是一对。出栈`(`, 当前`s[i]`为`)`则为一对\n\n## 代码\n\n```js\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    let length = s.length;\n    // 做优化，看了答案后添加\n    if(length % 2 == 1) {\n        return false;\n    }\n\n    // 建立字典， \n    let map = {\n        \"{\": \"}\",\n        \"(\": \")\",\n        \"[\": \"]\",\n    }\n\n    let inqueue = [\"{\", \"(\", \"[\"];\n    let stack = [];\n\n    for(let i = 0; i < s.length; i++) {\n        const current = s[i];\n        // 判断以下是否属于开合 的括号\n        if(inqueue.includes(current)) {\n            stack.unshift(current);\n            continue;\n        }\n\n        // 出栈， 判断当前出栈的括号是否跟 s[i] 为一对，\n        let pop = stack.shift();\n        if(current !== map[pop]) {\n            return false\n        } \n    }\n    // 最后判断以下栈里面还有没有数据，有的话那就代表还有没有匹配的括号\n    return stack.length == 0 ;\n};\n```\n\n","tags":["algorithm-栈"]},{"title":"字符串相乘","url":"/2020/08/13/字符串相乘/","content":"\n[字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)\n\n## 题目描述\n\n给定两个字符串 `num1` 和 `num2` ,返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n\n示例：\n\n```html\n输入: num1 = \"2\", num2 = \"3\"\n输出: \"6\"\n```\n\n\n## 分析\n\n我们以 `num1 = \"123\"`, `num2 = \"456\"`做例子\n\n```html\n       1  2  3\n       4  5  6\n    --------------\n    1  3  6  8\n    9  1  2  0       \n 4  5  6\n ------------------\n 5  6  0  8  8\n```\n\n* 我们循环 123，分别乘以下面的 456,\n* 3 * 456 得到的是 1368\n* 2 * 456 得到的是 912， 但此时的2应该是20， 所以得到的结果是 9120\n* 1 * 456 得到的是 456， 但此时的1应该是100，所以得到的结果是 45600\n* 将这三个结果加起来即可\n\n**注意：**我们每次相乘的结果都用数组存起来， `1368 => [1,3,6,8]` 如此类推\n\n* 后面就是大数相加了，将所有的数组都加起来，另外这里使用了分治 \n\n## 代码\n\n```js\n/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar multiply = function(num1, num2) {\n    if(num1 == 0 || num2 == 0) {\n        return \"0\";\n    }\n    \n    let length1 = num1.length;\n    let length2 = num2.length;\n    \n    let multiplyAdd = 0;\n    let times = 0; \n    let resArr = []\n    for(let i = length1 - 1; i >= 0; i--) {\n        let currentNum1 = num1[i] * 1\n        let resultArray = []\n        for(let j = length2 - 1; j >= 0; j--) {\n            const tempRes = currentNum1 * (num2[j] * 1) + multiplyAdd;\n            const div = tempRes % 10;\n            multiplyAdd = Math.floor(tempRes / 10);\n            resultArray.unshift(div)\n        }\n        if(multiplyAdd > 0) {\n            resultArray.unshift(multiplyAdd);\n            multiplyAdd = 0;\n        }\n        for(let k = 0; k < times; k++) {\n            resultArray.push(0)\n        }\n        times++;\n        resArr.push(resultArray.join(\"\"))\n    }\n    if(resArr.length <= 1) {\n        return resArr.join(\"\")\n    }\n    const test = fenzhi(resArr);\n\n    return test.join(\"\");\n   \n};\n\n/** \n * [\"1386\", \"9120\", \"45600\"]\n * 递归分支\n * 递归结束条件时，数组只剩下一个的时候, 直接返回\n * 剩下的就是左右两个相加了 combine(left, right),  // 简单说就是 left + right\n */ \nvar fenzhi = function(arr) {\n    let length = arr.length;\n    if(length == 1) {\n        return arr.join(\"\");\n    }\n    \n    const currentIndex = Math.floor(arr.length / 2);\n    let left = arr.slice(0, currentIndex);\n    let right = arr.slice(currentIndex, length);\n\n    return  combine( fenzhi(left) , fenzhi(right) );\n}\n\n// 我这里使用大数相加\nvar combine = function(arr1, arr2) {\n    let result = [];\n    let length1 = arr1.length - 1;\n    let length2 = arr2.length - 1;\n\n    let add = 0;\n\n    let i = 0;\n    let j = 0;\n\n    while(length1 >= 0 || length2 >= 0) {\n        let num1 = length1 >= 0 ? arr1[length1] : 0;\n        let num2 = length2 >= 0 ? arr2[length2] : 0\n        let res = num1 * 1 + num2 * 1 + add * 1;\n        let div = res % 10;\n        add = Math.floor(res / 10);\n        result.unshift(div);\n        length2--;\n        length1--;\n    }\n    if(add > 0) {\n        result.unshift(add);\n    }\n    // console.log(\"result\", result)\n    return result;\n}\n```\n\n","tags":["algorithm-数组","algorithm-分治"]},{"title":"剑指 Offer 55 - II. 平衡二叉树","url":"/2020/08/12/剑指-Offer-55-II-平衡二叉树/","content":"\n[剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)\n\n## 题目描述\n\n输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n\n示例 1:\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n```html\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n返回 true 。\n\n\n## 分析\n\n* 我们每次获取左右节点的最大深度，然后相减要是 <= 1\n* 在递归左右节点\n\n## 代码\n\n```js\nvar isBalanced = function(root) {\n    if(!root) {\n        return true\n    }\n\n    let left = dept(root.left);\n    let right = dept(root.right);\n    return Math.abs(left - right) <= 1 && isBalanced(root.left) && isBalanced(root.right)\n}\n\nvar dept = function(root) {\n    if(!root) {\n        return 0;\n    }\n\n    return Math.max( dept(root.left), dept(root.right) ) + 1\n}\n```\n","tags":["algorithm-二叉树","algorithm-深度遍历搜索"]},{"title":"关于this","url":"/2020/08/11/关于this/","content":"\n参考 《你不知道的JavaScript上卷》\n\n我们经常会对this的指向存在疑惑，搞不清楚是指向window，还是本身。\n\n## this 的解析\n\n* **this是在运行时进行绑定的，并不是在编写时绑定，**\n* **它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式**\n\n## this 规则\n\n我们要清楚知道**在函数的执行过程中调用位置是如何确定this的绑定对象的**。\n\n我们分析 函数是属于以下四种规则的哪一种既可。\n\n* 默认绑定\n* 隐式绑定\n* 显示绑定\n* 硬绑定\n\n### 默认绑定\n\n默认绑定是最常用的一种方式，**可以把这条规则看作是无法应用其他规则时的默认规则。**\n\n```js\n// 例子\n\nfunction foo() {\n    console.log(this); // this 指向的是window\n}\n\n// 此时我们调用的位置在全局，那么foo 的this指向的是window\nfoo();\n```\n\n**注意：**默认绑定在严格模式下，会报错。 严格模式下，默认绑定会将this绑定到undefined\n\n\n### 隐式绑定\n\n一般来说隐式绑定就是`obj.func()`这样子。但我们看看下面的注意事项\n\n```js\n// 这里要注意foo的声明方式\nfunction foo() {\n    console.log(this.a) // 123\n}\n\nconst obj = {\n    a: \"123\",\n    foo: foo\n}\n//obj对象引用了foo, 调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象“拥有”或者“包含”它。\nobj.foo();\n```\n\n**隐式调用：** 当函数引用有上下文的时候，函数的this会绑定到上下文对象中。\n\n但是对象属性引用链中**只有上一层或者说最后一层在调用位置中起作用**\n\n```js\n// 例子\nfunction foo() {\n    console.log(this.a) \n}\n\nconst obj = {\n    a: \"123\",\n    foo: foo\n}\n\nconst obj2 = {\n    a: \"2\",   // \n    obj: obj\n}\n\n// 这里是最后一层起作用了\nobj2.obj.foo();  // 123\n```\n\n**隐式丢失**\n\n简单说就是函数丢失了原来的绑定对象，然后**函数使用默认绑定的方式**，导致了this指向`window`或者是`undefined`\n\n```js\n\nfunction foo() {\n    console.log(this.a) \n}\n\nconst obj = {\n    a: \"123\",\n    foo: foo\n}\nvar a = \"windows\";\n\n// 虽然 obj.foo 引用的是foo 函数，但是它等同于使用foo(), 这样看的话他的调用方式是全局的，所以使用默认绑定\nconst test = obj.foo;\ntest()  // windows,  \n```\n\n另外还有**回调函数**会造成this的丢失，所以我们一般用`call`或者`apply`去改变this的指向\n\n```js\n// 例子\nfunction foo() {\n    console.log(this.a) \n}\n\nconst obj = {\n    a: \"123\",\n    foo: foo\n}\nvar a = \"windows\";\n\nfunction doFoo(fn) {\n    // fn => foo\n    fn()\n}\n\ndoFoo(obj.foo)\n```\n\n### 显示绑定\n\n显示绑定主要是使用了 `call` 和 `apply`, 我们可以理解 当函数调用是，this 的指向更改为`call`函数或者`apply`函数的**第一个参数**\n\n\n```js\nvar obj = {\n    a: \"123\"\n}\n\nfunction foo() {\n    console.log(this.a)\n}\n\nfoo.call(obj); // 123， 我们理解成 当foo函数调用的时候 this 指向 obj\n```\n**我们可以理解为 foo.call(obj) => foo(), 但是this指向了obj**\n\n我们看下一个最常用的操作\n\n```js\n// 辅助函数\nfunction bind(fn, obj) {\n    return function() {\n        return fn.apply(obj, arguments);\n    }\n} \n\nfunction foo(params) {\n    console.log(this.a, params)\n}\n\nvar obj = {\n    a: \"123\"\n}\n\nvar test = bind(foo, obj); // bind函数返回的是function\ntest(\"hahah\") // 输出： 123，hahah\n```\n\n\n### new 绑定\n\n使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n\n1. 创建（或者说构造）一个全新的对象。\n1. 这个新对象会被执行[[Prototype]]连接。\n1. 这个新对象会绑定到函数调用的this。\n1. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。\n\n我们先看看new的实现源码\n\n```js\nfunction new(fn, ...args) {\n    let obj = {};\n    obj._proto_ = fn.prototype; \n    let res = fn.call(obj, ...args);\n    \n    let isObject = typeof res === 'object' && typeof res !== null;\n    let isFunction = typeof res === 'function';\n    return isObject || isFunction ? res : obj;\n}\n```\n\n看到上面第三步，`call` 改变了`fn` this的指向\n\n```js\nfunction foo(a) {\n    this.a = a\n}\n\nvar obj = new foo(2)\nconsole.log(obj.a); // 2\n\n```\n\n## 优先级\n\nnew > 显式绑定 > 隐式绑定 > 默认绑定\n\n\n## 我们看看 如何实现 apply 和 call方法\n\n\n### call\n```js\n// call 方法类似, call 方法实现方式跟下面一样\nvar foo = {\n    value: 1,\n    bar: function() {\n        console.log(this.value)\n    }\n}\nfoo.bar() // 1\n\n// fn.call(obj, 1, 2)\nFunction.prototype.imitateCall = function (context) {\n    // 这里的context 同等于上面的 foo， 如果context没有那么我们指定到window\n    context = context || window    \n   \n    // 当前this 指的是 function\n    context.invokFn = this    \n    // 截取作用域对象参数后面的参数\n    let args = [...arguments].slice(1)\n    // 执行调用函数，记录拿取返回值\n    let result = context.invokFn(...args)\n    // 销毁调用函数，以免作用域污染\n    Reflect.deleteProperty(context, 'invokFn')\n    return result\n}\n\n```\n\n### apply\n\n```js\n// fn.apply(obj, [1, 2])\nFunction.prototype.imitateApply = function (context) {\n    // 这里的context 同等于上面的 foo， 如果context没有那么我们指定到window\n    context = context || window    \n    // 当前this 指的是 function\n    context.invokFn = this    \n    // 截取作用域对象参数后面的参数\n    let result\n    if (arguments[1]) {\n        result = context.invokFn(...arguments[1])\n    } else {\n        result = context.invokFn()\n    }\n    // 销毁调用函数，以免作用域污染\n    Reflect.deleteProperty(context, 'invokFn')\n    return result\n}\n```\n","tags":["javascript"],"categories":["javascript"]},{"title":"计数二进制子串","url":"/2020/08/10/计数二进制子串/","content":"\n[计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)\n\n## 题目描述\n\n给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。\n\n重复出现的子串要计算它们出现的次数。\n\n### 示例：\n\n```html\n输入: \"00110011\"\n输出: 6\n解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。\n\n请注意，一些重复出现的子串要计算它们出现的次数。\n\n另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。\n\n```\n\n## 分析\n\n* 我们直接用 `1100` 做分析例子，我们可以看出其实他的结果就是 2，就只有两种结果`[1100, 10]`\n* 所以我们循环这个字符串，记录相同的的数字 `1`的个数 = 2；然后以当前i做起点，往后遍历两位，要是都相同那么就是2种（此时重复的数字还是2），要是只有一位就只有1种（此时重复的数字就变成1了）\n\n\n## 代码\n\n```jsx\n/**\n * @param {string} s\n * @return {number}\n */\nvar countBinarySubstrings = function(s) {\n    let length = s.length;\n    if(length == 0) {\n        return 0;\n    }\n    \n    let count = 1;\n    let prev = s[0];\n    let currentNum = null;\n    let result = 0;\n    // s = \"1100\"\n    let i = 1;\n    while(i < length) {\n        currentNum = s[i];\n        if(currentNum == prev) { // 为了找相同的数字\n            count++;  // 相同数字的个数\n            i++;\n            continue;\n        }\n\n        // prev = 1; count = 2\n\n        // currentNum 已经跟prev 不一样了， 就是 0 => 1 , 1 => 0， 然后以i为起点，遍历后面count个数\n        let j = i; \n        while(j < i + count && j < length) {\n            // 这里表示 当前数字跟 前一个数字相同的话结果 + 1 ,即当前 prev = 1， s[j] = 0, 就是当前i为去起点，往后两位都是0的话就 + 2\n            if(s[j] == !(prev * 1)) {      \n                result++;\n            } else {  \n                // 此时不一样时，重新计算重复的个数\n                count = j - i\n                break;\n            }\n            j++;\n        }\n\n        i = i + count;\n        prev = currentNum;\n    }\n    return result\n};\n```\n","tags":["algorithm-基础"]},{"title":"相同的树","url":"/2020/08/07/相同的树/","content":"\n\n## 题目描述\n\n给定两个二叉树，编写一个函数来检验它们是否相同。\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n### 示例：\n\n```html\n输入:      1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n输出: true\n```\n\n\n## 分析\n\n* 我们暂定左边的树为p, 右边的树为q\n* 从根分析，要是 p 或 q ，一个为空，另一个不为空，那么我们返回false\n* p 和 q 都为空，那么我们直接返回true\n* p 和 q 都不为空，那么我们判断他们的值是否相同 `p.val === q.val`\n* 递归操作， 判断 p的左子树 跟 q 的左子树 是否相同，执行上面的操作, 所以`isSameTree(p.left, q.left)`； \n    p 的右子树 跟 q 的右子树是否相同，执行上面的操作, 所以 `isSameTree(p.right, q.right)`\n\n\n## 代码\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(!p && q) {\n        return false\n    }\n    if(p && !q) {\n        return false\n    }\n\n    if(!p && !q) {\n        return true\n    }\n\n    if(p.val !== q.val) {\n        return false\n    }\n\n\n    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```","tags":["algorithm-二叉树"]},{"title":"滑动验证码","url":"/2020/08/06/滑动验证码/","content":"\n## 前言\n\n一直想做一个滑动验证码的组件。\n\n\n## html 结构\n\n```html\n<div className={styles.container}>\n    <div className={styles.slider}>\n        <!-- 滑块 -->\n        <div className={styles.sliderHandle} onMouseDown={mouseDown} style={sliderHandleStyle} > >> </div>\n        <!-- 轨道 -->\n        <div className={styles.sliderRail}>\n            <div className={styles.text}>向右滑动验证</div>\n        </div>\n        <!-- 滑块路线 -->\n        <div className={styles.sliderTrack} style={{width: ((offset.x) / 250 * 100 + \"%\"), borderRadius: (offset.x < 250) ? 'none' : '45px' }}></div>\n    </div>\n</div>\n```\n\n## less 结构\n\n主要是一些定位， 相对定位中的绝对定位\n\n```less\n.container {\n\twidth: 400px;\n\theight: 400px;\n\tmargin: 50px auto;\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-items: center;\n\tjustify-content: center;\n\tuser-select: none;\n\n    .slider {\n\t\twidth: 250px;\n\t\theight: 45px;\n\t\tposition: relative;\n\t\tborder-radius: 45px;\n\n\t\t.sliderHandle {\n\t\t\twidth: 45px;\n\t\t\theight: 45px;\n\t\t\tborder-radius: 50%;\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t\tjustify-content: center;\n\t\t\talign-items: center;\n\t\t\tbackground-color: #fff;\n\t\t\tz-index: 99;\n\t\t\tposition: absolute;\n\t\t\tleft: 0;\n\t\t\ttop: 0;\n\t\t\tright: auto;\n\t\t\ttransform: translateX(-50%);\n\t\t\tbox-shadow:  1px 5px 2px #eee;\n\t\t\tcursor: pointer;\n\t\t}\n\n\t\t.sliderRail {\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t\twidth: 100%;\n\t\t\tborder-radius: 45px;\n\t\t\tbackground-color: #f5f5f5;\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t\tjustify-content: center;\n\t\t\talign-items: center;\n\t\t}\n\n\t\t.sliderTrack {\n\t\t\tposition: absolute;\n\t\t\twidth: 0%;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tz-index: 89;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t\tborder-top-left-radius: 45px;\n\t\t\tborder-bottom-left-radius: 45px ;\n\t\t\tbackground-color: #91d5ff;\n\t\t}\n    }\n}\n\n```\n\n## 代码逻辑\n\n代码中主要使用的是 react Hook， 主要的逻辑是使用了 mouseup, mouseover, mouseDown\n\n```jsx\nconst Block: React.FC = () => {\n\tconst [dragging, setDragging] = useState(false);\n\tconst [origin, setOrigin] = useState({ x: 0, y: 0 });\n\tconst [offset, setOffset] = useState({ x: 0, y: 0});\n\n\tconst mouseDown = useCallback(({clientX, clientY}) => {\n\t\tconsole.log(\"mouseDown\", clientX);\n\t\tsetOrigin((state) => ({ x: clientX, y: clientY}))\n\t\tsetDragging(true);\n\t}, []);\n\n\tconst mouseMove = useCallback(({clientX, clientY}) => {\n\t\tlet x =  clientX - origin.x;\n\t\tif( x >= 250 ) {\n\t\t\tx = 250\n\t\t} else if(x / 250 * 100 <= 0 ) {\n\t\t\tx = 0;\n\t\t}\n\t\tconst transition =  { x, y: clientY - origin.y }; \n\t\t\n\t\tif(x >= 250) {\n\t\t\tsetDragging(() => false)\n\t\t}\n\t\tsetOffset(state => {\n\t\t\treturn  {\n\t\t\t\t...state,\n\t\t\t\t...transition\n\t\t\t}\n\t\t});\n\t  }, [origin]);\n\n\tconst mouseUp = useCallback(() => {\n\t\tconsole.log(\"up\")\n\t\t\n\t\tsetDragging(() => false)\n\t\t\n\t  }, []);\n\n\tuseEffect(() => {\n\t  if (dragging) {\n\t\twindow.addEventListener('mousemove', mouseMove);\n\t\twindow.addEventListener('mouseup', mouseUp);\n\t  } else {\n\t\twindow.removeEventListener('mousemove', mouseMove);\n\t\twindow.removeEventListener('mouseup', mouseUp);\n\t\t\n\t\tsetOffset((state) => {\n\t\t\tlet x = state.x\n\t\t\tif(x>= 250) {\n\t\t\t\tconsole.log(\"验证通过\")\t\t\t\n\t\t\t} else if(x< 250) {\n\t\t\t\tx = 0\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: state.y\n\t\t\t}\n\t\t})\n\t  }\n\t}, [dragging]);\n\n\tconst sliderHandleStyle = useMemo(() => ({\n\t\tleft: (offset.x) / 250 * 100 + \"%\",\n\t\ttransition: (!dragging ? 'left 500ms' : 'none' )\n\t}), [offset, dragging])\n\n    return (\n\t\t<div>\n\t\t\t<div className={styles.container}>\n\t\t\t\t<div className={styles.slider}>\n\t\t\t\t\t<div className={styles.sliderHandle} onMouseDown={mouseDown} style={sliderHandleStyle} ><DoubleRightOutlined /></div>\n\t\t\t\t\t<div className={styles.sliderRail}>\n\t\t\t\t\t\t<div className={styles.text}>向右滑动验证</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className={styles.sliderTrack} style={{width: ((offset.x) / 250 * 100 + \"%\"), borderRadius: (offset.x < 250) ? 'none' : '45px' }}></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n    );\n}\n\n```\n\n## 线上仓库\n\n[demo](https://codesandbox.io/s/polished-sun-grk5j?file=/src/App.js)\n\n## 这里记录一下在使用 react hook 的一些问题\n\n先谈谈 useCallback 这个函数吧\n\n### useCallback\n\nuseCallback 提供了两个参数，一个个回调函数，另一个是依赖数组。\n**当依赖数组不改变时，此时回调函数不改变，已达到缓存的效果，减少在re-render的时候重新生成函数**\n\n#### 案例1\n\n```jsx\n// Child.js\n\nconst Child = ({cb}) => {\n\treturn (\n\t\t<div>\n\t\t\t<button onClick={cb}>点击</div>\n\t\t</div>\n\t)\n}\n\n```\n\n```jsx\nconst App = () => {\n\t// 此时 当App 重新渲染的时候，会重新生成 memoClick\n\t// const memoClick = () => console.log(\"click\"); \n\n\t// 用了useCallback 后 无论App 是否重新渲染，传给 Child 的 memoClick 都是之前的引用\n\tconst memoClick = useCallback(() => console.log(\"click\"), [])\n\treturn (\n\t\t<div>\n\t\t\t<Child cb={cb} />\n\t\t</div>\n\t)\n}\n```\n\n#### 其他\n\n当useCallback 的依赖数组 在useCallback内设置变化会导致无限循环\n\n```jsx\nconst App = () => {\n\tconst [a, setA] = useState(1);\n\tconst memoClick = useCallback(() => {\n\t\tconsole.log(\"click\")\n\t\tsetA((state) => {\n\t\t\tconst after = state.a++;\n\t\t\treturn after\n\t\t})\n\t}, [a])\n\n\treturn (\n\t\t<div>\n\t\t\t<div>{a}</div>\n\t\t\t<Button onClick={memoClick}>点击</Button>\n\t\t</div>\n\t)\n}\n```\n\n然后我找了很多文章，应该只有这篇是讲的比较清晰的， [React Hooks(二): useCallback 之痛](https://zhuanlan.zhihu.com/p/98554943)\n\n## 后话\n\n验证码组件还没做好，但大体逻辑是这样\n\n\n","tags":["react"],"categories":["react"]},{"title":"二叉树的最大深度","url":"/2020/07/30/二叉树的最大深度/","content":"\n[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n## 题目描述\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n```html\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n## 分析\n\n* 题目用递归\n* 递归终止条件： 当当前树节点为空时，返回0\n* 要是根不为空，我们比较 左右节点，看左节点比较深还是右节点深\n\n\n## 代码\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(!root) {\n        return 0\n    } \n\n    return (1 + Math.max( maxDepth(root.left), maxDepth(root.right) )) \n};\n```\n","tags":["algorithm-二叉树","algorithm-递归"]},{"title":"整数拆分","url":"/2020/07/30/整数拆分/","content":"\n[整数拆分力扣上](https://leetcode-cn.com/problems/integer-break/)\n\n\n## 题目描述\n\n给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。\n\n示例1: \n\n```html\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1。\n```\n\n示例2：\n\n```html\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n```\n\n## 思想\n\n* 2 => 1 + 1 \n* 3 => 2 + 1\n* 4 => 2 + 2\n* 5 => 2 + 3\n* 6 => 3 + 3\n* 7 => 3 + 4\n* 8 => 3 + 3 + 2\n* 9 => 3 + 3 + 3\n* 10 => 3 + 3 + 2 + 2\n\n\n观察 10 跟 8, 还有 7 的关系， 观察9 跟 7 还有 6 的关系, 我这里直接用dp表示\n* `dp[10] = max(dp[8] * 2, dp[7] * 3)`,  =>  `max(3 * 3 * 3 * 2, 3 * 4 * 3)`\n* `dp[9] = max(dp[7] * 2, dp[6] * 3)`,   =>  `max(3 * 4 * 2, 3 * 3 * 3)`\n\n**注意：**但你会发现 从dp[6] 往上就不符合上面的方法了，\n* ~~dp[6] = max(dp[4] * 2, dp[3] * 3)~~\n\n所以我直接做了暴力破解！直接赋值\n\n\n\n## 代码\n\n```js\n/**\n * @param {number} n\n * @return {number}\n */\nvar integerBreak = function(n) {\n    let dp = Array(n + 1).fill(1);\n    dp[3] = 2;\n    dp[4] = 4;\n    dp[5] = 6\n    dp[6] = 9\n\n    for(let i = 7; i <= n; i++) {\n        dp[i] = Math.max(dp[i - 3] * 3, dp[i - 2] * 2);\n    }\n\n    return dp[n]\n\n};\n```\n\n## 官方题解\n\n`dp[i]=max(2×(i−2),2×dp[i−2],3×(i−3),3×dp[i−3])`\n\n```c++\nclass Solution {\npublic:\n    int integerBreak(int n) {\n        if (n < 4) {\n            return n - 1;\n        }\n        vector <int> dp(n + 1);\n        dp[2] = 1;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = max(max(2 * (i - 2), 2 * dp[i - 2]), max(3 * (i - 3), 3 * dp[i - 3]));\n        }\n        return dp[n];\n    }\n};\n\n```","tags":["algorithm-动态规划"]},{"title":"xlsx 读取写入excel","url":"/2020/07/27/xlsx-读取写入excel/","content":"\n## js-xlsx\n\n`npm install xlsx --save`\n\n[文档地址](https://github.com/SheetJS/sheetjs)\n\n## 读取\n\n这里记录一下最经常用的方法，到时候复杂处理再记录\n\n### 以nodejs 的方式\n\n```js\n// nodejs 方式读取文件\nconst filePath = './test.xlsx';\nconst ws = xlsx.readFile(filePath, { type: 'binary'}); // 传文件路径读取文件\nconst sheet = ws.Sheets[\"Sheet1\"]; // 指定工作表\nconst data = xlsx.utils.sheet_to_json(sheet, {header:1}); // 对工作表的内容进行json 转化\nconst header = data.slice(0, 1); // 第一行就是我们的header\nconst body = data.slice(1); // 数据body\n```\n\n### browser 方式，上传文件的形式读取excel\n\n```html\n<input type=\"file\"  @change=\"fileChange\" />\n```\n\n```js\nfunction fileChange(e) {\n    var files = e.target.files;\n    console.log(files)\n    var fileReader = new FileReader();\n    fileReader.readAsBinaryString(files[0]);\n\n    fileReader.onload = (ev) => {\n        // 读取上传的文件，后面的跟上面类似\n        const file = ev.target.result; \n        const wb = xlsx.read(file, { type: 'binary' }); \n        const sheet = wb.Sheets[\"Sheet1\"];\n        const data = xlsx.utils.sheet_to_json(sheet, {header:1});\n    };\n\n},\n```\n\n### 写 Excel\n\n\n### nodejs 方式直接导出excel\n```jsx\n/**\n * @params dataSource 简单的数据结构\n * @params excelName  表名\n */ \n\ntype source {\n    name: string,\n    address: string,\n    phone: number\n}\n\nfunction json2Excel(dataSource: source, excelName: string) {\n    let wb = xlsx.utils.book_new()\n    let ws = xlsx.utils.aoa_to_sheet(dataSource); // 将简单的数据对象写到工作表里\n    xlsx.utils.book_append_sheet(wb, ws, \"SheetJS\")\n    xlsx.writeFile(wb, `${excelName}.xlsx`);\n}\n```\n\n### 创建a 链接方式导出excel\n\n[参考](https://blog.csdn.net/tian_i/article/details/84327329)\n\n\n[其他链接参考](https://www.cnblogs.com/liuxianan/p/js-excel.html)","tags":["js-xlsx"],"categories":["js-xlsx"]},{"title":"除数博弈","url":"/2020/07/24/除数博弈/","content":"\n[除数博弈](https://leetcode-cn.com/problems/divisor-game/)\n\n## 题目描述\n\n爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。\n\n最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：\n\n选出任一 x，满足 0 < x < N 且 N % x == 0 。\n用 N - x 替换黑板上的数字 N 。\n如果玩家无法执行这些操作，就会输掉游戏。\n\n只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。\n\n示例1： \n\n```\n输入：2\n输出：true\n解释：爱丽丝选择 1，鲍勃无法进行操作。\n```\n\n示例2：\n\n```\n输入：3\n输出：false\n解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。\n```\n\n## 思想\n\n* 题目要求能整除那么被除数 一定是 1，2，3，5 这几个数，所以我们只要关注dp[i-1], dp[i-2]和dp[i-3]还有dp[i-5]的值即可\n* 另外题目也说 0 < x < N 所以 i 一定要大于 2, 或者3，或者 5\n* 另外 假设 i = 4时， 可以整除2，所以可以关注dp[2]的值，和dp[3]的值，\n  * 如果我们关注dp[3]的话，也就是我先手，先取1，他取1，我再取1，他无法操作，我赢\n  * 如果我们关注dp[2]的话，也就是我先手，我先取2， 他取1，我无法操作，我输，\n  * **总结：** 总体来说是赢的，但dp[4] 要取与dp[2]， dp[3]相反的值.\n\n## 代码\n\n\n```js\nvar divisorGame = function(N) {\n    // 这既是一个博弈游戏，类似捡石子\n    let dp = Array(N + 1).fill(false);\n    dp[0] = false;\n    dp[1] = false;\n    dp[2] = true;\n\n    for(let i = 3; i < N + 1; i++) {\n        // 1, 2, 3, 5\n        dp[i] = (i > 5 && i % 5 == 0 && !dp[i - 5]) || \n                (i > 2 && i % 2 == 0 && !dp[i - 2]) || \n                (i > 3 && i % 3 == 0 && !dp[i - 3]) || \n                (!dp[i - 1]);\n    }\n    console.log(dp);\n    return dp[N];\n};\n```\n\n## 官方解答\n\n看了官方解答，我真的是吐了，就一样代码\n\n```js\nvar divisorGame = function(N) {\n    return N % 2 == 0;\n};\n```","tags":["algorithm-动态规划"]},{"title":"expo 极光推送","url":"/2020/07/23/expo 极光推送/","content":"\n## 这里记录一下在用expo 接入极光推送时的坑\n\n**貌似极光推送不能在ios模拟器中显示，推送的预估人数一直为0**\n\n**注意：因为expo不支持第三方sdk, 即不支持react-native link 这种方式，所以需要expo eject的方式使用Bare workflow**\n\n这里我使用的是[jpush-react-native](https://github.com/jpush/jpush-react-native) 极光官方维护的sdk\n\n1. `yarn add jpush-react-native`\n2. `yarn add jcore-react-native`\n3. `expo eject`\n4. 在`eject`的时候建立包名， 我这里ios/react 都一样`com.notice.test`\n5. eject 之后我们可以在项目得到原始的`react-native`包, 即包含了`ios` 以及`android` 两个包\n6. 这里官方文档写的不好，我们直接使用pod 自动引入的方式， issues 有人提到如果两种方式一起引用的话会报错\n7. `cd ios && pod deintegrate`\n8. `pod install`\n\n**ios需要进行证书设置**, 这里直接看[官方指南](https://docs.jiguang.cn/jpush/client/iOS/ios_cer_guide/)就可以了\n\n接下来就是修改 `AppDelegate.m`， 用xcode 打开ios目录下的`.xcworkspace`文件， 展开项目名`notice`即可看到`AppDelegate.m`, 以下可以参考[官方例子](https://github.com/jpush/jpush-react-native/blob/master/example/ios/example/AppDelegate.m)\n\n在头部加入\n```tsx\n#import <RCTJPushModule.h>\n#ifdef NSFoundationVersionNumber_iOS_9_x_Max\n#import <UserNotifications/UserNotifications.h>\n#endif\n```\n\n在`didFinishLaunchingWithOptions` 方法加入, 同时修改`appKey`\n\n```tsx\n // JPush初始化配置\n  [JPUSHService setupWithOption:launchOptions appKey:@\"57012733695b98e936ada5b0\"\n                        channel:@\"default\" apsForProduction:YES];\n  // APNS\n  JPUSHRegisterEntity * entity = [[JPUSHRegisterEntity alloc] init];\n  if (@available(iOS 12.0, *)) {\n    entity.types = JPAuthorizationOptionAlert|JPAuthorizationOptionBadge|JPAuthorizationOptionSound|JPAuthorizationOptionProvidesAppNotificationSettings;\n  }\n  [JPUSHService registerForRemoteNotificationConfig:entity delegate:self];\n  [launchOptions objectForKey: UIApplicationLaunchOptionsRemoteNotificationKey];\n  // 自定义消息\n  NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter];\n  [defaultCenter addObserver:self selector:@selector(networkDidReceiveMessage:) name:kJPFNetworkDidReceiveMessageNotification object:nil];\n  // 地理围栏\n  [JPUSHService registerLbsGeofenceDelegate:self withLaunchOptions:launchOptions];\n```\n\n在最后加入\n\n```tsx\n//************************************************JPush start************************************************\n\n//注册 APNS 成功并上报 DeviceToken\n- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {\n  [JPUSHService registerDeviceToken:deviceToken];\n}\n\n//iOS 7 APNS\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:  (NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {\n  // iOS 10 以下 Required\n  NSLog(@\"iOS 7 APNS\");\n  [JPUSHService handleRemoteNotification:userInfo];\n  [[NSNotificationCenter defaultCenter] postNotificationName:J_APNS_NOTIFICATION_ARRIVED_EVENT object:userInfo];\n  completionHandler(UIBackgroundFetchResultNewData);\n}\n\n//iOS 10 前台收到消息\n- (void)jpushNotificationCenter:(UNUserNotificationCenter *)center  willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(NSInteger))completionHandler {\n  NSDictionary * userInfo = notification.request.content.userInfo;\n  if([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {\n    // Apns\n    NSLog(@\"iOS 10 APNS 前台收到消息\");\n    [JPUSHService handleRemoteNotification:userInfo];\n    [[NSNotificationCenter defaultCenter] postNotificationName:J_APNS_NOTIFICATION_ARRIVED_EVENT object:userInfo];\n  }\n  else {\n    // 本地通知 todo\n    NSLog(@\"iOS 10 本地通知 前台收到消息\");\n    [[NSNotificationCenter defaultCenter] postNotificationName:J_LOCAL_NOTIFICATION_ARRIVED_EVENT object:userInfo];\n  }\n  //需要执行这个方法，选择是否提醒用户，有 Badge、Sound、Alert 三种类型可以选择设置\n  completionHandler(UNNotificationPresentationOptionAlert);\n}\n\n//iOS 10 消息事件回调\n- (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler: (void (^)(void))completionHandler {\n  NSDictionary * userInfo = response.notification.request.content.userInfo;\n  if([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {\n    // Apns\n    NSLog(@\"iOS 10 APNS 消息事件回调\");\n    [JPUSHService handleRemoteNotification:userInfo];\n    // 保障应用被杀死状态下，用户点击推送消息，打开app后可以收到点击通知事件\n    [[RCTJPushEventQueue sharedInstance]._notificationQueue insertObject:userInfo atIndex:0];\n    [[NSNotificationCenter defaultCenter] postNotificationName:J_APNS_NOTIFICATION_OPENED_EVENT object:userInfo];\n  }\n  else {\n    // 本地通知\n    NSLog(@\"iOS 10 本地通知 消息事件回调\");\n    // 保障应用被杀死状态下，用户点击推送消息，打开app后可以收到点击通知事件\n    [[RCTJPushEventQueue sharedInstance]._localNotificationQueue insertObject:userInfo atIndex:0];\n    [[NSNotificationCenter defaultCenter] postNotificationName:J_LOCAL_NOTIFICATION_OPENED_EVENT object:userInfo];\n  }\n  // 系统要求执行这个方法\n  completionHandler();\n}\n\n//自定义消息\n- (void)networkDidReceiveMessage:(NSNotification *)notification {\n  NSDictionary * userInfo = [notification userInfo];\n  [[NSNotificationCenter defaultCenter] postNotificationName:J_CUSTOM_NOTIFICATION_EVENT object:userInfo];\n}\n\n//************************************************JPush end************************************************\n```\n\n## 后记\n\n这里可以建议封装一个简单的hook, 来给我们注册用\n\n\n\n## 运行\n\n* 用`usb`将`iphone`跟`mac` 链接\n* 这里有时候会遇到一个问题, 就是`iphone`跟mac一直连上又断开， 解决方法`sudo killall -STOP -c usbd`\n* 最后运行 `npx react-native run-ios --device \"Bill@iPhone\"`\n","tags":["react-native","expo"]},{"title":"最小路径和","url":"/2020/07/23/最小路径和/","content":"\n[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n这道题跟[三角形最小路径和](./三角形最小路径和.md)类似\n\n\n## 题目描述\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明：**每次只能向下或者向右移动一步。\n\n示例：\n\n``` html\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n```\n\n## 思想\n\n这是一道二维数组的动态规划题目， 左边表示输入， 右边表示dp 结果集\n* 第一行只能够向右走， 所以  `dp[i][j] = grid[i][j] + dp[i][j - 1];`\n* 第一列只能向下走，所以 `dp[i][j] = grid[i][j] + dp[i - 1][j]`\n* 其余符合 `dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1])`;\n\n<style>\n.minPathSum {\n    display: flex;\n    flex-direction: row;\n}\n.minPathSum-right {\n    margin-left: 10px\n}\n@media screen and (max-width: 800px) {\n    .minPathSum {\n        display: flex;\n        flex-direction: column;\n    }\n\n    .minPathSum-right {\n        margin-left: 0px\n    }\n}\n</style>w\n\n<div  class=\"minPathSum\">\n    <div class=\"left\">\n        <p>输入</p>\n        <table>\n            <thead>\n                <th>i / k</th>\n                <th>k = 0</th>\n                <th>k = 1</th>\n                <th>k = 2</th>\n            </thead>\n            <tbody>\n                <tr>\n                    <td>i = 0</td>\n                    <td>1</td>\n                    <td>3</td>\n                    <td>1</td>\n                </tr>\n                <tr>\n                    <td>i = 1</td>\n                    <td>1</td>\n                    <td>5</td>\n                    <td>1</td>\n                </tr>\n                <tr>\n                    <td>i = 2</td>\n                    <td>4</td>\n                    <td>2</td>\n                    <td>1</td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n    <div class=\"minPathSum-right\">\n        <p>dp结果集</p>\n        <table>\n            <thead>\n                <th>i / k</th>\n                <th>k = 0</th>\n                <th>k = 1</th>\n                <th>k = 2</th>\n            </thead>\n            <tbody>\n                <tr>\n                    <td>i = 0</td>\n                    <td>1</td>\n                    <td>4</td>\n                    <td>5</td>\n                </tr>\n                <tr>\n                    <td>i = 1</td>\n                    <td>2</td>\n                    <td>7 (上面dp值与左边dp值比较取最小 + grid)</td>\n                    <td>6</td>\n                </tr>\n                <tr>\n                    <td>i = 2</td>\n                    <td>6</td>\n                    <td>8</td>\n                    <td>7</td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n</div>\n\n## 代码\n\n```js\n/**\n * 二维数组的动态规划\n * 当前 dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);\n * 第一行只能够向右走， 所以  dp[i][j] = grid[i][j] + dp[i][j - 1];\n * 第一列只能向下走，所以 dp[i][j] = grid[i][j] + dp[i - 1][j]\n */\nvar minPathSum = function(grid) {\n    let rows = grid.length;\n    let columns = grid[0].length;\n    let dp = [];\n    \n    for(let i = 0; i < rows; i++) {\n        let temp = [];\n        for(let j = 0; j < columns; j++) {\n            if(i == 0 && j == 0) {\n                temp.push(grid[i][j]);\n            } else if(j == 0) {\n                temp.push(grid[i][j] + dp[i - 1][j]);\n            } else if(i == 0) {\n                temp.push(grid[i][j] + temp[j - 1])\n            } else {\n                temp.push(grid[i][j] + Math.min(dp[i - 1][j], temp[j - 1]))\n            }\n\n        }\n        dp.push(temp);\n    }\n    return dp[rows - 1][columns - 1]\n};\n```\n\n\n","tags":["algorithm-动态规划"]},{"title":"React源码 调度","url":"/2020/07/21/React-调度/","content":"\n继上一遍[React源码-ReactDom](../React源码-ReactDom) 我们查看了ReactDom 的render所构成的整个fiber 结构\n\n我们重新看 `legacyRenderSubtreeIntoContainer`, 我们构建完fiber之后往下走\n\n```jsx\nfunction legacyRenderSubtreeIntoContainer(\n    parentComponent: ?React$Component<any, any>,\n    children: ReactNodeList,\n    container: DOMContainer,\n    forceHydrate: boolean,\n    callback: ?Function,\n) {\n  // 一开始进来 container 上是肯定没有这个属性的\n  let root: Root = (container._reactRootContainer: any);\n  // 没有 root 会执行 if 中的操作\n  if (!root) {\n    // Initial mount\n    // 创建一个 root 出来，类型是 ReactRoot\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    // ... 这里直接省略callback, 因为我们不关注callback\n  \n    unbatchedUpdates(() => {\n      // 大多数情况parentComponent 为null, 一遍不考虑，我们直接看else\n      if (parentComponent != null) {\n        root.legacy_renderSubtreeIntoContainer(\n          parentComponent,\n          children,\n          callback,\n        );\n      } else {\n        // 调用的是 ReactRoot.prototype.render，我们直接看这里\n        root.render(children, callback);\n      }\n    });\n  } else {\n    // ... 这里直接省略callback, 因为我们不关注callback\n    \n    // Update\n    if (parentComponent != null) {\n        root.legacy_renderSubtreeIntoContainer(\n            parentComponent,\n            children,\n            callback,\n        );\n    } else {\n      root.render(children, callback);\n    }\n  }\n  return getPublicRootInstance(root._internalRoot);\n}\n```\n\n## React.prototype.render \n\n```jsx\nReactRoot.prototype.render = function(\n  children: ReactNodeList,\n  callback: ?() => mixed,\n): Work {\n  // 这里指 FiberRoot\n  const root = this._internalRoot;\n  // ReactWork 的功能就是为了在组件渲染或更新后把所有传入\n  // ReactDom.render 中的回调函数全部执行一遍\n  // 我们这里callback 为null, 所以其实不用考虑这个\n  const work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  // 如果有 callback，就 push 进 work 中的数组\n  if (callback !== null) {\n    work.then(callback);\n  }\n  // work._onCommit 就是用于执行所有回调函数的\n  updateContainer(children, root, null, work._onCommit);\n  return work;\n};\n```\n\n### updateContainer\n\n```jsx\n// packages\\react-reconciler\\src\\ReactFiberReconciler.js\nexport function updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n): ExpirationTime {\n  // 取出容器的 fiber 对象.\n  const current = container.current;\n  // 计算时间\n  const currentTime = requestCurrentTime();\n  // expirationTime 代表优先级，数字越大优先级越高\n  // sync 的数字是最大的，所以优先级也是最高的\n  const expirationTime = computeExpirationForFiber(currentTime, current);\n  return updateContainerAtExpirationTime(\n    element,\n    container,\n    parentComponent,\n    expirationTime,\n    callback,\n  );\n}\n```\n\n### requestCurrentTime\n\n`packages\\shared\\ReactFeatureFlags.js` 的 enableNewScheduler = false; 所以使用的是`packages\\react-reconciler\\src\\ReactFiberScheduler.old.js`\n\n```jsx\nlet originalStartTimeMs: number = now();\nlet currentRendererTime: ExpirationTime = msToExpirationTime(\n  originalStartTimeMs,\n);\nlet currentSchedulerTime: ExpirationTime = currentRendererTime;\n// \n```\n承接下面的`currentSchedulerTime` 和 `currentRendererTime` \n\n```jsx\nfunction requestCurrentTime() {\n  // 调度程序调用requestCurrentTime来计算到期时间。\n\n  // 过期时间是通过将当前时间（开始时间）加起来得出的时间。\n  // 但是，如果在同一事件中安排了两次更新，即使实际时钟时间在第一次和第二次呼叫之间提前了，我们也应将它们的开始时间视为同时发生。\n  \n  // 换句话说，由于到期时间决定了更新的批处理方式，因此我们希望在同一事件中发生的所有优先级相同的更新都收到相同的到期时间。。\n   \n  // 我们跟踪两个不同的时间：当前的“渲染器”时间和当前的“调度器”时间。 渲染器时间可以随时更新。 它只是为了最大程度地降低通话性能。\n  \n  // 但是，只有在没有待处理的工作，或者确定我们不在某个事件的中间时，才能更新调度程序时间。\n  if (isRendering) {\n    // 此时在渲染中，直接返回当前作态\n    return currentSchedulerTime;\n  }\n  // Check if there's pending work.\n  findHighestPriorityRoot();\n  if (\n    nextFlushedExpirationTime === NoWork ||\n    nextFlushedExpirationTime === Never\n  ) {\n    // 如果没有待处理的工作，那么返回当前的渲染时间\n    recomputeCurrentRendererTime(); // 此函数 直接修改了currentRendererTime\n    currentSchedulerTime = currentRendererTime;\n    return currentSchedulerTime;\n  }\n  // 有待处理的时间时, 返回上一次的计时器时间\n  return currentSchedulerTime;\n}\n```\n\n### recomputeCurrentRendererTime\n```js\nfunction recomputeCurrentRendererTime() {\n  const currentTimeMs = now() - originalStartTimeMs;\n  currentRendererTime = msToExpirationTime(currentTimeMs);\n}\n```\n\n\n## 过期时间计算\n\n* 先来看看的当前计算过期时间的公式吧 \n\n```jsx\n// packages\\react-reconciler\\src\\ReactFiberExpirationTime.js\nexport const NoWork = 0;\nexport const Never = 1;\nexport const Sync = MAX_SIGNED_31_BIT_INT; // 1073741823\n\nconst UNIT_SIZE = 10;\nconst MAGIC_NUMBER_OFFSET = MAX_SIGNED_31_BIT_INT - 1;\n\n// ((ms / 10) | 0) 表示的是取整  2.5 | 0 = 2\n// ms时间戳 到 expireationTime 的转换， 数值越大优先级越高\nexport function msToExpirationTime(ms: number): ExpirationTime {\n  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);\n}\n\nexport function expirationTimeToMs(expirationTime: ExpirationTime): number {\n  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;\n}\n\n// 我们可以简单看成 num + 1 * precision， 也就是在一个precision 的范围内 \nfunction ceiling(num: number, precision: number): number {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\n//为了计算在某个bucket精度内的expirationTime，输入不同的expirationInMs,bucketSizeMs参数可以定义不同优先级的expirationTime\nfunction computeExpirationBucket(\n  currentTime,\n  expirationInMs,\n  bucketSizeMs,\n): ExpirationTime {\n  return (\n    MAGIC_NUMBER_OFFSET -\n    ceiling(\n      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE,\n    )\n  );\n}\n\n\nexport const LOW_PRIORITY_EXPIRATION = 5000;\nexport const LOW_PRIORITY_BATCH_SIZE = 250;\n\n// 计算异步事件过期时间，异步事件的优先级比较低\nexport function computeAsyncExpiration(\n  currentTime: ExpirationTime,\n): ExpirationTime {\n  return computeExpirationBucket(\n    currentTime,\n    LOW_PRIORITY_EXPIRATION,\n    LOW_PRIORITY_BATCH_SIZE,\n  );\n}\n\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\n\n// 计算交互事件过期时间，用户交互事件的优先级比较高\nexport function computeInteractiveExpiration(currentTime: ExpirationTime) {\n  return computeExpirationBucket(\n    currentTime,\n    HIGH_PRIORITY_EXPIRATION,\n    HIGH_PRIORITY_BATCH_SIZE,\n  );\n}\n\n// 根据过期时间获取当前优先级， 立即执行，还是普通优先级还是用户交互优先级\nexport function inferPriorityFromExpirationTime(\n  currentTime: ExpirationTime,\n  expirationTime: ExpirationTime,\n): ReactPriorityLevel {\n  if (expirationTime === Sync) {\n    return ImmediatePriority;\n  }\n  if (expirationTime === Never) {\n    return IdlePriority;\n  }\n  const msUntil =\n    msToExpirationTime(expirationTime) - msToExpirationTime(currentTime);\n  if (msUntil <= 0) {\n    return ImmediatePriority;\n  }\n  if (msUntil <= HIGH_PRIORITY_EXPIRATION) {\n    return UserBlockingPriority;\n  }\n  if (msUntil <= LOW_PRIORITY_EXPIRATION) {\n    return NormalPriority;\n  }\n  return IdlePriority;\n}\n\n\n```\n\n## computeExpirationForFiber\n\n我们再回到 `updateContainer` 继续执行到 `computeExpirationForFiber` 传的参数是**当前时间**还有`fiber`\n\n```jsx\nfunction computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) {\n  let expirationTime;\n  // 一开始 expirationContext = Nowork\n  if (expirationContext !== NoWork) {\n    expirationTime = expirationContext;\n  } else if (isWorking) {\n    if (isCommitting) {\n      // 在提交阶段发生的更新应具有同步优先级\n      expirationTime = Sync;\n    } else {\n      // 更新阶段和渲染阶段的过期时间应该一样\n      expirationTime = nextRenderExpirationTime;\n    }\n  } else {\n    // 计算新的过期时间\n    if (fiber.mode & ConcurrentMode) {\n      if (isBatchingInteractiveUpdates) {\n        // 交互事件\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } else {\n        // 异步事件，计算新的过期时间\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n      // 如果我们正在渲染树，请不要在已经渲染的到期时间进行更新。\n      if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {\n        expirationTime -= 1;\n      }\n    } else {\n      // 同步时间\n      expirationTime = Sync;\n    }\n  }\n  if (isBatchingInteractiveUpdates) {\n    // 跟踪最短的未执行互式到期时间。\n    if (\n      lowestPriorityPendingInteractiveExpirationTime === NoWork ||\n      expirationTime < lowestPriorityPendingInteractiveExpirationTime\n    ) {\n      lowestPriorityPendingInteractiveExpirationTime = expirationTime;\n    }\n  }\n  return expirationTime;\n}\n\n```\n\n## updateContainerAtExpirationTime \n\n```js\nexport function updateContainerAtExpirationTime(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  expirationTime: ExpirationTime,\n  callback: ?Function,\n) {\n  // 一样是fiber\n  const current = container.current;\n  // 获取 context 并赋值，这里肯定取不到值得，因为 parentComponent 为 null\n  const context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  return scheduleRootUpdate(current, element, expirationTime, callback);\n}\n```\n\n### scheduleRootUpdate\n\n* 下面开始调度了\n\n```js\nfunction scheduleRootUpdate(\n  current: Fiber,\n  element: ReactNodeList,\n  expirationTime: ExpirationTime,\n  callback: ?Function,\n) {\n  // 创建一个 update，就是内部有几个属性的对象\n  const update = createUpdate(expirationTime);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n  // 我们的 callback 是null的所以直接不用考虑二楼\n  flushPassiveEffects();\n  // 把 update 入队，内部就是一些创建或者获取 queue（链表结构），然后给链表添加一个节点的操作\n  enqueueUpdate(current, update);\n  scheduleWork(current, expirationTime);\n\n  return expirationTime;\n}\n```","tags":["react","react源码系列"],"categories":["react","react源码系列"]},{"title":"React基础","url":"/2020/07/21/react基础/","content":"\n## React 创建组件的方式\n\n* React.creactClass (已弃用)\n* Class 的方式创建组件\n* 纯函数的方式创建组件，即我们常说的Function Component\n\n这里主要介绍Class 跟 Function Component 两种方式\n\n\n### Class\n\nclass 是有生命周期的概念的\n\n* 挂载的时候的生命周期： constructor ->  render -> componentDidMount \n* 更新时的生命周期： getDerivedStateFromProps -> shouldComponentUpdate ->  render -> componentDidUpdate\n\n\n```jsx\nimport React, { Component, PureComponent } from 'react';\nClass Home extends Component {\n     constructor(props) {\n        super(props);\n        this.state = {\n            count: 1\n        }\n    }\n\n    /**\n     * 一般我们这里会做数据请求\n     */\n    componentDidMount() {}\n\n    componentDidUpdate() {}\n\n    /**\n     * \n     * 这里一般我们会做一些优化， 比如减少重复渲染。\n     * 父组件的state修改的话，会引起子组件的重新render, 但是当前子组件并没有依赖这个state，就可以用这个函数判断了\n     * 要是优化的话 可以使用 PureComponent , 她会会我们的props 进行浅比较\n     * @return boolean\n     */\n    shouldComponentUpdate(nextProps, nextState) {}\n\n    /**\n     * 这个生命周期时组件准备卸载了\n     * 这里可以对一些定时器，订阅等等做取消  \n     */\n    componentWillUnmount() {}\n\n    /**\n     * 这个方法无论是props 更新或者state更新都会进入到这个静态函数\n     * 返回一个对象， 当前的对象就是state，\n     * 如果返回null，那不对state做任何操作\n     */\n    static getDerivedStateFromProps(nextProps, prevState) {}\n\n    add = () => {\n        // 要注意的是 这个setState 修改的state 并不是立刻修改的，\n        this.setState({\n            count: this.state.count + 1\n        })\n    }\n\n    render() {\n        return (\n            <>\n                <div>state: {this.state.count}</div>\n                <div onClick={this.add}>+</div>\n\n                <div>props: {this.props.value}</div>\n            </>\n        )\n    }\n}\n```\n\n**注意： 在class 组件下 只能够用setState 去修改state的数据**， 它不像vue 那样可以直接修改数据。\n\n#### setState\n\nsetState 有两个参数， 一般我们会这么写\n```jsx\n// 一般我们会这么写\nthis.setState({\n    str: '123'\n})\n\n// 但实际上callback 还有另一个参数, callback\nthis.setState({\n    str: '123'\n}, () => {\n    console.log(\"callback\")\n}}\n\n// 另外我们setState 也可以用方法\nthis.setState((prevState) => ({\n    count: prevState.count + 1\n}))\n\n```\n\n\n#### props\n\n`react` 的 props 跟 `vue` 的 props 的传递方式大致一样，也是从父组件传props\n\n```js\n<Home value=\"hello world\">\n```\n\n## 高级用法\n\n### HOC\n\nHOC 就是一个高阶组件， 简单说就是传入一个组件， 返回一个组件的函数。它可以做到以下几点\n\n* 劫持渲染\n* 劫持props\n\n\n```jsx\n// 比如一个简单的loading组件， 当你要为你已经写过的组件增加一个loading状态的时候，此时可以用HOC\nconst HOC = (Component) => {\n    return class extends Component {\n         render() {\n            const { loading, ...rest } = this.props;\n\n            if(!loading) return \"loading...\";\n            return <WrappedComponent {...rest} />\n        }\n    }\n}\n\n// 使用\nconst EnhanceHoc = HOC(Home);\n\n```\n\n### render Props\n\n用的比较多的一种方式是Mdoal 框 或者 Drawer ， 虽然有很多UI 框架帮我们封装好Modal框，但有时候还要写visible, 关闭方法等等，就有点烦，这时候就可以用render Props\n\n```jsx\nconst CustomModal = ({visible, cancel}) => {\n    return (\n        <Modal visible={visible} onCancel={cancel} >\n            Hello World\n        </Modal>\n    )\n}\n```\n\n```jsx\n// modalContainer实现\nclass ModalContainer extends Component {\n    state = {\n        visible: false\n    }\n\n    handleCancel = () => {\n        this.setState({\n            visible: false\n        })\n    }\n\n    show = () => {\n        this.setState({\n            visible: true\n        })\n    }\n\n    render() {\n        const { visible } = this.state;\n        const { children } = this.props;\n        return (\n            children({\n                visible: visible,\n                show: this.show,\n                cancel: this.handleCancel\n            })\n        )\n    }\n}\n```\n\n```js\n//使用\nclass App extends Component {\n    render() {\n        return (\n            <div>\n                <ModalContainer>\n                    ({visible, show, cancel}) => (\n                        <>\n                            <CustomModal visible={visible} cancel={cancel}></CustomModal>\n                            <Button type=\"primary\" onClick={show}>\n                                Click\n                            </Button>\n                        </>\n                    )\n                </ModalContainer>\n            </div>\n        )\n    }\n}\n```\n\n\n## react Hooks\n\n### useState\n\n简单说 类似class 组件上面的 this.setState\n\n```jsx\nconst Home = () => {\n    // useState 的参数可以是简单类型， 也可以是方法\n    const [count, setCount] = useState(0);\n    const [toggle, setToggle] = useState(false);\n    const increment = () => {\n        setCount(count++);\n    }\n    const handleToggle = () => {\n        // setToggled 参数也可以用function\n        // setToggle((prevState) => nextState);\n        setToggled(toggled => !toggled);\n    }\n\n    return (\n        <>\n            <button onClick={increment}></button>\n            <div>{count}</div>\n            <div onClick={handleToggle}>{toggle}</div>\n        </>\n    )\n}\n```\n\n### useEffect\n\n在Function  Component 中, 是没有 生命周期的概念的，那么请求数据的时候就用到了useEffect, \n但是useEffect 其实包含3个生命周期 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`\n**注意： 不能在 if/else 或者是for循环中使用useEffect**\n\n```jsx\nconst Home = () => {\n    const [loading, setLoading] = useState(false);\n   \n\n    /**\n     * useEffect 提供两个参数， 一个是回调函数， 一个是依赖数组，\n     * 当第二参数不填的时候， 一旦state变化的时候， 就会执行这个函数\n     * 当第二个参数为 [] 空数组时， 就等同于 class组件的 componentDidMount\n     * 当第二个参数为[loading]， 代表只有loading 发生变化是，回调函数才会执行\n    */\n\n    useEffect(() => {\n        // 函数执行\n       \n       return () => {}\n    }, [])\n\n    return (\n        <>\n            <button onClick={increment}></button>\n            <div>{count}</div>\n            <div onClick={handleToggle}>{toggle}</div>\n        </>\n    )\n}\n```\n\n### useCallBack\n\nuseCallback 简单来说就是对我们的方法，进行缓存，达到一个性能优化的效果\n用的最多场景的是从父组件传方法给子组件，这时就可以用useCallback 了\n\n子组件onChange调用了父组件的handleOnChange\n父组件handleOnChange内部会执行setText(e.target.value)引起父组件更新\n父组件更新会得到新的handleOnChange，传递给子组件，对于子组件来说接收到一个新的props\n子组件进行不必要更新\n\n\n```jsx\nconst Child = React.memo((props) => {\n  console.log(props);\n\n  return (\n    <div>\n      <input type=\"text\" onChange={props.onChange}/>\n    </div>\n  )\n})\n\nconst Parent = () => {\n  const [count, setCount] = useState(0)\n  const [text, setText] = useState('')\n\n  const handleOnChange = useCallback((e) => {\n    setText(e.target.value)\n  },[])\n\n  return (\n    <div>\n      <div>count: {count}</div>\n      <div>text: {text}</div>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n      <Child onChange={handleOnChange} />\n    </div>\n  )\n}\n```\n\n[demo](https://codesandbox.io/s/amazing-darkness-20tc3?file=/src/App.js:79-231)\n\n上面例子可以看到父组件虽然更新了，但子组件没有重新render\n\n但注意的是 有时候useCallback 也会有可能触发无限循环。 用ruseReducer（解决）\n\n\n### useMemo\n\n跟useCallback 差不多，但是useCallback 缓存函数， useMemo 缓存值， 有点像 `vue`的 `computed`\n\n### useRef\n\n是一个一直会变的对象，他有一个`.current` 属性，可以保存dom, 可以是方法，等等\n\n### useReducer\n\n这个其实跟redux 的reducer 有点相似，在定义的state之后，只能通过`dispatch` 触发对应的reducer事件（Actions）更新state\n简单理解 ：\n\n```html\n       state -> UI -> 用户触发事件 执行action \n         ^                 |\n         |                 |\n         ------------------\n```\n\n[看看官方的例子吧!](https://react.docschina.org/docs/hooks-reference.html#usereducer)\n\n\n### useContext\n\n```jsx\nimport React, { createContext, useContext, useState } from \"react\";\n\nconst MenuContext = createContext({\n  index: 0\n});\n\nexport default function App() {\n  return (\n    <div>\n      <Menu defaultIndex={0}>\n        <MenuItem index={0}>menu1</MenuItem>\n        <MenuItem index={1}>menu2</MenuItem>\n        <MenuItem index={2}> menu3</MenuItem>\n      </Menu>\n    </div>\n  );\n}\n\nconst Menu = (props) => {\n  const { defaultIndex, onSelect } = props;\n  const [currentActive, setActive] = useState(defaultIndex);\n  const handleClick = (index) => {\n    setActive(index);\n    if (onSelect) {\n      onSelect(index);\n    }\n  };\n  const Icontext = {\n    index: currentActive || 0,\n    onSelect: handleClick\n  };\n\n\n  return (\n    <ul>\n      <MenuContext.Provider value={Icontext}>\n        {props.children}\n      </MenuContext.Provider>\n    </ul>\n  );\n};\n\nconst MenuItem = (props) => {\n  const { children, index } = props;\n  const itemContext = useContext(MenuContext);\n  const handleClick = () => {\n    if (itemContext.onSelect) {\n      itemContext.onSelect(index);\n    }\n  };\n  return (\n    <li onClick={handleClick}>\n      {itemContext.index === index ? <a>active </a> : null}\n\n      {children}\n    </li>\n  );\n};\n\n```\n\n[测试一下](https://codesandbox.io/s/wandering-shape-szhw2?file=/src/App.js:0-1221)\n\n\n#### 进阶 自动配置index\n\n就是 `React.Children.map` ，以及`React.cloneElement`\n\n```jsx\nimport React, { createContext, useContext, useState } from \"react\";\n\nconst MenuContext = createContext({\n  index: 0\n});\n\nexport default function App() {\n  return (\n    <div>\n      <Menu defaultIndex={0}>\n        <MenuItem>menu1</MenuItem>\n        <MenuItem>menu2</MenuItem>\n        <MenuItem> menu3</MenuItem>\n      </Menu>\n    </div>\n  );\n}\n\nconst Menu = (props) => {\n  const { defaultIndex, onSelect } = props;\n  const [currentActive, setActive] = useState(defaultIndex);\n  const handleClick = (index) => {\n    setActive(index);\n    if (onSelect) {\n      onSelect(index);\n    }\n  };\n  const Icontext = {\n    index: currentActive || 0,\n    onSelect: handleClick\n  };\n\n  const childrenRender = () => {\n    return React.Children.map(props.children, (child, index) => {\n      if (child.type.displayName === \"MenuItem\") {\n        return React.cloneElement(child, { index: index });\n      }\n    });\n  };\n\n  return (\n    <ul>\n      <MenuContext.Provider value={Icontext}>\n        {childrenRender()}\n      </MenuContext.Provider>\n    </ul>\n  );\n};\n\nconst MenuItem = (props) => {\n  const { children, index } = props;\n  const itemContext = useContext(MenuContext);\n  const handleClick = () => {\n    if (itemContext.onSelect) {\n      itemContext.onSelect(index);\n    }\n  };\n  return (\n    <li onClick={handleClick}>\n      {itemContext.index === index ? <a>active </a> : null}\n\n      {children}\n    </li>\n  );\n};\n\nMenuItem.displayName = \"MenuItem\";\n\n```\n\n[测试一下](https://codesandbox.io/s/gallant-sky-hqgcq?file=/src/App.js);\n\n[hooks学习](https://usehooks.com/)\n\n## redux, mobx\n\n余着\n\n","tags":["react"],"categories":["react"]},{"title":"两数之和 II - 输入有序数组","url":"/2020/07/20/两数之和-II-输入有序数组/","content":"\n[两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)\n\n## 题目描述\n\n给定一个已按照**升序排列** 的有序数组，找到两个数使得它们相加之和等于目标数。\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。\n\n说明：\n* 返回的下标值（index1 和 index2）不是从零开始的。\n* 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n> 输入: numbers = [2, 7, 11, 15], target = 9\n> 输出: [1,2]\n> 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n\n\n## 代码\n\n```js\n/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(numbers, target) {\n    let start = 0;\n    let end = numbers.length - 1;\n\n    while(start < end) {\n        const temp = numbers[start] + numbers[end]\n        if(temp === target) {\n            return [start + 1, end + 1];\n        }\n        // 2 + 15 > 9  因为是有序的所以, 应该从 end 减小\n        if(temp > target) {\n            end--;\n        } else {\n            // 如果target  = 22,\n            // 2 + 15 < 22 那么应该从start 往后移动\n            start++\n        }\n    }\n    return [start + 1, end + 1]\n};\n```","tags":["algorithm-双指针"]},{"title":"删除链表的倒数第N个节点","url":"/2020/07/20/删除链表的倒数第N个节点/","content":"\n[删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n\n## 题目描述\n\n删除链表中倒数的第n个节点\n\n示例：\n\n> 给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n> 当删除了倒数第二个节点后，链表变为 1->2->3->5.\n\n\n## 分析\n\n* 先遍历一次获得链表长度length\n* 然后length - n 获取target, 当前target < 0 时， p->next = p->next->next\n\n## 源码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function(head, n) {\n    let root = new ListNode(\"head\");\n    root.next = head;\n\n    let getLengthsPointer = head;\n\n    let nums = 0;\n    while(getLengthsPointer) {\n        nums++;\n        getLengthsPointer = getLengthsPointer.next;\n    }\n\n    let pointer = root;\n    let target = nums - n;\n\n    while(pointer) {\n        target--;\n        if(target < 0) {\n            pointer.next =  pointer.next.next ? pointer.next.next : null;\n            break;\n        }\n        pointer = pointer.next\n    }\n    return root.next;\n};\n```\n\n## 进阶\n\n一次遍历, **思想：** 用双指针，第一个指针与第二个指针 相隔n, 当第一个指针到达结尾时，那么第二个指针也到了倒数第n个数的前一个了。\n我们用上面 1 -> 2 -> 3 -> 4 -> 5 走一遍， n 为2\n\n* first 指向 3 , second 指向 head， 同时向后移动\n* 当first 指向到 null的时候，second 走到了 3，此时可以将second.next 指向 second.next.next \n\n\n```js\nvar removeNthFromEnd = function(head, n) {\n    let root = new ListNode(\"head\");\n    root.next = head;\n\n    let first = root;\n    let second = root;\n  \n    for (let i = 1; i <= n + 1; i++) {\n        first = first.next;\n    }\n    \n    while (first != null) {\n        first = first.next;\n        second = second.next;\n    }\n    second.next = second.next.next;\n    return dummy.next;\n\n\n}\n```","tags":["algorithm-双指针","algorithm-链表"]},{"title":"搜索插入位置","url":"/2020/07/17/搜索插入位置/","content":"\n[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)\n\n\n## 题目描述\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例：\n\n> 输入: [1,3,5,6], 0\n> 输出: 0\n\n## 思想\n\n* 因为是有序的数组，所以我们可以使用二分法找到插入的位置\n\n## 代码\n\n```js\nvar searchInsert = function(nums, target) {\n    // 二分查找\n    let left = 0;\n    let right = nums.length - 1;\n    while(left < right) {\n        let m = Math.floor( (right + left) / 2 );\n        if(nums[m] == target) {\n            return m;\n        }\n        if(target < nums[m]) {\n            right = m - 1;\n        } else {\n            left = m + 1;\n        }\n    }\n    let mid = Math.floor((right + left) / 2);\n    mid = mid > 0 ? mid : 0; // 为了解决负数问题\n    // 最后我们已经知道了左边跟右边的边界了，然后我们用target 比对一下 nums[mid] 就知道是放在当前位置还是放在后面一个位置了\n    \n    return target > nums[mid] ? mid + 1 : mid ; \n};\n```\n\n","tags":["algorithm-二分法"]},{"title":"不同的二叉搜索树","url":"/2020/07/17/不同的二叉搜索树/","content":"\n[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)\n\n## 题目描述\n\n给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n```\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n  1         3     3      2      1\n   \\       /     /      / \\      \\\n    3     2     1      1   3      2\n   /     /       \\                 \\\n  2     1         2                 3\n```\n\n## 搜索二叉树\n\n**搜索二叉树：** 左节点比根节点要小， 根节点永远比右节点要小。 `左 < 根 < 右`\n\n## 思路\n\n> 我们以 n = 5 为例子, [1, 2, 3, 4, 5]\n\n* 当以3为根节点时， 根据左节点永远比根节点小， 那么左节点只能为 `[1,2]`, 右节点为 `[4, 5]`\n  * 当 [1,2] 为左节点时, 又分成了两种情况， 当1为根节点时，2 为右节点；当 2 为根节点时， 1为左节点\n  * 当 [4,5] 为右节点时，跟上面类似\n* 当以2 为根节点时，那么 左节点只有为 `[1]`, 右节点为 `[3,4,5]`\n  * `[3,4,5]` 又可以以 3 或 4 或 5 做为根节点分析\n     * 3 为根节点 的时候为两种\n     * 4 为根节点的时候有一种\n     * 5 为根节点的时候又两种\n\n所以你会发现节点有两个的时候 f(2) = 2; f(1) = 1, 左右节点相乘就可以得到总数了\n所以 \n`f(2) = f(0) * f(1) + f(1) * f(0)`\n`f(3) = f(0) * f(2) + f(1) * f(1) + f(2) * f(0)`\n`f[4] = f(0) * f(3) + f(1) * f(2) + f(2) * f(1) + f(3) * f(0)`\n\n## 代码\n\n```js\nvar numTrees = function(n) {\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (let i = 2; i <= n; ++i) {\n        for (let j = 1; j <= i; ++j) {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n    return dp[n];\n};\n\n```\n\n","tags":["algorithm-动态规划"]},{"title":"三角形最小路径和","url":"/2020/07/16/三角形最小路径和/","content":"\n[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)\n\n## 题目描述\n\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n**相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点**。我们用`triangle` 表示当前数组\n\n|  i\\k  | k = 0 | k = 1 | k = 2 | k = 3  |\n|:----: | :---: | :---: | :---: | :----: |\n| i = 0 | 2     |       |       |        |\n| i = 1 | 3     |  4    |       |        |\n| i = 2 | 6     |  5    |  7    |        |\n| i = 3 | 4     |  1    |  8    |   3    |\n\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n## 思路\n\n这道题用动态规划，我一开始的想法是用一位数组的动态规划，后来提交发现失败了， 一开始想的递推公式是 ` dp[i + 1] = d[i] + Math.min(triangle[i][j], triangle[i][j + 1])`\n后来发现是一个二维数组的动态规划\n\n* 二维数组动态规划, 用dp 表示结果集\n* 我们以 `i` 作为行, `k` 作为列， **注意题目的相邻节点**\n* 我们发现 当 `k = 0` 时, 那么他当前dp 值 应该是 `dp[i][k] = dp[i-1][k] + triangle[i][k]`, `dp[i][k]` 因为 `k = 0`, 它只能从上往下走\n* 我们看第三行即 `i = 2`时, 看 `k = 1`, `dp[i][k] = triangle[i][k] + Math.min(dp[i - 1][k], dp[i - 1][k - 1])`,  当  `0 < k < column`时\n  我们`dp[i][k]` 应该 是用`左上角的dp, 即dp[i - 1][k - 1]`跟`正上方的dp值，即dp[i - 1][k]`取最小值 加上`triangle[i][k] `\n* 同样是第三行即 `i = 2`时，看 `k = 2`, `dp[i][k] = triangle[i][k] + dp[i - 1][k - 1]`, 此时 只能斜着走 即 2 -> 4 -> 这样走\n\ndp 结果 \n\n|  i\\k  | k = 0 | k = 1 | k = 2 | k = 3  |\n|:----: | :---: | :---: | :---: | :----: |\n| i = 0 | 2     |       |       |        |\n| i = 1 | 5     |  6    |       |        |\n| i = 2 | 11    |  10（这里左上跟正上对比，取小的那个跟triangle相加）   |  13（这里只能斜着走，取6）   |        |\n| i = 3 | 15    |  11   |  18   |   16   |\n\n最后取最后一行的最小那个即可\n\n## 代码\n\n```js\nvar minimumTotal = function(triangle) {\n    // dp[i + 1] = d[i] + Math.min(triangle[i][j], triangle[i][j + 1])\n    let i = 0;\n    let dp = []\n    let row = triangle.length;\n    while(i < row) {\n        let column = triangle[i].length;  // 获取当前行的列数\n        let dpColumn = []\n        for(let k = 0; k < column; k++) {\n            if(k == 0) {  // 列 = 0 时只能向下走，\n                dpColumn.push(i == 0 ? triangle[i][k] : dp[i - 1][k] + triangle[i][k])\n            } else if(k < column - 1) { // 列是中间列的话，就从正上方 或者左上方\n                dpColumn.push(Math.min(dp[i - 1][k], dp[i - 1][k - 1]) + triangle[i][k]);\n            } else {\n                // 最后一列的时候只能够斜着走\n                dpColumn.push(dp[i - 1][k - 1] + triangle[i][k])\n            }\n        }\n        dp.push(dpColumn);\n        i++;\n    }\n    return Math.min.call(null, ...dp[i - 1]);\n};\n```","tags":["algorithm-动态规划"]},{"title":"两个数组的交集 II","url":"/2020/07/13/两个数组的交集-II/","content":"\n[两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)\n\n## 题目描述\n\n就是给两个数组，求出他们的交集。\n\n**说明：**\n\n* 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。\n* 我们可以不考虑输出结果的顺序。\n\n## 思路\n\n* 使用map 记录其中一个数组数值出现的次数。\n* 遍历另一个数组，判断当前数字是否在map中，是的话添加到结果集中，并且当前map[number] 的值减1， 不是的话，那代表不是交集\n\n```js\nvar intersect = function(nums1, nums2) {\n    let result = [];\n    let map = new Map();\n    for(let i = 0; i < nums1.length; i++) {\n        if(map.has(nums1[i])) {\n            map.set(nums1[i], map.get(nums1[i]) + 1)\n        } else {\n            map.set(nums1[i], 1)\n        }\n    }\n    for(let j = 0; j < nums2.length; j++ ) {\n        // 判断当前数字是否在map 中，并且当前map的值是否大于0， 大于0的意思是：map 中还有 没有取交集的数\n        if(map.has(nums2[j]) &&  map.get(nums2[j]) > 0 ) {\n            result.push(nums2[j]);\n            map.set(nums2[j], map.get(nums2[j]) - 1)\n        } \n    }\n    return result;\n};\n```\n\n## 进阶\n\n* 如果给定的数组已经排好序呢？你将如何优化你的算法？\n* 如果 nums1 的大小比 nums2 小很多，哪种方法更优？\n* 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n\n这里只给一个想法吧，既然数组已经排序好了， 那我们就使用双指针的方法去解决这个问题，一个数组一个指针，如果两个指针所指的数相等，那么两个指针向后移，不相等的话判断哪个数值比较大，小的那个向后移，如此类推\n","tags":["algorithm-map"]},{"title":"面试题 17.13. 恢复空格","url":"/2020/07/11/面试题-17-13-恢复空格/","content":"\n[面试题 17.13. 恢复空格](https://leetcode-cn.com/problems/re-space-lcci/)\n\n## 题目描述\n\n给定一个字典 dictionary 和 一串字符串sentence， 在这串字符串中尽可能多的从字典中找到相应的值，返回未识别的字符\n\n>输入：\n> dictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"]\n> sentence = \"jesslookedjustliketimherbrother\"\n> 输出： 7\n> 解释： 断句后为\"jess looked just like tim her brother\"，共7个未识别字符。\n\n\n## 解题思路\n\n* 一开始想的是 根据我们现实生活中这样查字典这样，比如 looked, 先翻到L如果字典有l 开头的那再找 o 如果没有那直接退出，这时候就要构建字典树\n\n\n* 我们直接遍历字符串`sentence`, 然后 跟字典里的那些 词对比一下，然后最小的那个就可以了\n\n我们以 `sentence = 'jelookedss'`, `dictionary = [\"looked\"]` 为例子\n\ndp: \n\n| i     |  0 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | \n|:-----:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| sentence  | j  | e  | l  | o  | o  | k  | e  | d  | s  | s  |    |\n| dp[]  | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 2  | 3  | 4  |\n\n\n请注意我们`dp[0] = 0` 所以dp[1] 对应的应该是 sentence[0], 就是**后移了一位**\n看上面的图，当我们i = 7 的时候 我们找到了looked，这是我们字典里的，所以我们dp[7+1] 的值应该是`dp[2]` => `dp[7 - 6 + 1]` 即 `sentence[1]` 的时候，因为前面的都是在字典中找不到的,\n**替代公式**： 要是找到的情况下 `dp[i + 1] = Math.min(dp[i + 1], dp[i - 字典词长度 + 1])`\n\n\n## 动态规划\n\n```jsx\nvar respace = function(dictionary, sentence) {\n    let dp = [0];\n    let length = sentence.length;\n\n    if(dictionary.length == 0) {\n        return length;\n    }\n\n    for(let i = 0; i < length; i++) {\n        dp[i + 1] = dp[i] + 1;\n\n        for(let j = 0; j < dictionary.length; j++ ) {\n            const l = dictionary[j].length\n            if(dictionary[j] == sentence.substring(i - l + 1 , i + 1 )) {\n                dp[i + 1] = Math.min(dp[i + 1], dp[i - l + 1] );\n            }\n        }\n    }\n\n    return dp[length];\n};\n\n```\n\n\n## 字典树\n\n```js\nvar respace = function(dictionary, sentence) {\n    let cache = []\n    for (let j = 0;j < sentence.length + 1;j ++) {\n        cache.push(new Map)\n    }\n    let dp = new Array(sentence.length+1).fill(0);\n    let trie = {};\n    let n = sentence.length;\n    if (sentence === \"\") return 0;\n\n    // 构建字典树\n    for(let word of dictionary) {\n        let node = trie;\n        for(let c of word) {\n            if (node[c] == undefined) {\n                node[c] = {}\n            }\n            node = node[c];\n        }\n        node[\"#\"] = \"#\";\n    }\n    // 预处理出字典中存在的所有下标区间 cache[j].get[k] == true 表示[k,j]区间的单词在字典中能找到。\n    // 我们寻找字典开头，要是选找到开头的话继续往下找字典，要是遇到 # 那么就结束了，对于每个字符都是都一样，最后记录当前位置字符到字典结束的长度\n    for(let i = 1; i <= n; i++) {\n        let node = trie;\n        for(let j = i; j <= n; j++) {\n            let c = sentence[j-1];\n            if (!node[c]) {\n                break;\n            }\n            node = node[c];\n            if (node['#'] != undefined) {\n                cache[j].set(i, true);\n            }\n        }\n    }\n    for (let j = 1;j <= n;j ++) {\n        dp[j] = dp[j-1] + 1;\n        for(let [k,v] of cache[j]){\n            dp[j] = Math.min(dp[j], dp[k-1])\n        }\n    } \n    return dp[n];\n};\n```","tags":["algorithm-动态规划"]},{"title":"Hexo自定义案例","url":"/2020/07/09/hexo自定义/","content":"\n我使用的主题是[chic](https://github.com/Siricee/hexo-theme-Chic)\n\n\n## 修改主题markdown的高亮代码\n\n我当前使用的主题是不支持`jsx`的，所以对于`react`代码不能友好支持。所以使用`hexo-prism-plugin`修改了高亮部分\n\n* `坑:` 我安装了 `hexo-prism-plugin` 之后发现还是无法高亮 `jsx` 代码， 后来发现还要要安装 `hexo-inject` 模块\n\n- `npm install hexo-prism-plugin hexo-inject --save`\n- 修改`_config.yml`\n\n```yml\nhighlight:\n  enable: false  # 关闭默认的highlight\n\nprism_plugin:\n  mode: 'preprocess'    # realtime/preprocess\n  theme: 'base16-ateliersulphurpool.light' # 主题\n  line_number: false    # default false\n  # custom_css: 'path/to/your/custom.css'  \n```\n\n## 为主题图片添加大图\n\n主题无法对图片进行放大，图片最大也只是 `780 * 562`, 体验上不是很好，这里我使用了fancybox 进行修改\n\n下载fancybox的文件\n\n* 将 `jquery.fancybox.min.js`, `jquery.min.js` 放入 `theme/chic/source/js` 目录下\n* 将 `jquery.fancybox.min.css` 放入 `theme/chic/source/css/_lib/`目录下\n* 修改 `chic/_config.yml`, 添加代码\n\n  ```yml\n  fancybox: \n    enable: true\n    jquery: /js/jquery.min.js\n    fancyjs: /js/jquery.fancybox.min.js\n  ```\n* 修改 `Chic/layout/_partial/head.ejs` 添加以下代码\n\n```js\n<% if(theme.fancybox.enable!==null&&theme.fancybox.enable===true){ %>\n    <script type=\"text/javascript\"  src=\"<%- url_for(theme.fancybox.jquery) %>\"></script>\n    <script type=\"text/javascript\"  src=\"<%- url_for(theme.fancybox.fancyjs) %>\"></script>\n<% } %>\n```\n\n* 在 `Chic/source/css/style.styl` 添加,\n\n```css\n@import \"_lib/jquery.fancybox.min.css\"\n```\n这里添加css 不知道为什么不可以直接 跟上面添加js 一样，我找了很久都没找到解决方案，只能够在style 下强行添加css\n\n* 最后在 `source/js/script.js` 的document.ready()的回调回调函数添加 以下代码就可以\n\n```js\n$(\"a.group\").fancybox({\n    'transitionIn'\t:\t'elastic',\n    'transitionOut'\t:\t'elastic',\n    'speedIn'\t\t:\t600, \n    'speedOut'\t\t:\t200, \n    'overlayShow'\t:\tfalse\n});\n```\n\n### 使用\n\n这里强行使用`<a class=\"group\">`链接 包裹这img 表示使用fancybox\n```html\n<a class=\"group\" rel=\"group1\" href=\"图片url\">\n    <img src=\"图片url\" />    \n</a>\n```\n\n\n## 添加力扣页面\n\n> 我这里是想自定义添加一个新的页面，主要放自己练习算法时的解题思路，叫力扣，但又不想跟原来发表的文章混在一起\n\n\n* 添加文件夹 `source/algorithm`, 只有一个文件`index.md`\n\n```md\n# index.md\n---\ntitle: 力扣\ndate: 2020-04-08 16:09:43\nlayout: algorithm\n---\n```\n\n* 在`Chic/layout` 添加 `algorithm.ejs`\n\n```js\n<%- partial('_page/algorithm', {pagination: config.archive, index: true}) %>\n```\n\n* 在`Chic/layout/_page` 添加 `algorithm.ejs`\n\n```js\n// Chic/layout/_page/algorithm.ejs\n<div class=\"post-wrap algorithm-page archive\">\n    <div class=\"tags-algorithm\">\n        // 这里就是算法 tag, 我只筛选出 tag包含 algorithm- 的那些\n        <%site.tags.forEach(item=>{%>\n            <% if(item.name.includes(\"algorithm-\")) { %>\n                <a class=\"tags-item\" href=\"<%-url_for(item.path)%>\"><%- item.name.split(\"algorithm-\")[1] %><span class=\"nums\"><%-item.length%></span></a>\n            <% } %>\n        <%})%>\n    </div>\n    <div class=\"archive\">\n        // 每页条数\n        <% var perPage = config.algorithm_generator.per_page %>\n        // 这里我直接获取当前页面是第几页，没有page的话就是第一页\n        <% var currentPage = url.match(/page\\/(.*)\\//) ? url.match(/page\\/(.*)\\//)[1] : 1 %>\n        <% var last_year = ''; %>\n        // 然后我过滤掉 只是type == 'algorithm'的那些文章， 这个type, 在我们新键文章的时候跟title，tag那些写在一起\n        <% var posts = site.posts.filter((item) => item.type && item.type == 'algorithm') %>\n        // 做一个排序, 按最新的排\n        <% posts.data = posts.data.sort((a, b) => b.date - a.date) %>\n        // 选择当前页面的文章\n        <% posts.slice((currentPage - 1) * perPage, currentPage * perPage ).each(function (post) { %>\n                <% var cur_year = post.date.year(); %>\n                <% if(last_year !== cur_year){ %>\n                    <h3><%- cur_year %></h3>\n                <% last_year = cur_year; } %>\n                <article class=\"archive-item\">\n                    <a class=\"archive-item-link\" href=\"<%- url_for(post.path) %>\"><%= post.title %></a>\n                    <span class=\"archive-item-date\"><%- date(post.date, theme.date_format) %></span>\n                </article>\n        <% }) %>\n        // 分页\n        <% if(Math.ceil(posts.length /  perPage) > 1) { %>\n        <nav class=\"pagination\">\n            <%- paginator({\n                prev_next: false,\n                end_size: 1,\n                mid_size: 2,\n                total: Math.ceil(posts.length /  perPage)\n            }) %>\n        </nav>\n        <% } %>\n    </div>\n</div>\n```\n这里有个坑，我们点击 `/algorithm/page/2` 的时候会报当前页面存在，我通过 `hexo-generator-category` 找到类似的解决方案，\n我通过文档的[生成器](https://hexo.io/zh-cn/api/generator.html#%E5%BD%92%E6%A1%A3%E9%A1%B5%E9%9D%A2)写了一个类似的解决方案\n\n\n* 在 `Chic/script` 下添加 `algorithm.js`, 这里为了搞一个分页出来而已\n\n```js\nvar pagination = require('hexo-pagination'); // 要安装模块啊\nhexo.extend.generator.register('algorithm', function(locals){\n    // 这里不能对locals.post 进行更改，一旦发生更改，网站变量 site.posts 的内容也会跟着更改，这里不知道是为什么，我纠结了很久\n    let allPost = locals.posts; \n   \n    return pagination('/algorithm', allPost, {\n        perPage: this.config.algorithm_generator.per_page, // 在 _config.yml 添加 algorithm_generator: 配置 类似 category_generator\n        layout: ['algorithm', 'archive', 'index'], // 如果algorith这个layout,没有就会用 archive， 如此类推\n        format: 'page' + '/%d/',\n        data: {\n            __index: true\n        }\n    });\n\n});\n\n```\n\n* 最后只要修改一下 `Chic/layout/_page/archive.ejs` 文件跟上面类似第三部就行了, 这里说一下 config ,可以从最外层 `_config.yml`进行配置\n\n## 文章搜索\n\n\n* 先执行 `npm install hexo-generator-search -s`, 这个插件是为了生成`search.json`, 他包含的是文章的基本信息\n* 然后就是写 html 和 css了，我这里使用的是模态框，所以可以根据form 表单提交后唤出modal,然后进行ajax对search.json进行查询.\n* 我们根据关键字对文章content进行匹配，匹配有的加入数组，然后对匹配成功的那些数据进行字符截取，另外对关键字做highlight操作\n\n\n### 配置 _config.yml\n这里需要配置一下 root 下的 `_config.yml`, 添加以下代码\n\n```yml\n# search\nsearch:\n  enable: true\n  path: search.json\n  field: post\n  content: true\n```\n\n\n### 添加modal\n\n我这里直接写在了`Chic/layout/layout.ejs`, 我们只需要控制这个`modal`的`display`属性就好了\n\n#### html\n\n```html\n<!-- Chic/layout.ejs -->\n <div id=\"u-search\">\n        <div class=\"modal\">\n            <div class=\"modal-header\">\n                <div class=\"container\">\n                    <form id=\"u-search-modal-form\" class=\"u-search-modal-form\">\n                        <button type=\"submit\" class=\"form-submit-btn\">\n                            <img src=\"<%- url_for(theme.searchImg) %>\" class=\"search-btn-img\" />\n                        </button>\n                        <input placeholder=\"搜索文章。。。\" class=\"form-input\" id=\"modal-form-input\">\n                    </form>\n                    <a class=\"modal-close\">x</a>\n                </div>\n                <div class=\"search-loading\">\n                    <div class=\"search-loading-bar\"></div>\n                </div>\n            </div>\n            <div class=\"modal-body\">\n                <!-- ul 格式如下 -->\n                <!-- <ul class=\"modal-results\">\n                    <li class=\"result-item\">\n                        <a class=\"result-item-detail\">\n                            <span class=\"title\">页面配置</span>\n                            <span class=\"content\">\n                                content\n                            </span>\n                        </a>\n                    </li>\n                </ul> -->\n            </div>\n        </div>\n        <div class=\"modal-overlay\"></div>\n    </div>\n```\n\n#### modal 样式\n\n我把他放在了`Chic/source/css/_lib/search.css`\n\n这个要在 `Chic\\source\\css\\style.styl` 引用,添加代码 \n\n```css\n@import \"_lib/search.css\"\n```\n\n<details>\n<summary><mark>点击查看样式，这里是search.css 代码</mark></summary>\n\n```css\n    #u-search {\n        display: none;\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        padding: 60px 20px;\n        z-index: 1001;\n    }\n\n\n    #u-search .modal {\n        position: fixed;\n        height: 80%;\n        width: 100%;\n        max-width: 640px;\n        left: 50%;\n        top: 0;\n        margin: 64px 0px 0px -320px;\n        background: #fff;\n        z-index: 3;\n        border-radius: 4px;\n        overflow: hidden;\n    }\n\n    #u-search .modal-header {\n        position: relative;\n        width: 100%;\n        height: 64px;\n        z-index: 3;\n        border-top-left-radius: 4px;\n        border-top-right-radius: 4px;\n        font-size: 16px;\n        box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);\n        background: #fff;\n        transition: all 0.28s ease;\n        -moz-transition: all 0.28s ease;\n        -webkit-transition: all 0.28s ease;\n        -o-transition: all 0.28s ease;\n    }\n\n    #u-search .modal-header .container{\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n        padding: 0px;\n    }\n\n    #u-search .modal-header .container .u-search-modal-form {\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n        flex: 1;\n    }\n\n    #u-search .u-search-modal-form .form-submit-btn {\n        width: 50px;\n        height: 64px;\n        background: none;\n        border: none;\n        outline: none;\n        margin:  0 5px 0 5px ;\n    }\n\n    #u-search .u-search-modal-form .form-submit-btn img {\n        width: 33px;\n        height: 33px;\n    }\n\n    #u-search .modal-header .container .u-search-modal-form .form-input {\n        flex: 1;\n        margin-right: 15px;\n        border: none;\n        padding: 10px 10px;\n        outline: none;\n    }\n\n\n    #u-search .modal-header .modal-close {\n        display: block;\n        width: 55px;\n        height: 64px;\n        top: 0;\n        right: 0;\n        color: #2196f3;\n        cursor: pointer;\n        text-align: center;\n        line-height: 64px;\n        vertical-align: middle;\n        transition: all 0.28s ease;\n        -moz-transition: all 0.28s ease;\n        -webkit-transition: all 0.28s ease;\n        -o-transition: all 0.28s ease;\n        z-index: 2;\n        font-size: 22px;\n    }\n\n    #u-search .modal-header .search-loading {\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 100%;\n        height: 2px;\n        background: transparent;\n        z-index: 1;\n        \n    }\n\n    #u-search .modal-header .search-loading .search-loading-bar {\n        transition: all 0.28s ease;\n        -moz-transition: all 0.28s ease;\n        -webkit-transition: all 0.28s ease;\n        -o-transition: all 0.28s ease;\n        position: relative;\n        display: none;\n        width: 0%;\n        height: 100%;\n        background: #2196f3;\n    \n    }\n\n    #u-search .modal .modal-body {\n        padding: 15px;\n        height: calc(100% - 85px);\n        overflow: auto;\n\n    }\n\n    #u-search .modal .modal-body::-webkit-scrollbar{\n        width: 5px;\n        height: 5px;\n        /**/\n    }\n    #u-search .modal .modal-body::-webkit-scrollbar-track{\n        background: rgb(239, 239, 239);\n        border-radius:2px;\n    }\n    #u-search .modal .modal-body::-webkit-scrollbar-thumb{\n        background: #bfbfbf;\n        border-radius:10px;\n    }\n    #u-search .modal .modal-body::-webkit-scrollbar-thumb:hover{\n        background: #333;\n    }\n    #u-search .modal .modal-body::-webkit-scrollbar-corner{\n        background: #179a16;\n    }\n\n    #u-search .modal .modal-body .modal-results {\n        list-style: none;\n        padding-left: 0;\n        margin: 0px;\n    }\n\n    #u-search .modal .modal-body .modal-results .result-item {\n        padding: 15px;\n    }\n\n    #u-search .modal .modal-body .modal-results .result-item:hover {\n        background: #e8f4fd;\n    }\n\n    #u-search .modal .modal-body .modal-results .result-item .result-item-detail {\n        display: flex;\n        flex-direction: column;\n    }\n\n    #u-search .modal .modal-body .modal-results .result-item .result-item-detail .title {\n        color: #6e6e6e;\n        font-weight: 700;\n        font-size: 18px;\n        margin-bottom: 10px;\n    }\n\n    #u-search .modal .modal-body .modal-results .result-item .result-item-detail .content {\n        display: block;\n        white-space: inherit;\n        word-break: break-all;\n        text-overflow: ellipsis;\n        font-size: 14px;\n        color: rgba(85,85,85,0.65);\n        letter-spacing: 1px;\n        user-select: none;\n    }\n\n    #u-search .search-keyword {\n        color: #0c7cd5;\n        text-decoration: underline;\n        font-weight: bold;\n        font-style:normal\n    }\n\n    #u-search .modal-body .no-result {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n    }\n\n    #u-search .modal-overlay {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background: rgba(0,0,0,0.7);\n        z-index: 1;\n    }\n\n    @media screen and (max-width: 680px) {\n        #u-search {\n            padding: 0px;\n            display: none;\n        }\n\n        #u-search .modal {\n            box-shadow: none;\n            max-width: none;\n            top: 0;\n            left: 0;\n            margin: 0;\n            height: 100%;\n            border-radius: 0;\n        }\n        #u-search .modal-header {\n            border-radius: 0;\n            padding: 0px;\n        }\n    } \n\n    .modal-active {\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n    }\n\n    /* 以下是搜索框 */\n    .search {\n        margin-right: 6px;\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n    }\n        \n    .search .form-search {\n        padding: 10px 8px;\n    }\n            \n    .search .form-search .input {\n        display: block;\n        line-height: 1.3;\n        color: #555;\n        background: #e8e8e8;\n        padding: 5px 8px;\n        box-shadow: none;\n        box-sizing: border-box;\n        font-size: 1rem;\n        border-radius: 8px;\n        border: none;\n        outline: none;\n    }        \n            \n    .search .search-btn {\n        width: 22px;\n        height: 22px;\n        line-height: 22px;\n        margin-right: 5px;\n    }\n\n    .search .search-btn .search-btn-img {\n        height: 100%;\n        width: 100%;\n    }\n                \n\n    @media screen and (max-width: 479px) {\n\n        .navbar-mobile-right {\n            display: flex;\n            flex-direction: row;\n            align-items: center;\n        }\n            \n        .search .search-btn {\n            cursor: pointer;\n        }\n        \n        .search .form-search {\n            display: none;\n        }\n\n        .mobile-search {\n            position: absolute;\n            top: 0px;\n            left: 0px;\n            right: 50px;\n            padding-left: 15px;\n            background: #fff;\n            height: 80px;\n            display: flex;\n            flex-direction: row;\n            margin-right: 15px;\n        }\n\n        .mobile-search .form-search {\n            display: block; \n            flex: 1;\n        }\n\n        .mobile-search .input {\n            width: 100%;\n        } \n    }\n```\n   \n</details>\n\n### 增加搜索框\n\n我把该文件放在了 `Chic/layout/_partial/search.ejs`\n\n```jsx\n<% if(config.search && config.search.enable ) { %>\n    <div class=\"search \">\n        <div class=\"search-btn\" onClick=\"searchToggle()\">\n            <img src=\"<%- url_for(theme.searchImg) %>\" class=\"search-btn-img\" />\n        </div>\n        <form class=\"form-search\">\n            <input class=\"input\" placeholder=\"搜索文章\" autocomplete=\"off\" id=\"<%= name %>-search-input\"/>\n        </form>\n    </div>\n<% } %>\n\n```\n\n我们在 `Chic\\layout\\_partial\\header.ejs` 添加这个搜索框, 要在**pc的menu, 和mobile的menu**添加,\n\n```js\n<% var defaultName = 'pc' %>\n<%- partial('_partial/search', { name: defaultName }) %>\n\n// 这里是 mobile 的menu\n<div class=\"navbar-mobile-right\">\n    <% var type = 'mobile' %>\n    <%- partial('_partial/search', { name: type }) %>\n    <div class=\"menu-toggle\" onclick=\"mobileBtn()\">&#9776; 目录</div>\n</div>\n```\n\n### 添加搜索框的js, 搜索代码\n\n创建搜索代码\n\n<details>\n<summary><mark>点击查看代码</mark></summary>\n\n```jsx\n<script>\n    function searchToggle() {\n        const width = $(document.body).width()\n        if(width > 479) {\n            return;\n        }\n        const search = $('.search');\n        const searchForm = $('.form-search')\n\n        if(!search.hasClass(\"mobile-search\")) {\n            search.addClass(\"mobile-search\");\n        } else {\n            search.removeClass(\"mobile-search\");\n        } \n    }\n\n    function search(searchInputEl, formEl, flag) {\n        const path = \"<%= config.root %>\" + \"<%= config.search.path %>\"; // 可以在public 下查看这个search.json\n        $(formEl).submit(function(e){\n            e.preventDefault();\n            let target = null\n            if(searchInputEl == null) {\n                const screenWidth = $(document.body).width();\n                target = screenWidth > 479 ? $('#pc-search-input') : $('#mobile-search-input');\n                console.log(target);\n            } else {\n                target = $(searchInputEl)\n            }\n\n            if(!flag && target.val() === '') {\n                return ;\n            }\n\n            $(\"#u-search\").fadeIn(500, function() {\n                $(\"body > .wrapper\").addClass(\"modal-active\");\n\n                $.ajax({\n                    url: path,\n                    dataType: \"json\",\n                    beforeSend: function (xhr) {\n                        $input = target.val();\n                        $(\".form-input\").val($input);\n                        const loadingBar = $('.search-loading-bar') \n                        loadingBar.css({\n                            width:'100%',\n                            display: 'block'\n                        });\n                    },\n                    success: function( datas ) {\n                        // console.log(datas);\n                        const $resultPanel = $(\".modal-body\")[0];\n                        let str = `<ul class=\"modal-results\">`;\n                        var keywords = $(\".form-input\").val().trim().toLowerCase().split(/[\\s\\-]+/);\n                        $resultPanel.innerHTML = \"\";\n                        let hasResult = false\n                        let text = `<div class=\"no-result\">找不到与关键词相关的内容....</div>`;\n\n                        if ($(\".form-input\").val().trim().length <= 0) {\n                            // 没有结果\n                            $resultPanel.innerHTML = text;\n                            return;\n                        }\n                        datas.forEach(function (data) {\n                            var isMatch = true;\n                            if (!data.title || data.title.trim() === '') {\n                                data.title = \"Untitled\";\n                            }\n                            var data_title = data.title.trim().toLowerCase();\n                            var data_content = data.content.trim().replace(/<[^>]+>/g, \"\").toLowerCase();\n                            var data_url = data.url;\n                            var index_title = -1;\n                            var index_content = -1;\n                            var first_occur = -1;\n                            // only match artiles with not empty contents\n                            if (data_content !== '') {\n                                keywords.forEach(function (keyword, i) {\n                                    index_title = data_title.indexOf(keyword);\n                                    index_content = data_content.indexOf(keyword);\n\n                                    if (index_title < 0 && index_content < 0) {\n                                        isMatch = false;\n                                    } else {\n                                        hasResult = true\n                                        if (index_content < 0) {\n                                            index_content = 0;\n                                        }\n                                        if (i == 0) {\n                                            first_occur = index_content;\n                                        }\n                                    }\n                                });\n                            } else {\n                                isMatch = false;\n                            }\n                            // show search results\n                            if (isMatch) {\n                                str += `<li class='result-item'><a href='${data_url}' class='result-item-detail'> <span class=\"title\">${data_title}</span>`;\n                                var content = data.content.trim().replace(/<[^>]+>/g, \"\");\n                                if (first_occur >= 0) {\n                                    // cut out 200 characters\n                                    var start = first_occur - 40;\n                                    var end = first_occur + 160;\n\n                                    if (start < 0) {\n                                        start = 0;\n                                    }\n\n                                    if (start == 0) {\n                                        end = 200;\n                                    }\n\n                                    if (end > content.length) {\n                                        end = content.length;\n                                    }\n\n                                    var match_content = content.substring(start, end);\n\n                                    // highlight all keywords\n                                    keywords.forEach(function (keyword) {\n                                        var regS = new RegExp(keyword, \"gi\");\n                                        match_content = match_content.replace(regS, `<em class=\"search-keyword\">${keyword}</em>`);\n                                    });\n\n                                    str += `<span class=\"content\"> ${match_content} ...</span></a>`;\n                                }\n                                str += \"</li>\";\n                            }\n                        });\n                        str += \"</ul>\";\n                        if(hasResult) {\n                            $resultPanel.innerHTML = str;\n                        } else {\n                            $resultPanel.innerHTML = text;\n                        }\n\n                    },\n                    complete: function() {\n                        setTimeout(() => {\n                                const loadingBar = $('.search-loading-bar') \n                                loadingBar.css({\n                                    width:'0%',\n                                    display: 'none'\n                                });\n                        }, 300)\n                    }\n                });\n            })\n        \n        });\n    }\n    \n    $(document).ready(function() {\n        $('.modal-close').click(function () { \n            $(\"#u-search\").fadeOut();\n            $(\"body > .wrapper\").removeClass(\"modal-active\")\n        })\n\n        $('.modal-overlay').click(function() {\n            $(\"#u-search\").fadeOut();\n            $(\"body > .wrapper\").removeClass(\"modal-active\")\n        })\n        search(null, \".form-search\", false)\n        search(\"#u-search-modal-form .form-input\", \".u-search-modal-form\", true)\n    })\n</script>\n```\n</details>\n\n\n在 `themes\\Chic\\layout\\_partial\\head.ejs`中添加上面的以下代码，表示启动js\n\n```js\n<%# search %>\n\n<% if(config.search && config.search.enable ) { %>\n    <%- partial('_plugins/search.ejs') %>\n<% } %>\n\n```\n以上就是创建搜索框的全过程了，当然了我上面写的有点乱，可以自行整理一下\n\n\n\n\n","tags":["hexo"],"categories":["hexo"]},{"title":"路径总和","url":"/2020/07/07/路径总和/","content":"\n## 题目描述1\n\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n\n**说明: 叶子节点是指没有子节点的节点。**\n\n示例1\n\n```html\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n\n```\n\n> [5,4,8,11,null,13,4,7,2, null, null,null,1]\n> 22\n\n\n## 思想\n\n* **注意：**题目说了**叶子节点是没有子节点的节点**，那么我们只要判断一下当前节点有没有`root.left` 和 `root.right` 即可， 另外每次递归都减去当前`target = sum - root.val`, 然后递归左右子树就可以了\n\n## 递归实现\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {boolean}\n */\nvar hasPathSum = function(root, sum) {\n    if(root == null ) {\n        return false;\n    }\n\n    const value = root.val;\n    const target = sum - value;\n    if(target == 0 && (root.left == null && root.right == null)) {\n        return true;\n    }\n    return hasPathSum(root.left, target) || hasPathSum(root.right, target)\n\n};\n\n```","tags":["algorithm-二叉树","algorithm-递归"]},{"title":"63. 不同路径 II","url":"/2020/07/06/63-不同路径-II/","content":"\n[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)\n\n## 题目描述\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n<a class=\"group\" rel=\"group1\" href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png\">\n    <img style=\"margin-left: 0px\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png\" />\n</a>\n\n## 分析\n\n题目说明每次 **只能向下或者向右移动一步**。那么我们分析每次走到`a[m][n]` 只能从上面那个格子`a[m - 1][n]` 或者从左边那个格子`a[m][n - 1]`过来，我们定义 `a[m][n]`是到当前格子的有多少种路径数。 所以我们的递推公式是： `a[m][n] = a[m - 1][n] + a[m][n - 1]`;\n\n* **注意：** 第一行我们只能向右走， 第一列只能向下走。\n* 如果**上面**或者**左边**格子是障碍物， 那么当前格子应该是 0， 但其实也符合 `a[m][n] = a[m - 1][n] + a[m][n - 1]` 这个递推公式，这样我们判断格子是否是障碍物那么我们就设置为 0；\n\n\n## 代码\n\n```jsx\n/**\n * @param {number[][]} obstacleGrid\n * @return {number}\n */\nvar uniquePathsWithObstacles = function(obstacleGrid) {\n    let result = [];\n    let row = obstacleGrid.length;\n    let column = obstacleGrid[0].length\n    // 递推公式是 result[i][j] = result[i][j - 1] + result[i - 1][j]\n    for(let i = 0; i < row; i++) {\n        if(typeof result[i] == 'undefined') {\n            result[i] = [];\n        }\n        for(let j = 0; j < column; j++) {\n            let temp = obstacleGrid[i][j]\n            if(i === 0 && j === 0) {\n                result[i][j] = temp === 1 ? 0 : 1;\n            }\n            // 第一行只能向右走, 并且判断一下当前是不是障碍物，是的话那么走到当前路线的次数应该为0\n            if(i === 0 && j > 0) {\n                let tempLeft = obstacleGrid[i][j - 1];\n                result[i][j] = tempLeft || temp ? 0 : result[i][j - 1] ;\n            }\n\n            // 第一列只能向下走，并且判断一下当前是不是障碍物\n            if(j === 0 && i > 0) {\n                let tempUp = obstacleGrid[i - 1][j];\n                result[i][j] = (tempUp || temp ? 0 : result[i- 1][j]);\n            }\n\n            if(i > 0 && j > 0) {\n                const up = result[i - 1][j];\n                const left = result[i][j - 1];\n                result[i][j] = temp == 1 ? 0 : ( up + left);\n            }\n        }\n    }\n    return result[row - 1][column - 1]\n};\n```\n","tags":["algorithm-动态规划"]},{"title":"108. 将有序数组转换为二叉搜索树","url":"/2020/07/03/108-将有序数组转换为二叉搜索树/","content":"\n[108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)\n\n## 题目描述\n\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n示例：\n\n```html\n给定有序数组: [-10,-3,0,5,9],\n\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n\n       0\n     /   \\\n   -3     9\n   / \\    /\n -10  n  5\n\n```\n\n我们再来看一个示例\n\n示例2:\n\n```html\nnums = [1,2,3,4,5,6,7,8,9,10,11,12], length = 12\n\n             7\n           /   \\\n          4     10\n         /  \\    / \\\n        2    6   9  12\n       / \\  / \\  /\\  /\n      1  3 5  n 8  n 11\n```\n\n\n\n## 分析\n\n上面 n 代表的是null, 我们直接看**示例2**的根节点的排列情况\n\n* 7 的index 为 `Math.floor(nums.length / 2)`\n    * 4 的index 为 1~7的一半， 我们称为左半边的一半\n    * 10 的index 为 8~12的一半，我们称为右半边的一半\n\n所以我们总结上面获取根节点的情况是`nums[Math.floor(nums.length / 2)]`,然后反复获取左右半数组进行截取，再获取根节点，这里是一次递归\n\n* 当nums.length 为0 的时候，我们返回null\n* 根节点的左边数组为左子节点，右数组为右子节点\n\n我们模拟一下`nums = [1,2,3]`的时候\n* 我们取`root = new TreeNode(nums[Math.floor(nums.length / 2)])`即为2当根节点。当前左数组为[1], 右半数组为[3]\n* 左节点 应该是左半数组组成的**左子树**, 左半数组剩下[1], 当前子树`root = new TreeNode(nums[Math.floor(nums.length / 2)])`, 所以根节点为1, 而后当前左右数组都为`[]`, 再来`root.left = 回到第一步 `\n  * 当前数组的长度为0, 所以`root.left = null`, 所以整个流程是`root = 2, root.left = 1, root.left.left = null`\n* 右节点跟左节点一样\n\n\n## 源码\n\n```jsx\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\nvar sortedArrayToBST = function(nums) {\n    //如果当前length 为奇数的话，那切一半，length / 2 + 1 为当前root，偶数为 length / 2\n    const root = half(nums)\n    return root;\n};\n\nvar half = function(nums) {\n    if(nums.length == 0) {\n        return null\n    }\n\n    const currentIndex = Math.floor(nums.length / 2);\n    const rootValue = nums[currentIndex];\n    const currentRoot = new TreeNode(rootValue)\n    // 分治\n    let left = nums.slice(0, currentIndex);\n    let right = nums.slice(currentIndex + 1);\n    currentRoot.left = half(left);\n    currentRoot.right = half(right);\n    return currentRoot;\n}\n```","tags":["algorithm-二叉树","algorithm-递归"]},{"title":"Z 字形变换","url":"/2020/06/30/Z-字形变换/","content":"\n[Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)\n\n其实这道题就是移到数学题\n\n## 分析\n\n> 以 LEETCODEISHIRING 为示例，分别对row = 3, row = 4, row = 5, 进行分析, 括号表示index\n\n### row = 3\n\n|row/column| c = 0 | c = 1 | c = 2 | c = 3 | c = 4 | c = 5 | c = 6 | c = 7 |\n| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :--:  |\n| r = 0    | L(0)  |       | C(4)  |       |  I(8) |       | R(12) |       |\n| r = 1    | E(1)  | T(3)  | O(5)  |  E(7) |  S(9) | I(11) | I(13) | G(15) |\n| r = 2    | E(2)  |       | D(6)  |       |  H(10)|       | N(14) |       |\n\n### row = 4\n\n|row/column| c = 0 | c = 1 | c = 2 | c = 3 | c = 4 | c = 5 | c = 6 |\n| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| r = 0    | L(0)  |       |       |  D(6) |       |       | R(12) |\n| r = 1    | E(1)  |       | O(5)  |  E(7) |       |  I(11)| I(13) |\n| r = 2    | E(2)  | C(4)  |       |  I(8) |  H(10)|       | N(14) |\n| r = 3    | T(3)  |       |       |  S(9) |       |       | G(15) |\n\n### row = 5\n\n|row/column| c = 0 | c = 1 | c = 2 | c = 3 | c = 4 | c = 5 | c = 6 | c = 7 |\n| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| r = 0    | L(0)  |       |       |       |  I(8) |       |       |       |\n| r = 1    | E(1)  |       |       |  E(7) |  S(9) |       |       | G(15) |\n| r = 2    | E(2)  |       | D(6)  |       |  H(10)|       | N(14) |       |\n| r = 3    | T(3)  | O(5)  |       |       |  I(11)|  I(13)|       |       |\n| r = 4    | C(4)  |       |       |       |  R(12)|       |       |       |\n\n* 我们看这三个 `r = 0`时，第一个数跟第二数的偏移， 我们称这个为总偏移量\n    * row = 3时, 偏移为 4 - 0 = 4\n    * row = 4时，偏移为 6 - 0 = 6\n    * row = 5时，偏移为 8 - 0 = 8\n    * **总结：** 偏移 = 2 * row - 2\n* 再看 `r = 1`时，就是第二行数据， 第一个数跟第二个数以及第三个数的偏移\n    * row = 3 时，偏移为 3 - 1 = 2， 5 - 3 = 2， 上面总偏移量为4，所以第3个数跟第2个数的偏移量为 4-2 =2 \n    * row = 4 时，偏移为 5 - 1 = 4， 7 - 5 = 2， 上面总偏移量为6，所以第3个数跟第2个数的偏移量为 6-4 =2。 这一行往后的偏移是 4, 2, 4, 2, 4, 2 这样走  \n    * row = 5 时，偏移为 7 - 1 = 6， 9 - 7 = 2， 上面总偏移量为8，所以第3个数跟第2个数的偏移量为 6-4 =2。 这一行往后的偏移是 6, 2, 6, 2, 6, 2 这样\n    * 直到**前一个数 + 偏移量 >= s.length**换下一行。\n    * **总结：**第一个数与第二个数偏移量为 2 * (row - (r + 1)), 而第二个数跟第三个数的偏移量为 （总偏移量 - 第一个数跟第二个数的偏移量）\n* 往后如此类推，但最后一行跟第一行的偏移量应该一样\n\n\n## 源码\n\n```js\nvar convert = function(s, numRows) {\n    let result = [];\n    let length = s.length;\n    if(numRows == 1) {\n        return s;\n    }\n    let totalOffset = 2 * numRows - 2; // 总偏移量\n    let flag = true;  // 标志位\n    let i = 0;      // 表示数组中有几个数\n    let row = 1;    // 表示 第几行\n    let start = 0;  // 表示 当前index\n    let offset = 2 * (numRows - row);\n    while(i < length) {\n        result.push(s[start]);\n        // 第一行的偏移量跟最后一行的偏移量一样\n        if(row == 1 || row == numRows) {\n            start = start + totalOffset;\n        } else {\n            if(flag) {\n                start = start + offset;\n                flag = false;\n            } else {\n                start = start + (totalOffset - offset);\n                flag = true;\n            }\n        }\n        \n        i++;\n        // 换下一行，同时计算他的偏移值，把flag 重置\n        if(start >= length) {\n            row++;\n            start = row - 1;\n            flag = true\n            offset = 2 * (numRows - row);\n        }\n    }\n    return result.join(\"\")\n};\n```","tags":["algorithm-基础","algorithm-数组"]},{"title":"数组中的第K个最大元素","url":"/2020/06/29/数组中的第K个最大元素/","content":"\n[数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n## 题目描述\n\n在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n\n> 输入: [3,2,1,5,6,4] 和 k = 2\n> 输出: 5 \n> 解释：排序后数组结果[1,2,3,4,5,6], 取第二大的那个数就是 5\n\n## 分析\n\n* 这个题目直接想就是**数组通过排序后获取倒数第k个数**\n* 这里我使用快速排序\n\n### 代码\n\n```js\n// 快速排序\nfunction quicksort(nums, low, high) {\n    let i;\n    let j;\n    let s;\n    while (high > low) {\n        i = low;\n        j = high;\n        s = nums[low];\n        while (i < j) {\n            while (nums[j] > s) {\n                j--;\n            }\n            nums[i] = nums[j];\n            while (s >= nums[i] && i < j) {\n                i++;\n            }\n            nums[j] = nums[i];\n        }\n        nums[i] = s;\n        quicksort(nums, low, i - 1);\n        low = i + 1;\n    }\n    return nums;\n}\nvar findKthLargest = function(nums, k) {\n    const newNums = quicksort(nums, 0, nums.length - 1);\n    return newNums[nums.length - k];\n};\n```","tags":["algorithm-排序","algorithm-快速排序"]},{"title":"React源码-ReactDOM","url":"/2020/06/28/React源码-ReactDOM/","content":"\n## 文件目录\n\n`packages/react-dom/src/ReactDOM.js`\n\n## 用法\n\n```jsx\nReactDOM.render(<App />, document.getElementById(\"root\"));\n```\n\n## 源码\n\n### ReactDOM.render\n\n```jsx\nconst ReactDOM: Object = {\n    /**\n     * element => <App />\n     * container => document.getElementById(\"root\")\n     * callback => 回调函数 很少用\n    */\n    render(\n        element: React$Element<any>,\n        container: DOMContainer,\n        callback: ?Function,\n    ) {\n    // 下面第四个参数为false， 如果为true那么说明是服务端渲染\n    return legacyRenderSubtreeIntoContainer(\n        null,\n        element,\n        container,\n        false,\n        callback,\n    );\n};\n```\n\n* 先为`container`创建`_reactRootContainer`属性，其类型是ReactRoot, 同时在这一步中**删除掉container中的所有子集**\n\n### legacyRenderSubtreeIntoContainer\n\n```jsx\n/**\n * parentComponent => null\n * children => <App>\n * container => document.getElementById(\"root\")\n * forceHydrate => false\n * callback => callback\n*/\nfunction legacyRenderSubtreeIntoContainer(\n    parentComponent: ?React$Component<any, any>,\n    children: ReactNodeList,\n    container: DOMContainer,\n    forceHydrate: boolean,\n    callback: ?Function,\n) {\n    let root: Root = (container._reactRootContainer: any);\n    // 当前 container 没有 _reactRootContainer, 进去if操作执行legacyCreateRootFromDOMContainer\n    if (!root) {\n        // 初始化操作，创建_reactRootContainer属性， 类型是ReactRoot\n        root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n            container,\n            forceHydrate,\n        );\n        // 反正我从没传过 callback，不关心实现\n        if (typeof callback === 'function') {\n            const originalCallback = callback;\n            callback = function() {\n                const instance = getPublicRootInstance(root._internalRoot);\n                originalCallback.call(instance);\n            };\n        }\n        // Initial mount should not be batched.\n        // 第一次加载的话不需要打包更新\n        unbatchedUpdates(() => {\n            // 第一次不存在 parentComponent, 然后调用ReactRoot.prototype.render\n            if (parentComponent != null) {\n                root.legacy_renderSubtreeIntoContainer(\n                parentComponent,\n                children,\n                callback,\n                );\n            } else {\n                root.render(children, callback);\n            }\n        });\n    } else {\n        if (typeof callback === 'function') {\n            const originalCallback = callback;\n            callback = function() {\n                const instance = getPublicRootInstance(root._internalRoot);\n                originalCallback.call(instance);\n            };\n        }\n        // Update\n        if (parentComponent != null) {\n            root.legacy_renderSubtreeIntoContainer(\n                parentComponent,\n                children,\n                callback,\n            );\n        } else {\n            root.render(children, callback);\n        }\n    }\n    return getPublicRootInstance(root._internalRoot);\n}\n```\n\n### legacyCreateRootFromDOMContainer\n\n* 该方法是删除container下的子节点，并且生成`ReactRoot`\n\n```jsx\nfunction legacyCreateRootFromDOMContainer(\n    container: DOMContainer,\n    forceHydrate: boolean,\n): Root {\n    // 这个变量跟服务端渲染有关，我们直接把他看成false\n    const shouldHydrate =\n        forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n   \n    if (!shouldHydrate) {\n        let rootSibling;\n        // 这里直接把container的子节点删除，直到没有子节点\n        // <div id=\"root\"></div>\n        while ((rootSibling = container.lastChild)) {\n            container.removeChild(rootSibling);\n        }\n    }\n    \n    // 默认情况下root不用异步\n    const isConcurrent = false;\n    return new ReactRoot(container, isConcurrent, shouldHydrate);\n}\n```\n\n### ReactRoot\n\n* 我们看ReactRoot这个结构函数 `createContainer`就是一行代码它的作用是创建FiberRoot, 而这个root 其实又是 `FiberRootNode`\n* 然后创建Fiber, `createFiber(HostRoot, null, null, mode);`, 然后又返回了`FiberNode`, 此时`container`拥有**_reactRootContainer**属性, 而 `_reactRootContainer` 拥有 `_internalRoot`属性, 而`_internalRoot`又拥有`current`属性，这个属性类型就是FiberNode\n* 我们可以在react 项目下 打印一下 `document.getElementById(\"root\")._reactRootContainer`\n\n```js\n/**\n * container => <div id=\"root\"></div>\n * isConcurrent => false\n * hydrate => false\n*/\nfunction ReactRoot(\n    container: DOMContainer,\n    isConcurrent: boolean,\n    hydrate: boolean,\n) {\n    // 这个 root 指的是 FiberRoot\n    // 文件路径 packages/react-reconciler/src/ReactFiberReconciler.js\n    // createContainer 很简单就一行代码 \n    // return createFiberRoot(containerInfo, isConcurrent, hydrate);\n    const root = createContainer(container, isConcurrent, hydrate);\n    this._internalRoot = root;\n}\n\nReactRoot.prototype.render = function(\n  children: ReactNodeList,\n  callback: ?() => mixed,\n): Work {\n  // 这里就是之前的那个createFiberRoot创建的FiberRoot\n  const root = this._internalRoot;\n  // ReactWork 的功能就是为了在组件渲染或更新后把所有传入\n  // ReactDom.render 中的回调函数全部执行一遍\n  const work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  // 如果有 callback，就 push 进 work 中的数组\n  if (callback !== null) {\n    work.then(callback);\n  }\n  // work._onCommit 就是用于执行所有回调函数的\n  updateContainer(children, root, null, work._onCommit);\n  return work;\n};\n\n// 其实这里的名字已经表达了意思了，将subTree渲染进container\nReactRoot.prototype.legacy_renderSubtreeIntoContainer = function(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  callback: ?() => mixed,\n): Work {\n  const root = this._internalRoot;\n  const work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n \n  if (callback !== null) {\n    work.then(callback);\n  }\n  updateContainer(children, root, parentComponent, work._onCommit);\n  return work;\n};\n```\n\n#### createContainer\n\n```jsx\nexport function createContainer(\n    containerInfo: Container,\n    isConcurrent: boolean,\n    hydrate: boolean,\n): OpaqueRoot {\n    return createFiberRoot(containerInfo, isConcurrent, hydrate);\n}\n```\n\n#### createFiberRoot\n\n```jsx\nexport function createFiberRoot(\n  containerInfo: any,\n  isConcurrent: boolean,\n  hydrate: boolean,\n): FiberRoot {\n    // FiberRootNode 内部创建了很多属性\n    const root: FiberRoot = (new FiberRootNode(containerInfo, hydrate): any);\n    // document.getElementById(\"root\").._reactRootContainer._internalRoot 是 FiberRoot\n    // document.querySelector('#root')._reactRootContainer._internalRoot.current 是 Fiber\n    const uninitializedFiber = createHostRootFiber(isConcurrent);\n    root.current = uninitializedFiber;\n    uninitializedFiber.stateNode = root;\n\n    return root;\n}\n\n```\n\n#### createHostRootFiber \n\n```js\nexport function createHostRootFiber(isConcurrent: boolean): Fiber {\n    let mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;\n\n    if (enableProfilerTimer && isDevToolsPresent) {\n        mode |= ProfileMode;\n    }\n    \n    // HostRoot 指的是 classComponent, lazyComponent, functionCompoenent 等等\n    return createFiber(HostRoot, null, null, mode);\n}\n\n```\n\n#### createFiber \n\n我们可以从 `packages/react-reconciler/src/ReactFiber.js` 查看Fiber 的属性\n\n```jsx\nconst createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n```\n\n\n## FiberRoot 的结构\n<details>\n<summary><mark>点击查看FiberRoot</mark></summary>\n\n```jsx\ntype BaseFiberRootProperties = {|\n  // Any additional information from the host associated with this root.\n  // 就是 document.getElementById(\"root\")\n  containerInfo: any,\n  // 仅用于持久更新。\n  pendingChildren: any,\n  // 当前应用对应的Fiber对象，是Root Fiber\n  current: Fiber,\n\n  // 以下优先级用于区分\n  // 1) 没有提交(committed)的任务\n  // 2) 没有提交的挂起任务\n  // 3) 没有提交的可能被挂起的任务\n  // 我们选择不追踪每个单独的阻塞登记，为了兼顾性能而是按交易粒度来衡量绩效。\n\n  earliestSuspendedTime: ExpirationTime,\n  latestSuspendedTime: ExpirationTime,\n  // The earliest and latest priority levels that are not known to be suspended.\n  earliestPendingTime: ExpirationTime,\n  latestPendingTime: ExpirationTime,\n  // 最新通过的一个被reslove并且可以重新尝试的优先级\n  latestPingedTime: ExpirationTime,\n\n  pingCache:\n    | WeakMap<Thenable, Set<ExpirationTime>>\n    | Map<Thenable, Set<ExpirationTime>>\n    | null,\n\n  // 如果抛出错误，并且队列中没有更多更新，则在处理该错误之前，我们尝试从根目录再次进行一次同步渲染。\n  didError: boolean,\n\n  // 正在等待提交的任务的`expirationTime`\n  pendingCommitExpirationTime: ExpirationTime,\n \n  finishedWork: Fiber | null,\n  // 超时的操作\n  timeoutHandle: TimeoutHandle | NoTimeout,\n  // Top context object, used by renderSubtreeIntoContainer\n  context: Object | null,\n  pendingContext: Object | null,\n  // Determines if we should attempt to hydrate on the initial mount\n  +hydrate: boolean,\n  // Remaining expiration time on this root.\n  // TODO: Lift this into the renderer\n  nextExpirationTimeToWorkOn: ExpirationTime,\n  expirationTime: ExpirationTime,\n  // List of top-level batches. This list indicates whether a commit should be\n  // deferred. Also contains completion callbacks.\n  // TODO: Lift this into the renderer\n  firstBatch: Batch | null,\n  // root之间关联的链表结构\n  nextScheduledRoot: FiberRoot | null,\n\n  // New Scheduler fields\n  callbackNode: *,\n  callbackExpirationTime: ExpirationTime,\n  firstPendingTime: ExpirationTime,\n  lastPendingTime: ExpirationTime,\n  pingTime: ExpirationTime,\n|};\n\ntype ProfilingOnlyFiberRootProperties = {|\n  interactionThreadID: number,\n  memoizedInteractions: Set<Interaction>,\n  pendingInteractionMap: PendingInteractionMap,\n|};\n\nexport type FiberRoot = {\n  ...BaseFiberRootProperties,\n  ...ProfilingOnlyFiberRootProperties,\n};\n```\n</details>\nFiberRoot 的结构是上面两个合起来\n\n## Fiber 结构\n\n<details>\n<summary><mark>点击查看Fiber</mark></summary>\n\n```js\nexport type Fiber = {|\n\n  // 指的是functionComponent 还是 classComponent等等， lazyComponent\n  tag: WorkTag,\n\n  // Unique identifier of this child.\n  key: null | string,\n\n  // The value of element.type which is used to preserve the identity during\n  // reconciliation of this child.\n  elementType: any,\n\n  // The resolved function/class/ associated with this fiber.\n  type: any,\n\n  //  本地相关联的Fiber\n  stateNode: any,\n\n  // 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回\n  return: Fiber | null,\n\n  // 子节点，兄弟节点\n  child: Fiber | null,\n  sibling: Fiber | null,\n  index: number,\n\n  // 就是ref\n  ref: null | (((handle: mixed) => void) & {_stringRef: ?string}) | RefObject,\n\n  // 将要处理的props, 罪行的props\n  pendingProps: any, // This type will be more specific once we overload the tag.\n  // 上一次的props\n  memoizedProps: any, // The props used to create the output.\n\n  // A queue of state updates and callbacks.\n  // 用来存放 update，也就是用来记录改变状态的\n  updateQueue: UpdateQueue<any> | null,\n\n  // 上一次的state\n  memoizedState: any,\n\n  // A linked-list of contexts that this fiber depends on\n  contextDependencies: ContextDependencyList | null,\n  mode: TypeOfMode,\n\n  // Effect\n  effectTag: SideEffectTag,\n\n  // Singly linked list fast path to the next fiber with side-effects.\n  nextEffect: Fiber | null,\n\n  firstEffect: Fiber | null,\n  lastEffect: Fiber | null,\n\n  // Represents a time in the future by which this work should be completed.\n  // Does not include work found in its subtree.\n  expirationTime: ExpirationTime,\n\n  // This is used to quickly determine if a subtree has no pending changes.\n  childExpirationTime: ExpirationTime,\n\n  alternate: Fiber | null,\n\n  actualDuration?: number,\n\n  actualStartTime?: number,\n\n  selfBaseDuration?: number,\n\n  treeBaseDuration?: number,\n\n|};\n```\n</details>\n\n## Fiber结构图\n\n![Fiber结构图](https://i.loli.net/2020/06/29/zJLutWEVHIZjKvr.png)\n\n## 函数运行流程图\n\n![运行流程图](./React源码-ReactDOM/函数运行流程图.jpg)\n\n\n> [从demo查看](https://codesandbox.io/s/heuristic-gagarin-edqiv?file=/src/App.js)\n\n\n\n","tags":["react","react源码系列"],"categories":["react","react源码系列"]},{"title":"二进制求和","url":"/2020/06/23/二进制求和/","content":"\n[67. 二进制求和](https://leetcode-cn.com/problems/add-binary/)\n\n## 题目描述\n\n给定两个二进制字符串，两个相加返回结果\n\n> 输入: a = \"1010\", b = \"1011\"\n> 输出: \"10101\"\n\n\n## 解决方案\n\n将指针指向字符串最后一位，两两相加再加上仅为，注意处理进位，两字符串的当前值为1时\n    * 当前进位为0时，那么1 + 1 + 0 = 2 ，二进制要进位，当前值应该为2 % 2 = 0。进位变为1\n    * 当前仅为为1时，那么1 + 1 + 1 = 3 ，二进制要进位，当前值应为 3 % 2 = 1。 进位为1\n    * **将当前值放到数组头部**\n\n|       | i = 0 | i = 1 | i = 2 | i = 3 |\n|:-----:| :---: | :---: | :---: | :---: |\n| a数组 |       | 1      | 1     |   1   |\n| b数组 |       | 1     | 0     |    1   |\n| result| 1     | 0     | 0     | 0     |\n\n## 代码\n\n```js\nvar addBinary = function(a, b) {\n    let aLength = a.length;\n    let bLength = b.length;\n\n    let i = aLength - 1;\n    let j = bLength - 1;\n    \n    let result = [];\n    let add = 0; // 进位\n\n    while(i >= 0 || j >= 0) {\n        let atemp = i >= 0 ? a[i] * 1 : 0;  // 对i判定大于0为了防止数组溢出\n        let btemp = j >= 0 ? b[j] * 1 : 0;\n\n        let current =  atemp + btemp + add;\n        if(current >= 2) {\n            add = Math.floor(current / 2);\n        } else {\n            add = 0;\n        }\n        result.unshift(current % 2); // 将当前值放入到数组头\n\n        i--;\n        j--;\n    }\n    // 退出循环后如果数组为1表示有进位，那也要加到数组头\n    if(add != 0) {\n        result.unshift(add)\n    }\n\n    return result.join(\"\")\n};\n```","tags":["algorithm-双指针"]},{"title":"盛最多水的容器","url":"/2020/06/23/盛最多水的容器/","content":"\n[11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\n\n## 题目描述\n\n给定一个数组，数组存放的是每个元素的高度，以数组的key做x轴， a[key]做y轴 计算出其中两条与x轴形成的最大面积。\n\n> 以[1,8,6,2,5,4,8,3,7]为例子\n> 最大的面积为49， 以x1轴为1，y1轴为8， 和x2为8，y2为7构成的面积最大为49\n\n<img src=\"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg\" style=\"margin-left: 0; height: 250px\" />\n\n\n## 暴力破解\n\n我们可以用两重循环的方式暴力破解，可是我可以看出我们其实做了一些没必要的计算，\n    * `i = 0`时，`j = 1, j = 2, j = 3, .....j = 7`这些都是没必要计算的\n    * `i = 1`时，`j = 2, j = 3, j = 4, ....j = 7`, 这些都是没必要的\n    * 如此类推\n    \n```js\nvar maxArea = function(height) {\n    let start = 0; \n    let end = height.length - 1;\n    let max = 0;\n\n    for(let i = 0; i < height.length; i++) {\n        for(let j = i + 1; j < height.length; j++) {\n            let x = j - i;\n            let y = height[i] > height[j] ? height[j] : heigth[i];\n            max = Math.max(x * y, max)\n        }\n    } \n    return max;\n};\n```\n\n## 分析\n\n此题使用双指针，我们看上图，当前值为y, 当y一定时，那么x 尽可能的大，就可以找到最大值了。\n\n* 定义 **头尾指针**\n* 如果当前头指针 < 尾指针，那么，**头指针到尾指针的距离**为 y, **头指针**的值为x, 解释一下： 当前值头指针的值固定（y固定），x为最大。所以当前值高度为y的时候，面积最大\n* 如果当前头指针 > 尾指针，那么，**头指针到尾指针的距离**为 y, **尾指针**的值为x, 解释如上\n* 这个时候我们只需要修改头指针和尾指针就可以了。\n    * **头指针 < 尾指针时**，当前头指针的值y, 头指针到尾指针的距离为x, 当前面积已经最大了，所以**头指针向后移 start++**\n    * **头指针 > 尾指针时**，当前尾指针的值y, 头指针到为指针的距离为x, 当前面积已经醉倒了，所以**尾指针向前移 end--**\n\n* **注意：**这里需要分析好y轴就可以了\n\n以上面`heigth = [1,8,6,2,5,4,8,3,7]` 为例子， `start = 0; end = heigth.length - 1`\n\n* 当start = 0的时候, 当前y值为 `heigth[start]`为1，`height[end]`为7, `height[start] < height[end]`, start到end的距离x 为最大，且y的距离只能为1, 当前y = 1的时候，面积最大为7， 然后`start向后移`\n* 此时 `start = 1, end = heigth.length - 1`:\n    * `height[start] = 8, height[end] = 7`, 然而`height[start] > height[end]`, 那y的值只能够**取小**的那个，即`height[end]`, 当前`y=height[end]=7`的时候，`x = end - start`，面积最大为`49`, `end向前移动`; \n\n\n\n## 代码\n\n```jsx\nvar maxArea = function(height) {\n    let start = 0; \n    let end = height.length - 1;\n    let max = 0;\n\n    while(start != end) {\n        let x = end - start;\n        let y = height[end] > height[start] ? height[start] : height[end];\n\n        max = Math.max(x * y, max);\n\n        if(height[end] > height[start]) {\n            start++;\n        } else {\n            end--;\n        }\n    }\n    return max;\n};\n```\n","tags":["algorithm-双指针"]},{"title":"React源码-ReactChildren","url":"/2020/06/19/React源码-ReactChildren/","content":"\n## 文件目录\n\n`/packages/react/src/ReactChildren`\n\n## 文档\n\n[文档地址](https://zh-hans.reactjs.org/docs/react-api.html#reactchildren)\n\nReactChildren 主要用于组合模式，详细可以去看看ant-design的`Radio.Group`, `CheckBox.Group`;\n\n## children\n\n`this.props.children` 其实是一个 **ReactElement**对象或者是一个数组它的值也是`ReactElement`, [查看demo](https://codesandbox.io/s/happy-gould-ve16n?file=/src/App.js)可以看到控制台的输出。\n\n## React.Children.map\n\n![1592548713_1_.jpg](https://i.loli.net/2020/06/19/dQw3hM68FRs4vUG.png)\n`React.Children.map(this.props.children, (item) => [item, [item, [item]]])`可以看到一个挺有趣的现象，多层嵌套的数组平铺成一维数组，即`[item, [item, [item]]]` => `[item, item, item]`, 但可以注意一下各item的**key**\n\n\n### 源码\n\n#### 先看看 `mapChildren`\n\n```jsx\n/**\n * @param {?*} children  \n * @param {function(*, int)} func 遍历的方式\n * @param {*} context 上下文\n * @return {object} 遍历完后的结果\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  // 遍历出来的元素会丢到 result 中最后返回出去\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n```\n\n#### `mapIntoWithKeyPrefixInternal`\n\n```jsx\n/**\n * @param {?*} children   <p>123<p>\n * @param {Array} array   []\n * @param {string} prefix \"\"\n * @param {func} func     item => [item, [item, [item]]]\n * @param {*} context     undefined\n*/\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  \n  // 这里是处理 key, 看下面\n  let escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  // getPooledTraverseContext 和 releaseTraverseContext 是配套的函数\n  // 用处其实很简单，就是维护一个大小为 10 的对象重用池\n  // 每次从这个池子里取一个对象去赋值，用完了就将对象上的属性置空然后丢回池子\n\n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n\n  // 将当前 traverseContext 都的属性置空，然后丢回池子\n  releaseTraverseContext(traverseContext);\n}\n```\n\n#### escapeUserProvidedKey\n\n**eg.** `\".0/.0\"`, `\".0/.1:0\"`, `\".0/.1:1:0\"` 将 `/` 匹配，然后在`/`加一个`/` => `\".0//.0\"`, \n\n**replace** 的 第二个参数 `'$&'` 表示匹配的内容\n```jsx\nconst userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n```\n\n#### getPooledTraverseContext 和 releaseTraverseContext\n\n`getPooledTraverseContext` 和 `releaseTraverseContext` 是配套使用的，他们主要是维护一个长度为10对象池，`getPooledTraverseContext` 就是从对象池中拿一个对象出来然后赋值，`releaseTraverseContext` 就是将 traverseContext 的属性赋值为空，然后重新放会到池子里面。这样做是因为减少 创建对线和释放对象的性能消耗。\n\n```jsx\n/**\n * 从池中拿一个对象然后赋值，要是池子没有那直接返回一个对象\n * @param {Array} mapResult  遍历后的结果存放\n * @param {string} keyPrefix key 值\n * @param {func} maoFunction (item) => {}\n * @param {*} mapContext undefined \n * @returns {result, keyPrefix, func, context, count = 0}\n*/\n\nfunction getPooledTraverseContext(\n  mapResult,\n  keyPrefix,\n  mapFunction,\n  mapContext,\n) {\n  if (traverseContextPool.length) {\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n\n// 将对象置空然后放回池子\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n```\n\n#### traverseAllChildren\n\n```jsx\n/**\n * @param {*} children <p>123</p> 或者是 [<p>123</p>, <p>456</p>]\n * @param callback mapSingleChildIntoContext\n * @param {result, keyPrefix, func, context, count = 0} traverseContext\n*/\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n```\n\n#### traverseAllChildrenImple\n\n```jsx\n/**\n * @param {?*} children <p>123</p> 或者是 [<p>123</p>, <p>456</p>]\n * @param {!string} nameSoFar 名字路径\n * @param {!function} callback mapSingleChildIntoContext\n * @param {?*} traverseContext {result, keyPrefix, func, context, count = 0} \n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(\n  children,\n  nameSoFar,\n  callback,\n  traverseContext,\n) {\n  // 这个函数核心作用就是通过把传入的 children 数组通过遍历摊平成单个节点\n  // 然后去执行 mapSingleChildIntoContext\n\n  // 开始判断 children 的类型\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n  // 如果 children 是可以渲染的节点的话， 比如是<Demo>123</Demo>, 这种情况下，children 是“123”, 就直接调用 callback, \n  // 如果 children 是 [<p>123</p>, <p></p>] 就跳过往下走\n  // callback 是 mapSingleChildIntoContext\n  if (invokeCallback) {\n    callback(\n      traverseContext,\n      children,\n      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,\n    );\n    return 1;\n  }\n\n  // nextName 和 nextNamePrefix 都是在处理 key 的命名\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n  const nextNamePrefix =\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  // 节点是数组的话，就开始遍历数组，并且把数组中的每个元素再递归执行 traverseAllChildrenImpl\n  // 如果children 是数据的话，遍历children数组， 然后在对每个元素进行\n  // mapSingleChildIntoContext\n  if (Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(\n        child,\n        nextName,\n        callback,\n        traverseContext,\n      );\n    }\n  } else {\n    // 不是数组的话，就看看 children 是否可以支持迭代\n    // 就是通过 obj[Symbol.iterator] 的方式去取\n    const iteratorFn = getIteratorFn(children);\n    // 只有取出来对象是个函数类型才是正确的\n    if (typeof iteratorFn === 'function') {\n      // 然后就是执行迭代器，重复上面 if 中的逻辑了\n      const iterator = iteratorFn.call(children);\n      let step;\n      let ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(\n          child,\n          nextName,\n          callback,\n          traverseContext,\n        );\n      }\n    } else if (type === 'object') {\n      let addendum = '';\n      const childrenString = '' + children;\n            \n    }\n  }\n\n  return subtreeCount;\n}\n```\n\n* 该函数用于平铺节点\n* 我们要记住callback 是 `mapSingleChildIntoContext`\n* 判断`children`类型\n  * 为数字，字符串，还有单个节点的时候直接执行`mapSingleChildIntoContext`\n  * 要是为数组的话遍历数组，再执行`traverseAllChildrenImpl`\n  * 不是数组的话判断一下children 是不是可迭代的，要是是对象的话就抛出对象\n  \n\n#### mapSingleChildIntoContext\n\n```js\n/**\n * 这个函数只有当传入的 child 是单个节点是才会调用\n * @param bookKeeping traverseContext \n * @param child 传入的节点\n * @param childKey 节点的 key\n */\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  const {result, keyPrefix, func, context} = bookKeeping;\n  // func  => (item) => [item, [item, [item]]]\n  let mappedChild = func.call(context, child, bookKeeping.count++);\n  // 判断函数返回值是否为数组\n  // mappedChild 的结果是 [item, [item, [item]]]\n  // 我们说 (item) => [item, [item, [item]]] 会平铺成 [item, item, item]\n  if (Array.isArray(mappedChild)) {\n    // 是数组的话就回到最先调用的函数中\n    // 然后回到之前 traverseAllChildrenImpl 摊平数组的问题\n    // 假如 c => [item, [item, [item]]]，当执行这个函数时，返回值应该是 [item, [item, [item]]]\n    // 然后 [item, [item, [item]]] 会被当成 children 传入\n    // traverseAllChildrenImpl 内部逻辑判断是数组又会重新递归执行\n    \n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c);\n  } else if (mappedChild != null) {\n    // 不是数组且返回值不为空，判断返回值是否为有效的 Element\n    // 是的话就把这个元素 clone 一遍并且替换掉 key\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(\n        mappedChild,\n        // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        keyPrefix +\n          (mappedChild.key && (!child || child.key !== mappedChild.key)\n            ? escapeUserProvidedKey(mappedChild.key) + '/'\n            : '') +\n          childKey,\n      );\n    }\n    result.push(mappedChild);\n  }\n}\n```\n\n看看流程\n**eg.**\n* `React.Children.map(this.props.children, (item) => [item, [item, [item]]])`\n* children => `[<p>123</p>, <p>456</p>]`, func => `(item) => [item, [item, [item]]`, result = []\n\n\n1. 先进行 `mapIntoWithKeyPrefixInternal`, 传入上面三个值， 我们直接忽略key\n2. 然后从池里赋值 `func` 和`result`, `prefix`， 此时 `traverseContext`\n  * ```js\n      result: [],\n      keyPrefix: '',\n      func: (item) => [item, [item, item]],\n      context: undefined\n      count: 0\n    ```\n3. 然后执行 `traverseAllChildren`\n4. 再执行 `traverseAllChildrenImpl`, 判断 当前children 是不是可以直接渲染\n  * 是的话：那直接执行 mapSingleChildIntoContext， 将当前节点放到result\n  * 但现在我们的 `children` 是数组， 所以我们要逐个遍历， 再执行`traverseAllChildrenImpl`\n    * **eg.**此时我们拿到`children[0]`, 然后执行`traverseAllChildrenImpl`,然后进入 `mapSingleChildIntoContext，`\n    * ```jsx\n      // mapSingleChildIntoContext\n      // bookKeeping：{ result: [], keyPrefix: \"\", func: (item) => [item, [item, [item]]] }\n      // child: <p>123</p>\n      ```\n    * 在`mapSingleChildIntoContext`内执行了func, 所以得到的结果是`mappedChild = [item, [item, [item]]]`， 然后**判断mappedChild是否是数组**，是的话把 mappedChild 当成children 从第一步开始, 但递归后此时func是`c => c`,\n\n    * 从 `traverseAllChildrenImpl` 判断 `mappedChild` 是数组，然后遍历他，拿出第一个item，再执行了一次 `traverseAllChildrenImpl`,然后是ReactElement,就执行了`mapSingleChildIntoContext`, 但**注意**此时的func 是 `c => c`, 判定结果不是数组，将结果push 进result，`mapSingleChildIntoContext结束`。回到`traverseAllChildrenImpl`, 然后执行 `mappedChild[1]`, 又在`traverseAllChildrenImpl`方法判定是数组，再取`mappedChild[1][0]` 去做 `mapSingleChildIntoContext`, 然后执行 func `c => c`,再push进result，`mapSingleChildIntoContext结束`, 再一次回到`traverseAllChildrenImpl`，直到`mapChildren`遍历完。\n5. 以上如此类推\n      \n\n\n## 流程图\n\n<!-- ![1592636860_1_.jpg](https://i.loli.net/2020/06/20/gDGK3Jal8bYx7Pp.png) -->\n\n<a class=\"group\" rel=\"group1\" href=\"https://i.loli.net/2020/06/20/gDGK3Jal8bYx7Pp.png\">\n    <img src=\"https://i.loli.net/2020/06/20/gDGK3Jal8bYx7Pp.png\" />    \n</a>","tags":["react","react源码系列"],"categories":["react","react源码系列"]},{"title":"React源码--ReactElement","url":"/2020/06/18/React源码-ReactElement/","content":"\n## 文件目录\n\npackages/react/src/ReactElement\n\n## ReactElement\n\n指定当前元素是 ReactElement, 但该元素是由 createElement 创建的, 来看一下**ReactElement** 源码\n\n\n```jsx\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    $$typeof: REACT_ELEMENT_TYPE,   // 指Element元素\n\n    // 下面几个都是我们 元素的属性，\n    // eg. <div key=\"1\" ref=\"string\" value=\"123\"></div>\n    type: type,                \n    key: key,                    \n    ref: ref,                      \n    props: props, \n    \n    // 记录负责创建此元素的组件。\n    _owner: owner,  // 其实是一个FiberNode\n  };\n\n  return element;\n};\n\n```\n\n## createElement\n\n[文档](https://react.docschina.org/docs/react-api.html#createelement)\n\n根据type 创建一个ReactElement。同时处理**ref, key, props, 还有children, 另外对defaultProps 赋值**。\n\n我们看一下babel 的转化吧！\n\n```html\n<div key=\"1\" ref=\"string\" value=\"123\">\n    <p>children1</p>\n    <p>children2</p>\n</div>\n```\n\n会转换成\n\n```jsx\nReact.createElement(\n    \"div\", \n    {\n        ref: \"string\",\n        value: \"123\",\n        key: \"1\"\n    },\n    React.createElement(\n        \"p\", \n        null,\n        \"children1\",\n    )\n    React.createElement(\n        \"p\", \n        null,\n        \"children12\",\n    )\n)\n```\n\n\n### 源码：\n\n```jsx\nexport function createElement(type, config, children) {\n    // type => div\n    // config => {ref: \"string\",value: \"123\",key: \"1\"}\n    // children => <p>children1</p>, <p>children2</p>\n\n    let propName;\n\n    const props = {};\n\n    let key = null;\n    let ref = null;\n    let self = null;\n    let source = null;\n\n    //  验证config, 把key 和 ref 从config 单独抽离出来放到props 中\n    if (config != null) {\n        // 验证 ref 和 key\n        if (hasValidRef(config)) {\n            ref = config.ref;\n        }\n        if (hasValidKey(config)) {\n            key = '' + config.key;\n        }\n        \n        // self 正确获取this, 检测this与 ReactElement.owner是否相等，不相等就发出警告\n        // source 一个注释对象（由编译器或其他方式添加），指示文件名，行号和/或其他信息。\n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source;\n       \n        // 遍历配置，把除了key, ref, _self, _source这些以外的数据放到props\n        for (propName in config) {\n            if (\n                hasOwnProperty.call(config, propName) &&\n                !RESERVED_PROPS.hasOwnProperty(propName)\n            ) {\n                props[propName] = config[propName];\n            }\n        }\n    }\n\n    // 处理children, arguments 后面的参数都是children\n    // 如果children 数大于1个，那么放入到数组中\n    const childrenLength = arguments.length - 2;\n    if (childrenLength === 1) {\n        props.children = children;\n    } else if (childrenLength > 1) {\n        const childArray = Array(childrenLength);\n        for (let i = 0; i < childrenLength; i++) {\n            childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n    }\n\n    // 判断是否有给组件设置 defaultProps，有的话判断是否有给 props 赋值，\n    // 只有当值为 undefined 时，才会设置默认值\n    if (type && type.defaultProps) {\n        const defaultProps = type.defaultProps;\n            for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n                props[propName] = defaultProps[propName];\n            }\n        }\n    }\n\n    return ReactElement(\n        type,\n        key,\n        ref,\n        self,\n        source,\n        ReactCurrentOwner.current,\n        props,\n    );\n}\n```\n\n## cloneElement\n\n[文档](https://react.docschina.org/docs/react-api.html#cloneelement)\n\ncloneElement 克隆元素， 大致跟createElement 的处理方式一样 。\n\n","tags":["react","react源码系列"],"categories":["react","react源码系列"]},{"title":"最佳观光组合","url":"/2020/06/17/最佳观光组合/","content":"\n## 最佳观光组合\n\n[题目](https://leetcode-cn.com/problems/best-sightseeing-pair/)\n\n## 题目描述\n\n给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。\n一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。\n返回一对观光景点能取得的最高分。\n\n示例：\n\n> 输入：[8,1,5,2,6]\n> 输出：11\n> 解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\n\n## 暴力破解\n\n```js\nvar maxScoreSightseeingPair = function(A) {\n    let max = 0;\n    const length = A.length;\n    for(let i = 0; i < length; i++) {\n       for(let j = i + 1; j < length; j++) {\n            max = Math.max((A[i] + A[j] + i - j), max); \n       } \n    }\n    return max\n};\n```\n\n## 分析\n\n我们可以看方程 `A[i] + A[j] + i - j => A[i] + i + A[j] - j`, 我们遍历数组 可以知道 `A[j] - j` 是可以知道的并且是固定的，所以只要把 `A[i] + i` 变为最大即可，所以 `max + A[j] - j` \n\n\n## 动态规划\n\n>  max = A[i] + A[j] + i - j = A[i] + i + A[j] - j\n\n```js\nvar maxScoreSightseeingPair = function(A) {\n    let len = A.length;\n    let dp = [];\n    let max = 0;\n    dp[0] = 0;\n\n    for(let i = 1; i < len; i++){\n        dp[i] = Math.max(dp[i - 1], A[i - 1] + i - 1);\n        max = Math.max(max, dp[i] + A[i] - i);\n    }\n    return max;\n}\n\n```\n\n## 优化\n\n```js\nvar maxScoreSightseeingPair = function(A) {\n    let res = 0;\n    let max = 0;\n    const length = A.length;\n    debugger;\n    // A[i] + A[j] + i - j => A[i] + i + A[j] - j\n    // 我们知道A[j] - j 是固定的, 只要维护 A[i] + i 为最大即可，所以就遍历一次 => max + A[j] - j\n    for(let i = 0; i < length; i++) {\n        res = Math.max(max + A[i] - i, res);\n        max = Math.max(max, A[i] + i)\n    }\n\n    return res;\n};\n```\n\n","tags":["algorithm-动态规划","algorithm-基础"]},{"title":"React源码--React API","url":"/2020/06/16/React源码-React API/","content":"\n## 源码版本 16.8.6\n\n[地址](https://github.com/facebook/react/tree/16.8.6)\n\n## 看看API\n\n我们进到`packages/src`, 看到`React.js`, 其实这个文件时返回一些基本的API, 比如我们常用的`Children, createRef, Component, PureComponent, createContext, forwardRef, lazy, memo` 还有 **hooks** 等等，但我们先不看hooks\n\n### Children\n\n这个Children方法其实是给我们处理`props.children`的, `props.children`其实就是一个类数组的东西，Children的用法有遍历`React.Children.map` 或者 `React.Children.forEach`，一般情况下我们会配合**组合模式cloneElement**使用， 有返回`children`个数 `React.Children.count`，另外两个不常用`toArray`和 `only`\n\n[文档](https://zh-hans.reactjs.org/docs/react-api.html#reactchildren)\n\n[源码解析](https://zhou-bill.github.io/2020/06/19/React%E6%BA%90%E7%A0%81-ReactChildren/)\n\n### createRef\n\n我们看看用法\n\n```jsx\nclass Demo extends React.Component {\n    constructor() {\n        this.ref = React.createRef()\n    }\n\n    render() {\n        return (\n            <div>\n                <Input ref={this.ref} />\n                // 或者\n                <Input ref={(inputRef) => this.ref = inputRef } />\n            </div>\n        )\n    }\n}\n```\n\n### Component 和 PureComponent\n\nComponent 和 PureComponent 就是后者多了一个`state` 和 `props` 的浅比较， 也就是相当于在 `Component` 执行了 `shouldComponentUpdate`, 简单类型下，可以用`PureCompnent` 做组件的性能优化\n\n### createContext\n\n在 react 16后，context 做了改变\n\n```jsx\n\nconst ThemeContext = React.createContext('light');\n\nclass App extends React.Component {\n    render() {\n        // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。\n        // 无论多深，任何组件都能读取这个值。\n        // 在这个例子中，我们将 “dark” 作为当前的值传递下去。\n        return (\n            <ThemeContext.Provider value=\"dark\">\n                <Toolbar />\n            </ThemeContext.Provider>\n        );\n    }\n};\n```\n\n```jsx\n// 中间的组件再也不必指明往下传递 theme 了。\nfunction Toolbar() {\n    return (\n        <div>\n            <ThemedButton />\n        </div>\n    );\n}\n```\n\n```jsx\nclass ThemedButton extends React.Component {\n    render() {\n        return (\n            <ThemeContext.Consumer> \n                {\n                    (theme) => (\n                        <Button theme={theme} />\n                    )\n                }\n            \n            </ThemeContext.Consumer>\n        );\n    }\n}\n```\n\n### forwardRef\n\n其实就是ref 的转发, 一般情况下我们不能用ref 当做props 传递给组件的，但可以通过forwardRef 做强制转发，用的最多的是解决HOC组件传递ref的问题的\n\n```jsx\nconst FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"FancyButton\">\n    {props.children}\n  </button>\n));\n\n// 你可以直接获取 DOM button 的 ref：\nconst ref = React.createRef();\n<FancyButton ref={ref}>Click me!</FancyButton>;\n```\n\n\n### lazy\n\n简单说就是懒加载\n\n\n### memo\n\n简单说就是 PureComponent\n","tags":["react","react源码系列"],"categories":["react","react源码系列"]},{"title":"面试题46. 把数字翻译成字符串","url":"/2020/06/09/面试题46-把数字翻译成字符串/","content":"\n[面试题46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)\n\n## 题目描述\n\n给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n\n示例：\n\n> 输入: 12258\n> 输出: 5\n> 解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\"\n\n## 分析\n\n* 一开始想的也是 **滑动窗口**, 但后来想了一下不太正确，应该用动态规划\n\n## 过程\n\n以 `nums = \"12258\"` 为例子\n\n* `i = 0`, `nums[0]` => `1`, 结果为`b`,那么结果只有一种， 解释： 只取第一个数`1`的时候，结果肯定只有一种，\n    * `1 转成 b`\n* `i = 1`, `nums[1]` => `2`, 结果为`bc, m`, 那么结果有两种，解释： 当数字为`12`的时候，它可以为\n    * ` 1 => b, 2 => c`, 为一种：`bc` \n    * `12 => m`, 为一种：`m`\n* `i = 2`, `nums[2]` => `2`, 结果为`bcc, mc, bw`, 结果有三种，解释：当数字为`122`的时候,它可以为 \n    * `1  => b, 2  => c, 2 => c` 为一种, `bcc`\n    * `12 => m, 2  => c` 为一种, `mc`\n    * `1  => b, 22 => w` 为一种, `bw`\n* `i = 3`, `nums[3]` => `5`, 结果为`bccf, mcf, bwf, mz, bcz`, 解释： 当数字为`1225`的时候，他可以为\n    * `1  => b, 2  => c, 2 => c, 5 => f` 为一种, `bccf`\n    * `12 => m, 2  => c, 5 => f` 为一种, `mcf`\n    * `1  => b, 22 => w, 5 => f` 为一种, `bwf`\n    * `1  => b, 2  => c, 25 => z` 为一中, `bcz`\n    * `12 => m, 25 => z`, 为一种：`mz`\n* `i = 4`, `nums[4]` => `8`, 结果为`bccfi, mcfi, bwfi, mzi, bczi`, 解释： 当数字为`12258`的时候，他可以为\n    * `1  => b, 2  => c, 2 => c, 5 => f, 8 => i` 为一种, `bccfi`\n    * `12 => m, 2  => c, 5 => f, 8 => i` 为一种, `mcfi`\n    * `1  => b, 22 => w, 5 => f, 8 => i` 为一种, `bwfi`\n    * `1  => b, 2  => c, 25 => z, 8 => i` 为一中, `bczi`\n    * `12 => m, 25 => z, 8 => i`, 为一种：`mzi`\n\n上面我们看 `i = 1`, `i = 2`, `i = 3` 的时候，的结果，我们用`dp`表示他们的结果\n    * `i = 3`的结果`bccf, mcf, bwf, mz, bcz`,\n    * `i = 2`的结果`bcc, mc, bw`,\n    * `i = 1`的结果`m, bc`    \n\n发现没，其实`dp[3]` 就是从 `dp{2]` 和`dp[1]`的结果过来的, `dp[2]`的字符串结果都加个`f`就等于`dp[3]`的前3个, `dp[1]`的字符串结果加个`z`就是`dp[3]`后三个\n所以递推公式 **dp[i] = dp[i - 1] + dp[i - 2]**, 但此时递推公式明显不符合`i = 4`的时候的值, **dp[i] 明显等于 dp[i-1]**, 但前提是`nums[i - 1] + nums[i] = 58 > 25`\n\n## 代码\n\n```js\nvar translateNum = function(num) {\n    let numString = num + \"\";\n    let length = numString.length;\n    if(length < 1) {\n        return 0\n    }\n    let dp = [];\n    // 递推公式 dp[i] = d[i - 1] + dp[i - 2], 和 dp[i] = dp[i - 1]\n    dp[0] = 1;\n    for(let i = 1; i < length; i++) {\n        const temp = numString[i - 1] + numString[i];  // 当temp = 06 的时候 其实也跟dp[i - 1]一样\n        if(temp > 25 || numString[i - 1] == '0') {\n            dp[i] = dp[i - 1]\n        } else {\n            dp[i] = dp[i - 1] + (i - 2 < 0 ? 1 : dp[i - 2]) ;  // i - 2 < 0 这里是为了解决 dp[i-2]防止溢出问题, 12 结果为2,\n        }\n    }\n    return dp[length - 1]\n};\n```\n","tags":["algorithm-动态规划","algorithm-面试题"]},{"title":"面试题29. 顺时针打印矩阵","url":"/2020/06/09/面试题29-顺时针打印矩阵/","content":"\n[面试题29.顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)\n\n## 题目描述\n\n输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\n\n示例 1：\n\n> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[1,2,3,6,9,8,7,4,5]\n\n## 分析\n\n示例1：\n\n| i/j   | j = 0 | j = 1 | j = 2 |\n|:-----:| :---: | :---: | :---: |\n| i = 0 | 1     | 2     | 3     |\n| i = 1 | 4     | 5     | 6     |\n| i = 2 | 7     | 8     | 9     |\n| i = 2 | 10    | 11    | 13    |\n\n示例2：\n\n| i/j   | j = 0 | j = 1 | j = 2 | j = 3 |\n|:-----:| :---: | :---: | :---: | :---: |\n| i = 0 | 1     | 2     | 3     | 4     |\n| i = 1 | 5     | 6     | 7     | 8     |\n| i = 2 | 9     | 10    | 11    | 12    |\n| i = 2 | 13    | 14    | 15    | 16    |\n\n可以看一下结果，题目说是顺时针打印，可以想象一下 i 跟 j 的变化\n\n* 循环遍历\n* 结束条件是： 当结果数组的长度 == `matrix`数组的高 * 宽， 即所有子集都遍历过了\n* 再来分析一下边界问题, 分析一下 `i`, `j` 的变化， 这里以 **示例2** 为例子\n    1. 开始： 向右走， 那么 `j++`，`i`不变， 到 `j == 3`的时候向下， 所以这里要考虑右边的边界问题\n    2. 向下走： 那么 `i++`, `j` 不变，到 `i == 3`的时候向左， 所以考虑下边界问题\n    3. 向左走： 那么 `j--`, `i` 不变，到 `j == 0`的时候向上，所以考虑左边界问题\n    4. 向上走： 那么 `i--`, `j` 不变，到 `i == 1`的时候再一次重复， 1,2,3,4这四步， 但这里要考虑上边界的问题\n\n我这里用 `direction` 表示方向， `1 => 向右， 2 => 向下， 3 => 向左， 4 =》 向上`\n\n这时候就是想什么时候得到边界，在边界的时候改变方向，所以有\n\n* 先设置边界 `left = 0, right = colums - 1, up = 0, down = rows - 1`, 这里表示`左右上下`的边界，我们只要操作这个边界就可以了\n另外`rows`表示有多少行，`colums`表示有多少列\n\n* `i == up && j == left`, 我们可以看 `i == 0, j == 0`的时候，这时候就是向右走\n\n* `i == up && j == right`, 这时候就是 `i == 0， j == 3`的时候，那么我们就改变方向，向下走\n\n* `i == down && j == right`, 这时候就是 `i == 3, j == 3`，那么又改变方向，向左走\n\n* `i == down && j == left`, 这时候就是 `i == 3, j == 0`, 又改变方向，向上走\n\n* 注意： 此时向上走之后，等 `i == up + 1 && j == left`, 即 `i == 1, j ==0`, 即`5`这个地方，那么就`向右走`，同时，更改边界, `left++, right--, up++, down--` 再重复上面的事情\n\n> 整个过程是：\n\n* `1 => 2 => 3 => 4 => 8 => 12 => 16 => 15 => 14 => 13 => 9 => 5 这是一圈`\n* `6 => 7 => 11 => 10 这又是一圈`\n\n当输入的`matrix = [[1],[2],[3]]`就只有一列的时候， 另外看`示例1`, 走完外圈，剩下内圈，只剩下`5,8`这两个元素的时候也`向下走`，所以总结 `left == right`的时候，`direction = 2, i++`\n\n## 代码\n\n```js\nvar spiralOrder = function(matrix) {\n    let rows = matrix.length;\n    let result = [];\n    if(rows == 0) {\n        return result\n    }\n    let columns = matrix[0].length;\n    let count = 0;\n    let i = 0;\n    let j = 0;\n    let direction = 1;  // 1 => 向右 2 => 向下 3=> 向左 4 => 向上\n    let left = 0;        // 左边界\n    let right = columns - 1;  // 右边界\n    let up = 0; \n    let down =  rows - 1;\n\n    while(count < rows * columns) {\n        const current = matrix[i][j];\n        result.push(current);\n        count++;\n        if(left == right) {  // 当剩下的元素只有一列的时候，只能向下走了\n            direction = 2;\n            i++;\n            continue;\n        }\n        if(i == up && j == left) {   // 拐点向右\n            direction = 1\n        } else if(i == up && j == right) {  // 拐点向下\n            direction = 2\n        } else if(i == down && j == right) { // 拐点向左\n            direction = 3;\n        } else if(i == down && j == left) { // 拐点向上\n            direction = 4\n        }\n        \n        if(i == up + 1 && j == left) {\n            // 完成一圈后，重设定边界\n            left = left + 1;\n            right = right - 1;\n            up = up + 1;\n            down = down - 1;\n            direction = 1;\n        }\n\n        // 根据方向，改变i, j的值\n        if(direction == 1) {\n            j++;\n        } else if(direction == 2) {\n            i++;\n        } else if(direction == 3) {\n            j--;\n        } else {\n            i--;\n        }\n    }\n    return result\n};\n```\n","tags":["algorithm-基础","algorithm-数组","algorithm-面试题"]},{"title":"高德地图滑动验证","url":"/2020/06/05/高德地图滑动验证/","content":"\n## 高德地图滑动验证\n\n* 用dispatch 模拟dom的mousedown, mousemove，还有mouseUp 事件\n* 再用 `setInterval` 执行`mouseMove`事件即可\n* 但这里有时候会滑动失败，所以要刷新验证码，然后重新滑动，\n* 有时候又是滑动验证码**验证成功**后。 再一次**弹出验证码**\n* **注意：**滑动验证码请注意滑动的速度和滑动的距离，要是太慢、滑动距离太短的话，滑动验证多数会不通过。\n\n### 检查验证码\n```js\n// 检查验证码\nfunction checkYzm() {\n    const dom = document.querySelector(\".sufei-dialog\");\n    \n    if(dom && dom.style.display == \"block\") {\n        return true;\n    } \n    return false\n}\n```\n\n### 滑动验证码\n```js\nasync function sliderYzm() {\n    await sleep(1500);\n    const iframe = document.getElementById(\"sufei-dialog-content\");\n    const btn = iframe.contentWindow.document.getElementById(\"nc_1_n1z\");\n    const mousedown = document.createEvent(\"MouseEvents\");\n    const rect = btn.getBoundingClientRect();\n    var x = rect.x;\n    var y = rect.y;\n    mousedown.initMouseEvent(\"mousedown\", true, true, window, 0, x, y, x, y, false, false, false, false, 0, null);\n    btn.dispatchEvent(mousedown);\n\n    let dx = 0;\n    let dy = 0;\n    const mousemove = document.createEvent(\"MouseEvents\");\n    return new Promise((resolve) => {\n        const  interval = setInterval(async () => {\n            const _x = x + dx;\n            const _y = y + dy;\n            mousemove.initMouseEvent(\"mousemove\", true, true, window,0 ,_x, _y, _x, _y, false, false, false, false, 0, null);\n            btn.dispatchEvent(mousemove);\n            \n            if(_x - x >= 300){\n                clearInterval(interval);\n                const mouseup = document.createEvent(\"MouseEvents\");\n                mouseup.initMouseEvent(\"mouseup\", true, true, window, 0, _x, _y, _x, _y, false, false, false, false, 0, null);\n                btn.dispatchEvent(mouseup);\n\n                await sleep(2500);\n                if(btn.className.indexOf('btn_ok') > -1){\n                    console.log(btn.className);\n                    sleep(1000)\n                    resolve({status: 1});\n                }  \n                \n                if(iframe.contentWindow.document.querySelector(\"#nocaptcha > .errloading\")) {\n                    console.log(\"error\")\n                    sleep(1000)\n                    resolve({status: 0})\n                }\n            } else{\n                dx += Math.ceil(Math.random() * 300);\n            }\n        }, 30);\n    })\n    \n}\n```\n\n上面只是滑动验证\n\n### 循环检查时候是否有验证码\n\n```js\n/**\n * 循环检查是否有验证码\n * 1. 要是有验证码窗口，那么滑动验证， 但滑动验证有失败或者成功，失败返回0， 成功返回1\n * 2. 滑动成功后，防止验证码再一次出现，我们延迟1500毫秒，再查看一下验证码窗口是否存在，存在就再一次执行loopSlideYzm(), 不存在就直接结束函数了\n * 3. 滑动失败后，会有刷新标志，那这时候应该点击刷新后，再一次执行loopSlideYzm();\n */ \nasync function loopSlideYzm() {\n    await sleep(1200);\n    const hasYzm = checkYzm();\n    await sleep(1000);\n    if(hasYzm) {\n        const { status } = await sliderYzm();\n        await sleep(1500);\n        if(status) {\n            console.log(\"再找一次是否有验证码\")\n            const hasYzmAgain = checkYzm();\n            await sleep(1500);\n            if(hasYzmAgain) {\n                return await loopSlideYzm();\n            } else  {\n                return Promise.resolve()\n            }\n        } else {\n            console.log(\"给我刷新验证码\");\n            freshYzm();\n            await sleep(1500);\n            return await loopSlideYzm();\n        }\n    } \n    return Promise.resolve()\n}\n```\n\n### 刷新验证码\n\n```js\nfunction freshYzm() {\n    const iframe = document.getElementById(\"sufei-dialog-content\");\n    iframe.contentWindow.document.querySelector(\"#nocaptcha > .errloading > .nc-lang-cnt > a\").click()\n}\n```\n\n以上就是自动跳过高德地图的滑动验证码全过程\n","tags":["js"],"categories":["js"]},{"title":"记录一下react的一些用法","url":"/2020/06/03/记录一下react的一些用法/","content":"\n## 高阶组件\n\n### HOC\n\n* HOC 其实就是一个函数， 接收参数是**一个组件**，但返回值是**一个组件**\n\n看一个简单的高阶组件\n\n```js\nfunction visibleHOC(WrappedComponent) {\n    return class extends Component {\n        render() {\n            const { visible } = this.props;\n            \n            if(!visible) return null;\n            return <WrappedComponent {...this.props}>\n        }\n    }\n}\n```\n\n## Render Props\n\n```js\nconst CustomModal = ({visible, cancel}) => {\n    return (\n        <Modal visible={visible} onCancel={cancel} >\n            Hello World\n        </Modal>\n    )\n}\n```\n\n```js\nclass ModalContainer extends Component {\n    state = {\n        visible: false\n    }\n\n    handleCancel = () => {\n        this.setState({\n            visible: false\n        })\n    }\n\n    show = () => {\n        this.setState({\n            visible: true\n        })\n    }\n\n    render() {\n        const { visible } = this.state;\n        const { children } = this.props;\n        return (\n            children({\n                visible: visible,\n                show: this.show,\n                cancel: this.handleCancel\n            })\n        )\n    }\n}\n```\n\n```js\nclass App extends Component {\n    render() {\n        return (\n            <div>\n                <ModalContainer>\n                    ({visible, show, cancel}) => (\n                        <>\n                            <CustomModal visible={visible} cancel={cancel}></CustomModal>\n                            <Button type=\"primary\" onClick={show}>\n                                Click\n                            </Button>\n                        </>\n                    )\n                </ModalContainer>\n            </div>\n        )\n    }\n}\n```\n\n[demo](https://codesandbox.io/s/modal-container-nt23y?file=/ModalContainer.js)","tags":["react"],"categories":["react"]},{"title":"原型与继承","url":"/2020/06/01/原型与继承/","content":"\n## prototype\n\n我们知道每个函数都有一个**prototype**指向他的原型对象。\n我们可以这么理解： 每个对象在创建时就与另一个对象产生关联，其实就是对另一个对象的引用。而js 再找**对象属性**时会顺着原型链一直往上找，直到无法找到为止\n\n来看一下\n\n```js\nfunction Person(name) {\n    this.name = name\n}\n\n// 控制台打印一下， => 是结果\nPerson.prototype  => { constructor: f }\n\n// 而 Person.prototype.constructor 又指向与构造函数自己\nPerson.prototype.constructor == Person  // true\n```\n\n用下图表示：\n![1591078556.jpg](https://i.loli.net/2020/06/02/5nJ2Tr4xRo6Wsk3.png)\n\n\n## __proto__\n\n每个对象都有一个`__proto__`属性，除了null外，而这个属性又指向他的原型对象\n\n验证一下\n\n```js\nfunction Person(name) {\n    this.name = name\n}\n\nvar person = new Person(\"Bill\");\n\n// 控制台打印一下， person.__proto__\nperson.__proto__ => { constructor: f }\n\n// 我们从上面[prototype]看 Person.prototype 也是指向 { constructor: f }, 那么他们是否是同一个东西呢?\nperson.__proto__ == Person.prototype   // 结果是 true 的\n\n// 上面一样的话，那么\nperson.__proto__.contructor == Person // true\n```\n\n用图表示一下就是\n\n![1591082949_1_.jpg](https://i.loli.net/2020/06/02/ZjH7Ty2tclun65e.png)\n\n## new 操作符\n\n> 这里解释一下new 操作符，其实跟原型有关\n\n首先搞清楚`new` 做了什么\n\n* 创建对象\n* 将对象的原型指向函数的原型\n* 改变 `this` 上下文\n* 返回这个对象\n\n```js\nfunction newObj(fn, ...args) {\n    var obj = {};\n    obj.__proto__ = fn.prototype;\n    let res = fn.call(obj, ...args);\n    \n    let isObject = typeof res === 'object' && typeof res !== null;\n    let isFunction = typeof res === 'function';\n    return isObject || isFunction ? res : obj;\n\n    // 这里其实可以直接返回obj\n    // 但防止 fn 这个方法直接返回this, 以下这种情况\n\n    // function fn(name) {\n    //     this.name = name;\n    //     return this;\n    // }\n} \n\nfunction Person(name) {\n    this.name = name;\n}\n// 测试一下\nperson = newObj(Person, \"Bill\")\n\n// 打印一下 person\n// Person {name: Bill}\n```\n\n## Fn.prototype.__proto__\n\n* 我们说**Fn.prototype** 是一个原型对象，我们上面说只要是对象都有`__proto__`, 那么`Fn.prototype.__proto`指向的是什么呢？\n\n答案是： `Object.prototype`\n\n```js\nObject.prototype == Person.prototype.__proto__  // true\n```\n\n所以有了下图\n\n![1591086668_1_.jpg](https://i.loli.net/2020/06/02/1g8zioGeFZwuf6n.png)\n\n到此原型基本已经讲完了\n\n\n## 继承\n\n下面写继承\n\n### 原型链继承\n\n```js\nfunction Parent(){\n    this.role = \"parent\"\n    this.list = [1,2,3]\n}\n\nParent.prototype.getRole = function() {\n    return this.role\n}\n\nfunction Child(name) {\n    this.name = name\n}\n\nChild.prototype = new Parent();\n\nChild.prototype.getName = function() {\n    return this.name;\n}\n\nvar children = new Child(\"admin\");\nchildren.getName()\nchildren.getRole()\n\nvar parent = new Parent();\nconsole.log(parent.role)  // parent\n\nChild.prototype.value = \"123\"\nconsole.log(parent.value);  // \"undefined\"\nconsole.log(children.value) // “123”\n\n// 以下是原型链的缺点\nvar children2 = new Child(\"child2\");\nconsole.log(children.list, children2.list) // [1,2,3], [1,2,3,4]\nchildren.list.push(4);\nconsole.log(children.list, children2.list) // [1,2,3,4], [1,2,3,4]\n```\n\n看下图\n\n![1591092645_1_.jpg](https://i.loli.net/2020/06/02/XJg9vL2CWi5FKRU.png)\n\n* 当执行了 `Child.prototype = new Parent()`, **我们说找属性的话,会顺着原型链去找**, 比如`children`要找`getRole`,那么他会一直找，`Child.prototype.__proto__`下有`getRole`, 这就是继承\n* 当执行了 `Child.prototype.value = \"123\"`, `children`实例也拥有了**value** 。\n* **缺点**: \n    * 只要在某个子类下改变了**父类**的**引用类型**的值，那么**子类**都会改变，这样做就**不能做到相互独立**了\n    * 无法实现父类构造函数属性的赋值\n\n\n### 使用call，改变this 作用域\n\n```js\nfunction Parent() {\n    this.role = \"parent\"\n}\n\nfunction Child(role, name) {\n    Parent.call(this, role)\n    this.name = name;\n}\n\nvar children = new Child(\"children\", \"哈哈哈\");\n\n// 注意\nParent.prototype.getRole = function() {\n    return this.role;\n}\n\n// 上面原型方法，子类是无法继承的，即children没有getRole 方法\n```\n\n**优点：**\n* 解决了原型继承无法向父类赋值的问题\n* 可以继承多个构造函数属性（call多个）；\n\n**缺点：**\n* 只能继承父类构造函数的属性。**原型链新创建的无法被继承**\n* 无法实现构造函数的复用。（每次用每次都要重新调用）\n* 每个新实例都有父类构造函数的副本，臃肿。\n\n### 组合模式\n\n将call方式和原型链方式组合起来\n\n```js\nfunction Parent(role) {\n    this.role = role\n}\n\nParent.prototype.value = \"test\";\n\nfunction Child(role, name) {\n    Parent.call(this, role);\n    this.name = name;\n}\n\nChild.prototype = new Parent();\n\nvar children = new Child(\"child\", \"admin\")\n```\n\n**优点：**\n\n* 可以继承父类原型上的属性，可以传参，可复用；\n* 每个新实例引入的构造函数属性是私有的；\n\n**缺点：**\n* 调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数；\n\n\n### 寄生式继承\n\n```js\nfunction Parent(role) {\n    this.role = role;\n    this.list = [1,2,3];\n}\n\nParent.prototype.value = \"123\"\n\n// 原型式继承\nfunction _extend(obj) {\n    function F(){};\n    F.prototype = obj;  // F.prototype = new Parent()  -> 还是回到原型链继承\n    return new F();     // 这里像不像 原型链继承上面的 new Child();\n}\n\nvar parent = new Parent();  // 获取父类实例\n\n// 以上是原型式继承，以下给原型继承在套个壳子传递参数\nfunction wrap(obj, name, role){\n    var child = _extend(obj);   \n    child.role = role;\n    child.name = name;\n    return child;\n}\nvar child = wrap(parent, 'test', \"child\");\nconsole.log(child.role)  // \"test\"\nconsole.log(child.value) // \"123\"\n\nvar child1 = wrap(parent, \"Bill\", \"child1\");\nconsole.log(child1.list) // [1,2,3]\n\nchild1.list.push(456);   \nconsole.log(child1.list) // [1,2,3,456]\nconsole.log(child.list)  // [1,2,3,456] \n```\n\n看上面\n* 又回到了**原型链继承**的缺点之一了，对于**父类引用类型**的，一旦做了修改，子类的都会发生改变\n\n###  寄生组合式继承\n\n```js\nfunction Parent(role) {\n    this.role = role;\n    this.list = [1,2,3];\n}\n\nParent.prototype.value = \"123\"\n\nfunction Child(name, role) {\n    Parent.call(this, role)  // 等于有了父类构造函数的副本\n    this.name = name;\n}\n\nfunction _extend(obj) {\n    function F(){};\n    F.prototype = obj;  // F.prototype = new Parent()  -> 还是回到原型链继承\n    return new F();     // 这里像不像 原型链继承上面的 new Child();\n}\n\nvar extendFn = _extend(Parent.prototype);\nChild.prototype = extendFn;\n\nextendFn.constructor = Child;\nvar children = new Child(\"test\", \"child\");\n\n```\n我们看下图\n![1591157016_1_.jpg](https://i.loli.net/2020/06/03/gN4HcF98ymQ7UpA.png)\n\n上面与下面其实大致一样,\n\n```js\nfunction F(){};\nF.prototype = Parent.prototype;\nfunction Child() {\n    Parent.call(this);\n}\nChild.prototype = new F();  // 是不是有点像组合模式\n```\n\n```js\n// 寄生组合模式理想版\nfunction inheritPrototype(subType, superType){\n    var prototype = Object.create(superType.prototype); //创建对象\n    prototype.constructor = subType; //增强对象\n    subType.prototype = prototype; //指定对象\n}\nfunction SuperType(name){\n    this.name = name;\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function(){\n    alert(this.name);\n};\nfunction SubType(name, age){\n    SuperType.call(this, name);\n    this.age = age;\n}\ninheritPrototype(SubType, SuperType);//实现继承\nSubType.prototype.sayAge = function(){\n    alert(this.age);\n}\n```","tags":["js"],"categories":["js"]},{"title":"打家劫舍","url":"/2020/05/29/打家劫舍/","content":"\n[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)\n\n\n## 题目描述\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n```js\n输入: [1,2,3,1]\n输出: 4\n解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n```\n\n## 尝试\n\n* 一开始以为是 `i奇数`的值相加，与`偶数`的值相加，最后比最大值，提交发现是错误的\n* 然后一想就知道是一位数组的动态规划\n\n\n## 题解\n\n* 定义数组含义： `dp[i]` 设定第i房间时，所偷的钱为最大\n* 找出数组元素间的关系式 => 递推公式。 题目规定：小偷不能连续偷窃相邻的房子，至少隔一个房间，\n  那么当我偷到第i房间的时候，我只要求出第i-2房间时跟第i-3房间时的最大值即可，`i-2`表示隔了一间房间， `i-3`表示隔了2个房间\n  所以递推公式为 `dp[i] = nums[i] + Math.max(dp[i - 3], dp[i - 2])`\n* 找出初始条件： 第0间自然是`nums[0]`, 但我们递推公式 `i-3`和`i-2` 理论上没有非正整数的房间，我们手动输入为0吧\n\n\n```js\nvar rob = function(nums) {\n    // dp[i] = nums[i] + Max(dp[i-3], dp[i-2]) \n    let dp = new Map();\n    dp[0] = nums[0];\n    dp[-1] = 0;\n    dp[-2] = 0;\n\n    // dp(1) = nums[1] + max(dp(1-3), dp[1-2])\n    for(let i = 1; i < nums.length; i++) {\n        dp[i] = nums[i] + Math.max(dp[i-3], dp[i-2]);\n    }\n    let result = 0;\n    for(let i = 0; i < nums.length; i++) {\n        result = Math.max(result, dp[i]);      \n    }\n    return result\n};\n```\n","tags":["algorithm-动态规划"]},{"title":"字符串解码","url":"/2020/05/29/字符串解码/","content":"\n[394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n## 题目描述\n\n编码规则为：`k[encoded_string]`, 即中括号前表示**重复的次数**，中括号里面的是**重复的字符串**\n\n例子：\n\n```js\ns = \"3[a]2[bc]\", 返回 \"aaabcbc\".\ns = \"3[a2[c]]\", 返回 \"accaccacc\".\ns = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\".\n```\n\n## 尝试\n\n* 用栈的方式去解决问题\n* 用递归的方式\n\n## 递归解决\n\n* 以`3[a2[c]]`为例子, 变量为`s`\n* 遍历字符串`s`, \n* 如果是`数字`, `/\\d/.test(s[i])`, `i++`,\n* 如果直接是`字母`,那直接往后扫, `i++`\n* 遇到`[`进入递归\n* 遇到`]`结束递归，同时返回`[encode_string]`中括号里面的内容, 同时返回当前`index`，即当前`]`在`s[]`中第几位 \n* 将**第6步**返回的值和**第3步**的重复次数，做个for循环就好了\n\n## 代码实现\n\n```js\nvar decodeString = function(s) {\n    let res = \"\";\n    const sub = generate(s, 0);\n    res += sub.sub;\n    return res\n}\n// 3[a2[c]]\nfunction generate(string, start) {\n    let index = start;\n    let temp = \"\";\n    let tempNum = \"\";\n\n    while(index < string.length) {\n        const current = string[index];\n        if(current == \"[\") {\n            const sub = generate(string, index + 1 );\n            let res = \"\";\n            index = (sub.index)\n            for(let i = 0 ; i < tempNum ; i++) {\n                res += sub.sub\n            }\n            temp += res;\n            tempNum = \"\";\n        } else if(current == \"]\") {\n            let res = temp;\n            return {index: index + 1, sub: res}\n        } else if(/\\d/.test(current)) {\n            tempNum += current\n            index++;\n         } else {\n            temp += current\n            index++\n         }\n    }\n    return {index: index, sub: temp} \n}\n```\n\n","tags":["algorithm-递归"]},{"title":"和为k的子数组","url":"/2020/05/27/和为k的子数组/","content":"\n[力扣上第560题](https://leetcode-cn.com/problems/subarray-sum-equals-k/)\n\n## 题目描述\n\n给定一个数组 `nums` 跟一个 和为`k` 的值，找到该数组中和为 k 的连续的子数组的个数。\n\n```html\n输入:nums = [1,1,1], k = 2\n输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。\n```\n\n## 尝试\n\n* 暴力破解, 即每个数跟与他以后的数相加 等于k，那么 res + 1\n\n```js\nfunction subarraySum(nums, k) {\n    let res = 0;\n    for(let i = 0; i < nums.length; i++) {\n        let current = nums[i];\n        if(current == k) {\n            res += 1;\n        }\n\n        for(let j = i + 1; j < nums.length; j++) {\n           current += nums[j];\n           if(current == k) {\n               res += 1;\n           } \n        }\n    }\n    return res;\n}\n```\n\n* 滑动窗口，滑动窗口不太好处理，窗口向右扩展的时候，那其实是跟上面算法好像差不多，然后放弃了\n\n* 看了题解，发现了一个**前缀和**算法\n\n## 前缀和算法\n\n* 将数组中的每一项在遍历时都加起来，然后加入到新的数组中，我们用`s[i]`表示\n    * 定义`s[0] = 0`\n    * `s[1] = a[0]`\n    * `s[2] = s[1] + a[1]`\n    * 所以得到 `s[i + 1] = s[i] + nums[i]`\n    * 所以移动等式 `nums[i] = s[i + 1] - s[i]`\n\n所以有以下代码\n```js\nfunction subarraySum(nums, k) {\n    let res = 0;\n    let s = [0];\n\n    // 多了这一层，结果更慢了\n    for(let i = 0; i < nums.length; i++) {\n        s[i + 1] = s[i] + nums[i];\n    }\n\n    for(let i = 0; i < nums.length; i++) {\n        for(let j = i; j <= nums.length; j++) {\n            if(s[j + 1] - s[i] == k) {\n                res++;\n            }\n        }\n    }\n\n    return res\n}\n```\n\n可以看到以上代码其实跟第一种方法是大同小异的，只是使用了前缀和的思想，但这个方法比上面那个还要慢，因为多 前缀和添加这一组循环\n\n## 优化\n\n> 看到题解是用**前缀和**还有**哈希表**做优化的\n\n思想：\n\n* 将当前**前缀和**的值当做**哈希表**的`key`。\n* 将当前**前缀和**出现的次数 当做**哈希表**的`value`\n\n具体操作如下:\n\n* 当遍历 `nums`时，计算当前**前缀和**, 存入map\n* 如果 map 中已存在 key 为 当前`前缀和 - k`,  因为一直遵守 `【当前前缀和】-【之前求出的前缀和】 === k`, \n    * 那么取出哈希表的值，`res += value`, \n* 如果 map 中， 没有当前前缀和的值\n    * 那么把**前缀和**添加到哈希表中，值为1， \n    * 如果有，那么改变`哈希表`的值: `map[prefix]++`\n\n```js\nfunction subarraySum(nums, k) {\n    let res = 0;\n    let map = { 0:1 };\n    let prefixSum = 0;\n\n    for(let i = 0; i < nums.length; i++) {\n        prefixSum += nums[i];\n        \n        if(map[prefixSum - k]) {\n            res += map[prefixSum - k]\n        }\n\n        if(map[prefixSum]) {\n            map[prefixSum]++\n        } else {\n            map[prefixSum] = 1\n        }\n    }\n    return res\n}\n```","tags":["algorithm-前缀和"]},{"title":"验证回文字符串 Ⅱ","url":"/2020/05/19/验证回文字符串 Ⅱ/","content":"\n## 验证回文字符串 Ⅱ\n\n[力扣上第680题](https://leetcode-cn.com/problems/valid-palindrome-ii/)\n\n## 核心思想\n\n使用双指针，即使用前后两个指针，同时对前指针和后指针的值做对比，要是相同，那么前指针向后移动，后指针向前移动\n**但这道题说可以删除一个字符**, 那么当我们遇到不相等的值的时候，只要前指针向后移动，或者后指针向前移动，然后剩下的做对比即可\n\n* 终止条件为： **前指针 比 后指针要大，或者说是前指针后于后指针**\n\n\n## 解释\n\n![1590400698_1_.jpg](https://i.loli.net/2020/05/25/6pKX9EhsoyrkPIH.png)\n\n上图，我们只要判断左指针和右指针的值是否相等，直到终止条件，要是全部都相同，那么就是回文了\n\n**但这题说可以删除一个字母，那么等字符不相等的时候，左指针向后移动或者右指针向前移动，将剩下的再做一次回文即可**，看下图\n\n![1590400906_1_.jpg](https://i.loli.net/2020/05/25/zlvfcQJZxUYy1hW.png)\n\n\n## 代码\n\n```js\n// \"ebcbb ececabbacec bbcbe\"\n// \"ebcbb cecabbacece bbcbe\"\nvar validPalindrome = function(s) {\n    let left = 0;\n    let right = s.length - 1;\n    let flag = false; // 标志位 表示要是遇到一个前指针与后指针不相同的值, 退出循环。\n    while(left < right) {\n        const leftTemp = s[left];\n        const rightTemp = s[right];\n        if(leftTemp == rightTemp) {\n            left++;\n            right--;\n        } else {\n            flag = true;\n            break;\n        }\n    } \n    if(flag >= 1) {\n        const tempString = s.slice(left + 1, right + 1);\n        return validChilren(left+1, right, s) || validChilren(left, right - 1, s);\n    }\n    return true;\n};\n\nfunction validChilren(left, right, s) {\n    while(left < right) {\n        const leftTemp = s[left];\n        const rightTemp = s[right];\n        if(leftTemp == rightTemp) {\n            left++;\n            right--;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n\n","tags":["algorithm-基础"]},{"title":"大众点评文字数字解密","url":"/2020/05/08/大众点评文字数字解密/","content":"\n## 原理\n\n百度发现大众点评网上面的文字数字加密是通过字体文件加密的，也就是说用css 的class 用不同的类对应的字体文件，再加下面的特殊字符跟字体文件上面的编码一一对应起来\n\n## 先看一下大众点评吧\n\n![1588908462_1_.jpg](https://i.loli.net/2020/05/08/emBOdhVyIK4TA8v.png)\n\n我们从上图可以看到，大众点评的地址是加密的，所以我们不能直接从html中获取\n\n## 发现\n\n发现上图 `.num` 类和 `.address` 类用的 `ba****.css`, 打开此css发现这些类使用的字体文件都是不同的，看下图：\n\n![1588919508_1_.jpg](https://i.loli.net/2020/05/08/7VHbsvjQtkfDgal.png)\n\n> 我们可以下载FontCreator 打开上图链接的.woff, 或者用百度的FontEditor(之前可以用，后来不行了)\n\n![1588921914_1_.jpg](https://i.loli.net/2020/05/08/AbBZvV9gKpExaFW.png)\n\n我们用`北`做例子，在大众点评上加密的字符是 ``, 我们发现.woff 文件用forntCreator 上面的16进制码是 `efa8`, \n\n## js 解析字体文件工具 fonteditor-core\n\n它会把.woff 文件中某个 字体转成十进制然后一一对应起来\n\n```js\nvar Font = require('fonteditor-core').Font;\nvar fs = require('fs');\nvar buffer = fs.readFileSync('4.woff');\n// 不加这个文件会报错  \n// https://cdn.bootcdn.net/ajax/libs/pako/1.0.10/pako_inflate.min.js\nlet inflate_daddy = require(\"./pako_inflate.min\"); \n\nvar font = Font.create(buffer, {\n    type: 'woff', // support ttf,woff,eot,otf,svg\n    inflate: inflate_daddy.inflate\n});\nconsole.log(font.data.cmap);\n\n// font.data.cmap \n// key值代表十进制, value代表的是第几个字体\n{\n    '120': 1,\n    '57346': 81,\n    '57348': 275,\n    ...\n    '61352': 125\n}\n```\n\n上面`北`字为例，加密字符 ``,转成十进制就是 `61352` 也就是在.woff 文件第`125`个字,但机器是不知道上面第125个字是什么字，所以我们做一个.woff文件的所有字体人工抽取出来然后一一对应就好了\n\n```js\nwoffString = `\n    1234567890店中美家馆\n    小车大市公酒行国品发电金心业商司\n    超生装园场食有新限天面工服海华水\n    房饰城乐汽香部利子老艺花专东肉菜\n    学福饭人百餐茶务通味所山区门药银\n    农龙停尚安广鑫一容动南具源兴鲜记\n    时机烤文康信果阳理锅宝达地儿衣特\n    产西批坊州牛佳化五米修爱北养卖建\n    材三会鸡室红站德王光名丽油院堂烧\n    江社合星货型村自科快便日民营和活\n    童明器烟育宾精屋经居庄石顺林尔县\n    手厅销用好客火雅盛体旅之鞋辣作粉\n    包楼校鱼平彩上吧保永万物教吃设医\n    正造丰健点汤网庆技斯洗料配汇木缘\n    加麻联卫川泰色世方寓风幼羊烫来高\n    厂兰阿贝皮全女拉成云维贸道术运都\n    口博河瑞宏京际路祥青镇厨培力惠连\n    马鸿钢训影甲助窗布富牌头四多妆吉\n    苑沙恒隆春干饼氏里二管诚制售嘉长\n    轩杂副清计黄讯太鸭号街交与叉附近\n    层旁对巷栋环省桥湖段乡厦府铺内侧\n    元购前幢滨处向座下臬凤港开关景泉\n    塘放昌线湾政步宁解白田町溪十八古\n    双胜本单同九迎第台玉锦底后七斜期\n    武岭松角纪朝峰六振珠局岗洲横边济\n    井办汉代临弄团外塔杨铁浦字年岛陵\n    原梅进荣友虹央桂沿事津凯莲丁秀柳\n    集紫旗张谷的是不了很还个也这我就\n    在以可到错没去过感次要比觉看得说\n    常真们但最喜哈么别位能较境非为欢\n    然他挺着价那意种想出员两推做排实\n    分间甜度起满给热完格荐喝等其再几\n    只现朋候样直而买于般豆量选奶打每\n    评少算又因情找些份置适什蛋师气你\n    姐棒试总定啊足级整带虾如态且尝主\n    话强当更板知己无酸让入啦式笑赞片\n    酱差像提队走嫩才刚午接重串回晚微\n    周值费性桌拍跟块调糕\n    `\n```\n\n以上获取`北`字 就是 `woffString[font.data.cmap['61352']] => woffString[125]`\n\n## 字符串转进制\n```js\nfunction stringToEntity(str, radix = 10) {\n    let arr = str.split('')\n    let tmp = arr.map(item => item.charCodeAt(0).toString(radix) ).join('');\n    // console.log(`'${str}' 转实体为 '${tmp}'`)\n    return tmp\n}\n```\n\n以上就是解密全过程\n\n\n\n\n\n\n\n","tags":["js"]},{"title":"webpack+vue+electron开发环境搭建","url":"/2020/04/23/webpack-vue-electron开发环境搭建/","content":"\n## 设置electron 安装路径\n\n`npm set config ELECTRON_MIRROR=\"https://npm.taobao.org/mirrors/electron/\"`\n\n## 核心思想\n\nelectron 分主进程和渲染进程，在这里，我们直接把主进程看成是**创建主体窗口**，而渲染进程看成是 **页面的渲染**。\n\n* 渲染进程当成一般的webpack配置即可， `vue-loader, less-loader, style-loader`等等照常配置即可,\n* 主进程： 主进程我们只当他是创建主体窗口的，那么我们只需要配置 `babel-loader`,\n* 当主进程发生改变时，那么就**重启窗口**， 简单来说就是直接使用 `electron .`这个命令， 但是我们使用nodejs 的方式启动\n* 当渲染进程文件发生改变时，我们的electron 也跟着刷新，那么就要使用`devServer + webpack-hot-middleware`, 但我觉得直接使用`devServer` 也没问题\n* 在主进程中要监听localhost的变化 `win.loadURL(\"http://localhost:9000\")`,才能达到 实时更新\n\n\n## 配置渲染进程\n\n> 我们根据 `vue-cli` 目录文件去配，`vue-cli` \n\n渲染进程的目录路径：`src/render/` 目录下\n\n```js\n├─assets      // 资源文件\n├─components  // vue 组件\n├─pages       // 路由页面\n├─App.vue     // vue 主体文件\n├─index.js    // 入口文件\n└─router.js   // 路由文件，配置路由的\n```\n\n渲染进程webpack 配置： \n\n```js  \n// configs/webpack.render.config.js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst VueLoaderPlugin = require('vue-loader/lib/plugin');\nconst webpack = require('webpack')\n\n// loader 自行npm install\nmodule.exports = {\n    mode: 'development',\n    entry: './src/render/index.js',\n    devtool: 'eval-source-map', \n    // target: 'electron-renderer', // 加了反而报错\n    output: {\n        filename: '[name].js',\n        path: path.resolve(__dirname, '../dist/render')\n    },\n    module: {\n        rules: [\n\t\t\t// babel-loader, less-loader 等等\n            {\n                test: /\\.vue$/,  // 编译vue\n                loader: 'vue-loader'\n            }\n            // ... 图片字体文件等等的文件配置\n        ]\n    },\n    plugins: [\n        new VueLoaderPlugin(), // 编译vue\n        new HtmlWebpackPlugin({template: path.resolve(__dirname, '../public/index.html')}),\n        new webpack.HotModuleReplacementPlugin()\n    ],\n    // 往后devServer 会改成nodejs 的方式启动\n    devServer: {\n        contentBase: path.resolve(__dirname, '../dist/render'),\n        hot: true,\n        compress: true,\n        port: 9000,\n        open: true\n    }\n}\n```\n\n要是执行命令`webpack-dev-server --config ./configs/webpack.dev.config.js` 没报错，那没渲染进程基本没问题了，另外我们往后 会把**devServer 改成 nodejs的方式启动**\n\n## 配置主进程\n\n我们会把主进程的js 放入`src/main/`目录下， 但其实只有index.js\n\n```js\nconst path = require('path');\n\nmodule.exports = {\n    entry:  './src/main/index.js',\n    mode: 'development',\n    output: {\n        filename: '[name].js',\n        path: path.resolve(__dirname, \"../dist/main\")\n    },\n    target: 'electron-main'\n}\n```\n\n## 用nodejs 的方式启动这些配置\n\n```js\n// 渲染进程\n//https://webpack.docschina.org/guides/development\n// 因为webpack-hot-middleware 只能检测到文件发生变化时重新加载，但不能刷新浏览器，所以我们加入 webpack-dev-server， 让浏览器自动刷新\nfunction createRendererServer() {\n\treturn new Promise((resolve, reject) => {\n\t\t// 直接添加 wenpack-hot-middleware/client.js, \n\t\trendererConfig.entry = ['webpack-hot-middleware/client?noInfo=true&reload=true'].concat(rendererConfig.entry);\n\n\t\tconst compiler = webpack(rendererConfig);\n\t\thotMiddleware = webpackHotMiddleware(compiler, {\n\t\t\tlog: false,\n\t\t\theartbeat: 2500\n\t\t})\n\n\t\tcompiler.hooks.done.tap('done', stats => { console.log(\"完成\");})\n\n\t\tconst server = new webpackDevServer(compiler, {\n\t\t\tcontentBase: path.resolve(__dirname, '..'),\n\t\t\tquiet: true,\n\t\t\tbefore (app, ctx) {\n\t\t\t\t// express, 可获取 node 服务 app 实例，执行中间件操作\n\t\t\t\tapp.use(hotMiddleware)\n\t\t\t\tctx.middleware.waitUntilValid(() => {\n\t\t\t\t\tresolve()\n\t\t\t\t})\n\t\t\t}\n\t\t});\n\n\t\tserver.listen(9000);\n\t})\n\t\n}\n```\n\n```js\n// 因为主进程的index.js 文件不常改，我们直接使用watch 的方式，监听文件变化，文件一变化，那么我们就重新启动electron\nfunction createMainServer() {\n\treturn new Promise((resolve, reject) => {\n\t\tconst compiler = webpack(mainConfig);\n\t\t\n\t\t// 主进程监听文件变化， webpack watch 模式，那么就从起electron, 即调用electron .\n\t\tcompiler.watch({\n\t\t\taggregateTimeout: 300,\n\t\t\tpoll: 1000\n\t\t}, (err, stats) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (electronProcess && electronProcess.kill) {\n\t\t\t\tmanualRestart = true\n\t\t\t\tprocess.kill(electronProcess.pid)\n\t\t\t\telectronProcess = null\n\t\t\t\tstartElectron() // 用 nodejs spawn的方式启动electron , 启动加载的js 应该是在 /dist/main/main.js ,该方法就不写了\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tmanualRestart = false\n\t\t\t\t}, 5000)\n\t\t\t}\n\t\t\tresolve()\n\t\t})\n\t})\n}\n```\n\n我们用`Promise.all([createRendererServer(), createMainServer()])` 这两个都编译好之后再启动electron `.then(() => startElectron())`;\n\n## 效果\n\n<!-- ![bmoda-3cjoy.gif](https://i.loli.net/2020/04/23/YGbzdXaZVy2ARvi.gif) -->\n<a class=\"group\" rel=\"group1\" href=\"https://i.loli.net/2020/04/23/YGbzdXaZVy2ARvi.gif\">\n    <img src=\"https://i.loli.net/2020/04/23/YGbzdXaZVy2ARvi.gif\" />    \n</a>\n\n## 最后\n\n浏览器打开`localhost:9000` 一样也可以，另外就是 nwjs 的开发环境也大致一样吧\n","tags":["electron","vue","webpack"],"categories":["electron","vue","webpack"]},{"title":"长列表实践","url":"/2020/04/15/长列表实践/","content":"\n## 场景描述\n\n当在一些展示性页面的时候，会经常性使用一些列表进行渲染，但是当数据太多的时候，dom 节点不断累加，会造成滚动时页面的卡顿，影响用户体验\n\n解决方案：虚拟列表\n\n## 核心思想\n\n**虚拟列表只对可视区域中的列表进行渲染, 滚动时改变渲染的数组**\n\n\n\n## 子列表元素高度固定时\n\n* 整个列表高度固定\n* 可视区域渲染条数固定\n* 可根据滚动距离，得到渲染的数组\n* 移动可视区域到滚动的距离位置\n\n当有10000条数据，屏幕高度为500时, 子元素高度为50，那么可渲染区域应该渲染为10条数据, 整个列表高度为50 * 10000\n![JCDFaV.jpg](https://s1.ax1x.com/2020/04/15/JCDFaV.jpg)\n\n当我们发生滚动的时候，比如滚动了150px，那么我们可见区域的渲染列表就变成了下图 第4项到第13项了 \n![JCDiV0.jpg](https://s1.ax1x.com/2020/04/15/JCDiV0.jpg)\n### 结构\n\n```html\n<div className={styles.page} style={{height: pageHeight + \"px\"}} ref=\"container\">  {/* 屏幕高度 */}\n    <div className={styles.infiniteListGhost} style={{height: infiniteListGhostHeight + \"px\"}} ></div> {/* list 高度 */}\n    <div className={styles.renderList} style={{ transform: `translate3d(0, ${translate}px, 0)`}} > {/* 可见list 高度 */}\n        {\n            renderList.map((item, index) => {\n                return (\n                    <div className={styles.item} key={index} style={{height: itemHeight + \"px\"}}> {/* 子列表元素高度 */}\n                        { item }\n                    </div>\n                )\n            })\n        }\n    </div> \n</div>\n```\n\n```less\n.page {\n    overflow-y: auto;\n    width: 100%;\n    position: relative;\n\n    .infiniteListGhost {\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        z-index: -1;\n    }\n\n    .renderList {\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        z-index: 1;\n\n        .item {\n            color: #000;\n            border: 1px solid #ccc;\n            display: flex;\n            flex-direction: row;\n            align-items: center;\n            justify-content: center;\n        }\n    }\n}\n```\n\n> 子列表项的高度为 itemHeight = 50, 滚动高度 为 scrollTop\n\n* 屏幕高度： `pageHeight = document.body.clientHeight`;\n* 列表高度： `infiniteListGhostHeight = list.length * itemHeight`\n* 渲染条数： `const itemCount = Math.ceil(clientHeight / itemHeight );`\n* startIndex: `startIndex = Math.floor(scrollTop / itemHeight)`\n* endIndex: `endIndex = startIndex + itemCount`\n* 列表渲染数组： `list.slice(startIndex, endIndex)`;\n* startOffset: `startOffset = scrollTop - (scrollTop % itemHeight)`; 滚动倍数\n\n\n```js\nstate = {\n    pageHeight: 0, //屏幕高度\n    infiniteListGhostHeight: 0, // 列表总高度\n    renderList: [], // 渲染列表\n    itemHeight: 80,\n    translate: 0, // 可视区域偏移\n}\n\ncomponentDidMount() {\n    const { itemHeight } = this.state\n    this.refs.container.addEventListener('scroll', this.handleScroll);\n    const clientHeight = document.body.clientHeight;\n    const itemCount = Math.ceil(clientHeight / itemHeight );\n\n    this.setState({\n        pageHeight: clientHeight,\n        infiniteListGhostHeight: result.length * itemHeight,\n        renderList: result.slice(0, itemCount)\n    })\n}\n\ncomponentWillUnmount() {\n    this.refs.container.removeEventListener('scroll', this.handleScroll);\n}\n\nhandleScroll = (e) => {\n    const { itemHeight, pageHeight, infiniteListGhostHeight } = this.state\n    const scrollTop = e.srcElement.scrollTop || e.srcElement.scrollTop;\n    // 从scrollTop 计算出偏移startIndex\n    const itemCount = Math.ceil(pageHeight / itemHeight ); //可视区域高度 / 子项高度 = 子项个数\n    const startIndex = Math.floor(scrollTop / itemHeight);\n    const endIndex = startIndex + itemCount; \n    const list = result.slice(startIndex, endIndex ); \n    const startOffset = (scrollTop - (scrollTop % itemHeight));\n    this.setState({\n        translate: startOffset,\n        renderList: list\n    })\n}\n```\n\n\n\n## 效果\n\n![e0r5u-2k2gm.gif](https://i.loli.net/2020/04/15/wyAF5uhqMbiDB4N.gif)\n\n可以看出，只渲染可视区域内的数据\n\n\n## 设置上下缓存区\n\n> 当滚动太块的时候，往下会有一段空白， 往上也有一段空白，那么这时候设置上下缓冲区可以解决此问题\n\n```js\nhandleScroll = (e) => {\n    // ....\n    const above = Math.min(startIndex, itemCount);\n    const below = Math.min(result.length - endIndex, itemCount);;\n    const start = startIndex - above;\n    const end = endIndex + below;\n    const list = result.slice(start, end); // 注意此时list的渲染会加上缓存区，所以导致了偏移向下了，但实际上应该减掉 上方缓冲区才能渲染中间的\n    const startOffset = (scrollTop - (scrollTop % itemHeight) - above  * itemHeight); \n} \n```\n\n此时效果：\n\n![ayn6z-l262n.gif](https://i.loli.net/2020/04/16/u1KeX9xdiwYQTRA.gif)","tags":["react"],"categories":["react"]},{"title":"导航栏吸顶","url":"/2020/04/09/导航栏吸顶/","content":"\n\n## 导航栏吸顶\n\n> 当页面滚动超过导航栏时，导航栏依附固定在页面顶端\n\n下面介绍两种方式吧， 一种是 `position: sticky`, 另一种是`getBoundingClientRect()`\n\n## position: sticky 实现\n\n```css\n.stickyPostion {\n    postion: sticky;\n    top: 0;\n}\n```\n\n使用条件：\n* 父元素不能`overflow:hidden`或者`overflow:auto`属性。\n* 必须指定`top`、`bottom`、`left`、`right`4个值之一，否则只会处于相对定位\n* 父元素的高度不能低于sticky元素的高度\n* sticky元素仅在其父元素内生效\n\n### sticky 坑\n\n* 兼容性不太好\n* 不能触发 `BFC`\n\n\n## getBoundingClientRect()\n\ngetBoundingClientRect用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。\n**getBoundingClientRect是DOM元素到浏览器可视范围的距离（不包含文档卷起的部分）**。\n\n* 获取当前 nav 到浏览器顶端的距离。\n* 直接监听scroll 事件，\n* **用div包裹住nav导航栏，我们只需要获取当前div到顶端的距离即可，等到时 top值为0的时候，设置子级的position:fixed, 还原只需取消掉子级的position即可**\n  * 如果没有用div 包裹 nav导航栏的话，等top 值为0，就无法还原了，position 一直为fix, getBoundingClientRect.top值一直为0;\n\n结构应该如下：\n```html\n<div ref={this.stickyRef} id=\"sticky\">\n    <div className={isFixed ? styles.fix : styles.static}> // 这个为nav\n        <div>吸顶效果</div>\n    </div>\n</div>\n```\n\n```js\ncomponentDidMount() {\n    const top = this.stickyRef.current.getBoundingClientRect().top;\n    this.setState({\n        initPostionTop: top\n    })\n    window.addEventListener('scroll', this.handleScroll);\n}\n```\n\n```js\nhandleScroll = (e) => {\n    const { isFixed, initPostionTop } = this.state\n    const scrollTop = e.srcElement.body.scrollTop || e.srcElement.documentElement.scrollTop;\n    // 这里做了个优化，防止频繁setState, 如果一开始为吸顶，以及滚动距离大于 nav 到顶部的距离的时候，\n    // 或者 （不吸顶同时当前滚动距离小于nav到顶部的距离时)我们操作\n    if(isFixed && scrollTop >= initPostionTop || !isFixed && scrollTop <= initPostionTop) {\n        return ;\n    }  else  {\n        this.setState({\n            isFixed: scrollTop > initPostionTop\n        })\n    }\n}\n\n```\n\n## 小程序 (我使用的是Taro)\n\n> 小程序不支持 `window.addEventListener('scroll', this.handleScroll);`，只有`onPageScroll`\n\n下面是官方说明\n**注意：请只在需要的时候才在 page 中定义此方法，不要定义空方法。以减少不必要的事件派发对渲染层-逻辑层通信的影响。注意：请避免在 onPageScroll 中过于频繁的执行 this.setState() 等引起逻辑层-渲染层通信的操作。尤其是每次传输大量数据，会影响通信耗时。**\n\ntaro获取节点有点坑\n\n```js\ncomponentDidMount() {\n    // 注意this.$scope\n    const query = Taro.createSelectorQuery().in(this.$scope);\n    query.select('#sticky').boundingClientRect((rect) => {\n        this.setState({\n            initPostionTop: rect.top\n        })\n    }).exec();\n}\n```\n\nonPageScroll 代码基本一样\n\n\n## 坑\n\n* 这种方式有个坑，当吸顶的一瞬间，会发生抖动，这是因为 `position`变成`fixed` 的时候脱离了文档流。\n解决方案是 在`postion:fixed;`的元素里添加`transform: translateZ(0);`,我想应该是开启gpu 渲染，所以变得顺滑了吧\n\n## 关于优化\n\n> h5 优化，可以用另一种方式，就是用 监听滚动的时候使用 节流， 可以用 lodash.throttle\n\n`window.addEventListener('scroll', _.throttle(self.handleScrollThree, 50));`\n\n## 效果\n\n![b8827be2b9af0f70b7b9e3e9838e30e6.gif](https://i.loli.net/2020/04/10/a4kQYARnKp3oIsy.gif)","tags":["js"],"categories":["js"]},{"title":"一行代码使网站变灰","url":"/2020/04/08/一行代码使网站变灰/","content":"\n## 先看看效果吧\n\n![百度](https://i.loli.net/2020/04/08/Lm6iCbhrZYEJKPR.jpg)\n\n\n## 分析\n\n> 网站变灰用到的是 css3 的 filter 属性，其实就是滤镜\n\n## 代码\n\n```css\nhtml {\n    filter: grayscale(0.95) \n}\n```\n\nfilter 还能做 高斯模糊，色相旋转， 色相透明，调整对比度等等，\n\n```\nfilter: blur(5px); // 高斯模糊\nfilter: contrast(200%); // 调整对比度\nfilter: opacity(30%); // 调整透明度\n```\n","tags":["css"],"categories":["css"]},{"title":"Hello World","url":"/2020/04/08/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]