{"meta":{"title":"Chow Bill's Blog","subtitle":"","description":"","author":"Chow Bill","url":"http://yoursite.com","root":"/"},"pages":[{"title":"力扣","date":"2020-04-08T08:09:43.000Z","updated":"2020-05-29T15:40:08.093Z","comments":true,"path":"algorithm/index.html","permalink":"http://yoursite.com/algorithm/index.html","excerpt":"","text":""},{"title":"category","date":"2020-04-08T08:12:55.000Z","updated":"2020-04-11T02:59:36.898Z","comments":true,"path":"category/index.html","permalink":"http://yoursite.com/category/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-07-27T03:03:29.000Z","updated":"2020-08-29T07:00:03.370Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于博客我使用的主题是Chic, 该主题没有搜索，所以我自定义了一个搜索，具体操作可以看看hexo自定义案例 另外项目搭建在 github 和 gitee 关于我 既然相遇是偶然，又何必在意分别时的突然 喜欢看电影(强推 《毛骗》)，听歌，写代码, 看看书 坚持每天一道力扣题 QQ: 735051883 wechat：735051883 我关注的技术博客 creeperyang careteenL/blog PDKSophia/blog.io 前端内参 阿里大佬 js、es6专题 九部知识库 canvas yck js-33个概念 前端伪大叔 面试题 js/css/html等等面试题汇总 【前端进阶】 JavaScript Questions js-react-css-html-interview-question Weekly-FE-Interview 源码系列 vue react 正则表达式 正则表达式 regexr-cn 正则练习网站 书籍 《JavaScript 高级程序设计 - 第三版》 《深入浅出webpack》 写个脚本把弹出框删除即可继续阅读 《剑指offer》 微信读书 《你不知道的Javascript》 微信读书 之前在github找到的，后来又没找到"},{"title":"tag","date":"2020-04-08T08:09:43.000Z","updated":"2020-04-11T02:59:36.899Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"路径总和 II","slug":"路径总和-II","date":"2020-09-26T05:32:57.000Z","updated":"2020-09-26T05:47:10.276Z","comments":true,"path":"2020/09/26/路径总和-II/","link":"","permalink":"http://yoursite.com/2020/09/26/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/","excerpt":"","text":"路径总和 II 题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例给定如下二叉树，以及目标和 sum = 22 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回 [ [5,4,11,2], [5,8,4,5] ]题目分析其实这道题跟路径总和这道题很相似 其实就是将每次遍历的数放到 prefix 中，判断当前 节点是否有子节点 还有 sum - value === 0, 是的话，放入到 res 有 左节点 进入递归 有 右节点 进入递归 实现/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {number} sum * @return {number[][]} */ var pathSum = function(root, sum) { let res = []; let prefix = [] if(!root) { return res } dfs(root, sum, res, prefix); return res; }; var dfs = function(root, sum, res, prefix) { const value = root.val; const remain = sum - value; // 如果叶子节点都没有而且 sum - value == 0, 那么我们将prefix 加进数组 if(!root.left &amp;&amp; !root.right &amp;&amp; remain === 0) { res.push([...prefix, value]) return ; } // 没有子节点 且 remain !== 0 那就停止递归 if(!root.left &amp;&amp; !root.right &amp;&amp; remain !== 0) { return; } // 有左子节点 if(root.left) { dfs(root.left, remain, res, [...prefix, value]) } // 有右子节点, 进入递归 if(root.right) { dfs(root.right, remain, res, [...prefix, value]); } } 总结像这种需要保留 状态集的可以用prefix 装着，最后当符合条件的时候再 把 prefix 装到 result","categories":[],"tags":[{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"algorithm-深度搜索优先","slug":"algorithm-深度搜索优先","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E4%BC%98%E5%85%88/"}]},{"title":"面试总结","slug":"面试总结","date":"2020-09-10T10:37:32.000Z","updated":"2020-09-26T06:38:30.042Z","comments":true,"path":"2020/09/10/面试总结/","link":"","permalink":"http://yoursite.com/2020/09/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"vdom将多次dom修改的结果一次性更新到页面上，从而减少了页面的渲染次数，减少了修改dom之后的回流与重绘，提高了渲染性能VDOM的厉害之处不在于他运行有多快，而在于它在不需要人工优化的情况下，提供一个过得去的性能优化 说一说之前的面试体验吧 有一些纯属浪费时间，技术栈不太符合的也叫你过去面试，以后需要在先问技术栈再决定去不去面试，不然把自己搞的又累又浪费时间 面试本来就是双向选择，所以对面试官不要怂，说不定他比你还垃圾，毕竟面试造火箭，工作拧螺丝 经过这几轮面试， 主要可能问到的是 算法（排序， 动态规划）， react 源码（fiber, react 事件原理, 时间片（time slicing）， setState 在setTimeout 执行为什么是同步的, hook 实现原理也就是闭包， hook ref.current）(前端面试星球小程序有答案) react diff 算法 分3种，1 tree duff 2 component diff 3 element diff 网络问题 （tcp/ip, https, http1.0 与 http 1.1） tcp/ip 三次捂手， 四次挥手 https 基于ssl /tls 对称加密（简单说就是把各自秘钥传给对方），非对称加密 http1.0（一个http 请求连一个tcp, 所以时间耗在3次握手，4次回收）, http 1.1（增加 keep-alive）, http2.0 (头部压缩，二进制流，帧中有报文信息，通过排序重新组合还原报文) 的区别 nodejs (中间件) 插件 umi 底层， 约定式路由实现， dva， cli 集合 （webpack, ssr， UI库） 等等是怎么实现的 设计模式 （工厂， 单例， 观察者模式， 发布订阅） 说一说未来 针对算法 动态规划，DFS, BFS, 二分法，链表， 二叉树， react 源码，继续深入，这次要先看结构，再深入源码 vue 3.0 原理， 深入学习vue生态 （vuex, vue-router, echart） 图表实现 （canvas， three.js） nodejs 一个后端 语言 nodejs / python 书 设计模式 红宝书 图解http 学习本就是输入输出的事情， 学是输入，教别人是输出，多记录多回顾","categories":[],"tags":[]},{"title":"手写源码系列","slug":"手写源码系列","date":"2020-09-08T13:03:38.000Z","updated":"2020-09-26T04:20:54.744Z","comments":true,"path":"2020/09/08/手写源码系列/","link":"","permalink":"http://yoursite.com/2020/09/08/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/","excerpt":"","text":"防抖function debound(fn, wait) { let time; return function(...args) { if(time) { clearTimeOut(time) } time = setTimeOut(() => { fn.apply(this, args) }, wait) } } 节流节流的意思 是在单位时间内只执行一次 function throttle(fn, wait) { let time = null; return function(...args) { if(!time) { // 当前没有事件 time = setTimeOut(() => { time = null; fn.apply(this, args) }, wait) } } } promise参考链接","categories":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"webpack梳理","slug":"webpack-配置梳理","date":"2020-09-05T04:18:33.000Z","updated":"2020-09-06T03:55:45.344Z","comments":true,"path":"2020/09/05/webpack-配置梳理/","link":"","permalink":"http://yoursite.com/2020/09/05/webpack-%E9%85%8D%E7%BD%AE%E6%A2%B3%E7%90%86/","excerpt":"","text":"关于webpackwebpack 其实就是一个打包工具， 他可以把css, js, 图片等等的东西都打包成一个bundle，从entry开始递归分析他的依赖图，把应用到的每一个模块打包成一个或多个bundle webpakc 主要依赖下面几个配置 entry: 主入口文件 output: 输入文件的位置 modules: 里面配置的是loader， 我们可以想象loadder 为一名翻译官，把各种类型文件都翻译成浏览器可以识别的东西 plugins: 插件，我觉得webpack 的强大之处在于他的插件，plugin 可以针对在webpack不同的时期做不同的工作，比如CleanWebpackPlugin可以在打包之前删除清理指定目录 webpack 基础配置const path = require('path'); export default { entry: './src/index.js', // 入口文件 output: { filename: '[name].js', path: path.resolve(__dirname, 'dist'), }, resolve: { modules: ['node_modules'], // 告诉 webpack 解析模块时应该搜索的目录。 // 配置别名 alias: { '@': path.resolve(__dirname, 'src'), // 指定src的别名为 ‘@’ }, ententions: ['.js', '.css'], // 添加文件猴嘴 }, // 定义开发环境下的webpack-dev-server 其实就是动态更新 // 此时没有加载 HotModuleReplacementPlugin 的时候是通过loaction.reload（）重新加载网页的，但有个缺点就是不能记录状态 devServer：{ contentBase: path.resolve(__dirname, 'dist'), open: true, port: 8000, hot: true }, treeShaking: true, // 这里表示将没用过的代码自动删除掉 optimization：{ splitChunks: { cacheGroups: { vendor: { test: /node_modules/, priority: 1, // 数字越大，优先级越高 minChunks: 2, // 表示至少有两个js同事引用的时候，就会打包成vendor。js minSizes: 0, // 表示最小的大小 } } }, }, modules: { noParse: /jquery/, // webpack 优化， 不去递归jquery的依赖库 rules: [ { test: /\\.css$/, use: [ // 请记住loader 的运行顺序是从下到上，从右到左， // 另一种模式是内敛模式， import Styles from 'style-loader!css-loader?module!./styles.css', 忠中模式通过 ! 分割loadder， // 'style-loader!css-loader?module!./styles.css'.split(\"!\") => [\"style-loader\", \"css-loader\"] { loader: 'style-loader' }, { loader: 'css-loader', options: { modules: true } } ] }, { test: /\\.js$/, exclude: /(node_modules|bower_components)/, // 如果使用happypack的话，多线程打包，此时下面就要修改该成 // use: 'Happypack/loader?id=js' use: { loader: 'babel-loader', option: { cacheDirectory: true, // 开启js 打包优化 presets: ['@babel/preset-env', '@babel/preset-react'], plugins: [require('@babel/plugin-transform-object-rest-spread')] }, } } ] }, mode: 'development', // 指定环境， plugins: [ // 编译的时候指定全局变量，我们可以根据这个去定义当前环境是开发环境还是线上环境，定义不通的行为，比如url new webpack.DefinePlugin({ PRODUCTION: JSON.stringify(true), // 此时传过去的 PRODUCTION 是 字符串 “true” VERSION: JSON.stringify(\"5fa3b9\"), // }), // 多线程打包, 要是对css也启动多线程的话，再创建一个happypack， id为css new Happypack({ id: 'js', use: [{ loader: 'babel-loader', option: { cacheDirectory: true, // 开启js 打包优化 presets: ['@babel/preset-env', '@babel/preset-react'], plugins: [require('@babel/plugin-transform-object-rest-spread')] }, }] }), // ignorePlugin， 针对某个包的依赖不进行打包，比如moment， locale 是moment的语言包，要是我们只使用zh-cn 那么我们可以忽略掉其他，所以此时忽略掉locale new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/), // 下面是热更新 new webpack.NamedModulesPlugin(), // 告诉webpack 哪个模块更新了 new webpack.HotModuleReplacementPlugin(); // 进行热更新 ] } 热更新import test from './test'; if(module.hot) { module.hot.accept('./test', () => { console.log('文件已更新'); require('./test'); }) } 我们总结一下上面关于打包优化的几种方式吧 配置resolve 减少目录的搜索路径 同样的在loader 中设置 include 和 exclude 指定loader 编译的目录 设置modules 下的 noParse属性， 这个可以在打包的时候不检查某js 的依赖，这样就可以减少打包时间了 配置DllPlugin 用动态链接库的形式打包，这样的话会根据目录下的manifest.json 进行二次打包， 二次打包不会再对已生成的动态链接库进行打包 使用happyPack 用多线程打包 tapablewebpack 本质上是一种事件流机制，它的工作流程就是把各个插件串联起来， 他的核心就是tapable, tapable 有点像nodejs 的event库， 就是观察者模式 先来看看一个简单的events 库 class EventBus { constructor() { this.maps = {} } on(name, fn) { this.maps[name] = fn; } fire(name, data) { this.maps[name] &amp;&amp; this.maps[name](data); } } // 测试 const eventBus = new EventBus(); eventBus.on(\"click\", (data) => { console.log(\"click\", data) }) eventBus.fire(\"click\", {a: 1, b: 2}) 简单的观察者模式发布订阅其实很简单， 我可以想象成天文台， 当温度改变时， 天文台的数据改变（changes）的时候，我们用户需要做什么，他下雨了，我们需要收衣服， 被观察者是 天文台， 观察者 是我们用户， 具体做法是我们要收衣服， 就是对应下面的update， 简单说就是具体的做法就是观察者了 class Subject { constructor() { this.watchers = [] } addWatch(watcher) { console.log(this.watcher) this.watchers.push(watcher) } removeWatcher(watcher) { let index = this.watchers.indexOf(watcher); if(index > -1) { this.watchers.splice(index, 1) } } notify() { this.watchers.forEach((watcher) => watcher.update()) } } class Watcher { subscribeTo(subject) { subject.addWatch(this); } update() {} } let subject = new Subject() let watcher = new Watcher() watcher.update = function() { console.log('observer update') } watcher.subscribeTo(subject) //观察者订阅主题 let watcher2 = new Watcher() watcher2.update = function() { console.log('我是另一个观察者，我要做其他事情') } watcher2.subscribeTo(subject) subject.notify() 实现 SyncHook我们以上面的例子，实现一个SyncHook class SyncHook { constructor(args) { this.tasks = [] } // 绑定时间 tap(name, fn) { this.tasks.push(fn) } // 运行函数, 在tapabel call(...args) { this.tasks.forEach((task) => task(...args)); } } let hook = new SyncHook(['name']) // ['name'] 指的是我在创建hook的时候， 我tap需要传递的参数 hook.tap(\"test\", (name) => { console.log('test', name) }) hook.tap(\"test2\", (name) => { console.log(\"test2\", name) }) hook.call(\"hello\"); // 这里的hello 对应的是上面的name webpack 原理webapck其实就是自己实现了一个require方法，这里需要对AST进行一部分的了解， AST就是抽象语法树， 简单说就是将 js 转换成 语法树，转换成 方法， 变量等等的属性 我们看看AST 的步骤 AST 将 js 转换成 语法树 修改语法树的值 将 AST 转换成浏览器可以识别的 语法 AST 依赖包 babylon 将 源码 解析成 AST(抽象语法树) @babel/traverse 遍历 AST 中的节点 @babel/types 替换 AST 节点 @babel/generator 将替换的结果生成成js 我们想想webpack 的运行过程， 我们首先配置 webpack.config.js， 然后运行的是 webpack --config webpack.config.js 然后webpack 会根据 entry入口文件进行分析，对它进行AST解析， 如果entry入口文件还有require, 那么继续进行依赖遍历。 loader其实loader 就是一个方法，我们看两个例子, 一个是less-loader, 另一个是style-loader其中 loader-utils 获取loader 的参数就是 loader 的 options less-loader// less-loader /** * 我们less-loader 当然要转换成css，那么我们使用的是less.render * 下面使用less那么肯定需要 npm install less -=save-dev * @param {string} source 这里的source就是指 less源码 */ const loaderUtils = require('loader-utils'); function loader(source) { let css = \"\"; // loaderUtils.getOption(this) 可以拿到他的参数 less.render(source, (err, lessSource) => { css = lessSource.css }) return css; } style-loader/** * 我们style-loader 的作用是将css 写在html 的head 下面的style标签下 */ function loader(source) { let styles = ` const el = document.createElement(\"style\"); const css = ${source.replace(/\\s*/g, \"\")} el.innerHTML = css; document.head.appendChild(css); ` return styles } pluginwebpack 是基于tapable事件流， 你把 plugin 想象成在webapck 中不同的生命周期做不同的事情，我们看看webpack 的hooks吧 entryOption 入口hooks compile 编译时期 afterCompile 完成编译后 afterPlugins 插件完成编译后 run 运行 emit 生成编译文件时 done 执行完成 自定义pluginclass Plugin() { apply(compiler) { // 此时的compiler 是webpack实例 compiler.hooks.done.tap(\"run\", () => { console.log(\"此时是webpack 运行时运行的时间\") }) compiler.hooks.done.tap(\"name\", () => { console.log(\"此时是注册事件，指的是在整个wepack执行完成之后的回调函数\") }) } }","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"841. 钥匙和房间","slug":"841-钥匙和房间","date":"2020-08-31T07:32:23.000Z","updated":"2020-09-06T01:59:38.161Z","comments":true,"path":"2020/08/31/841-钥匙和房间/","link":"","permalink":"http://yoursite.com/2020/08/31/841-%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/","excerpt":"","text":"841. 钥匙和房间 题目描述简单说： 就是给定一个二维数组rooms， rooms[i] 代表的是房间，房间内有n把钥匙 rooms[i][j], 获得所有房间内的钥匙后能不能把房间都打开 示例1输入: [[1],[2],[3],[]] 输出: true 解释: 我们从 0 号房间开始，拿到钥匙 1。 之后我们去 1 号房间，拿到钥匙 2。 然后我们去 2 号房间，拿到钥匙 3。 最后我们去了 3 号房间。 由于我们能够进入每个房间，我们返回 true。 示例2输入：[[1,3],[3,0,1],[2],[0]] 输出：false 解释：我们不能进入 2 号房间。 分析方法一直接暴力破解， 就是遍历数组，把数组中的值放到 Set 里面，然后最后遍历一次状态数组即可 方法二用递归 建立状态机。 建立递归函数 当 当前房间的状态为 true 的时候，那么 表示这个房间已经进来过了，所以不用再继续遍历了 当 当前房间的状态为 false的时候，那么表示当前房间没去过，把当前房间设置为true, 然后遍历当前房间的钥匙，继续递归 最后，遍历上面的状态机，如果有一个为false, 那么返回false，只有全部为true才返回false 代码/** * @param {number[][]} rooms * @return {boolean} */ var canVisitAllRooms = function(rooms) { let length = rooms.length; let result = Array(length).fill(false); setStatus(result, rooms, 0); for(let i = 0; i &lt; result.length; i++) { if(!result[i]) { return false } } return true }; var setStatus = function(result, rooms, roomId) { if(result[roomId]) { return ; } const roomData = rooms[roomId]; result[roomId] = true for(let i = 0; i &lt; roomData.length; i++) { setStatus(result, rooms, roomData[i]) } }","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-深度遍历搜索","slug":"algorithm-深度遍历搜索","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2/"}]},{"title":"对antd-pro一些理解","slug":"对antd-pro一些理解","date":"2020-08-26T08:27:19.000Z","updated":"2020-09-07T06:08:28.165Z","comments":true,"path":"2020/08/26/对antd-pro一些理解/","link":"","permalink":"http://yoursite.com/2020/08/26/%E5%AF%B9antd-pro%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","excerpt":"","text":"umi文档 执行 npm create umi 创建 antd-pro 项目 路由整个 umi 建立的项目可以自定义路由，也可以约定式路由，我就直接对自定义路由展开配置可以写在 config/config.ts 下或者写在根目录下 .umirc.ts 的routes中 { path: '/', component: '../layouts/BlankLayout', routes: [ { path: '/', component: '../layouts/UserLayout', Routes: ['src/pages/Authorized'], authority: ['admin', 'user'], // 权限角色 routes: [ { name: '/test', icon: 'smile', path: '/test', component: './test', }, { name: '/test2', authority: ['admin', 'user'], // 权限角色 routes: [ { name: '', icon: 'smile', path: '/test2/step1' } ] } ], } } 侧边栏/导航栏注意：我们暂时不对它内置路由到底是怎么实现的，但我想的其原理就是对react-router进行配置吧 路由设置完之后对导航栏进行配置, 文档 另外umi文档中的插件 也是可以进行导航栏的废纸的 @ant-design/pro-layout文档 &lt;ProLayout // 这里的route是在上面配置自动获取的，不配置那么就不会显示在导航栏中 route={props.route} > &lt;/ProLayout> 权限说一下antd-pro的权限, 我们可以看到 utils/authority.ts, 作用是获取/设置localstorage中的用户角色，然后通过路由中的 Route跟authority 判断其是否有准入条件。 v4.1.0貌似有bug，不会经过pages/Authority.tsx判断权限 先通过 pages/Authority.tsx 文件判断用户登录以及权限路由 用户已登录， 获取当前location.pathname在路由表中的权限，一直向上找，跟localstorage获取的权限判断，没权限 跳转到 403 用户没登录，跳转登录页 然后再经过路由下的 Component, 或者说是他的Children 查看封装的 组件项目多次使用该组件， 使用方法如下： const notMatch = ( &lt;div>not Match&lt;/div> ) /** * @param {string | string[] | Promise&lt;boolean>} authority * @param { React.ReactNode } notMatch * */ &lt;Authorized authority={authorized!.authority} noMatch={noMatch}> {children} &lt;/Authorized> Authorized 实现// 此时的 RenderAuthorize 来自 src/Authorithy/index // 重新包装了一下Authority，使得 currentAuthority = ['admin', 'user'] 在整个周期都能使用 // getAuthority 就是获取当前权限 let Authorized = RenderAuthorize(getAuthority()); // 此时还是从新包装了一下Authorited RenderAuthorize const RenderAuthorize = renderAuthorize(Authorized); 返回闭包，同时导出CURRENT, 当前current 也就是 getAuthority()的值， 也可以理解成一个HOC吧 /** * use authority or getAuthority * @param {string|()=>String} currentAuthority */ function renderAuthorize(Authorized) { return function (currentAuthority) { if (currentAuthority) { if (typeof currentAuthority === 'function') { CURRENT = currentAuthority(); } if (Object.prototype.toString.call(currentAuthority) === '[object String]' || Array.isArray(currentAuthority)) { CURRENT = currentAuthority; } } else { CURRENT = 'NULL'; } return Authorized; }; } export { CURRENT } export default (Authorized) => renderAuthorize(Authorized); 这个组件逻辑很简单， 需要看check函数，传入的authority 是 [‘admin’] 为例子如果通过check 那么返回children, 否则返回 &lt;notMatch&gt; const Authorized: React.FunctionComponent&lt;AuthorizedProps> = ({ children, authority, noMatch = ( &lt;Result status=\"403\" title=\"403\" subTitle=\"Sorry, you are not authorized to access this page.\" /> ), }) => { const childrenRender: React.ReactNode = typeof children === 'undefined' ? null : children; // const dom = check(authority, childrenRender, noMatch); return &lt;>{dom}&lt;/>; }; 在来看看check函数 下面的CURRENT 就是上面的renderAuthorize 导出的CURRENT /** * @param {string| stirng[]} authority 这里的authority 就是 ['admin'], 也就是准入条件 * @param { React.ReactNode } target 也就是 children * @param { React.ReactNode } Exception notMatch */ function check&lt;T, K>(authority: IAuthorityType, target: T, Exception: K): T | K | React.ReactNode { return checkPermissions&lt;T, K>(authority, CURRENT, target, Exception); } 再来看看 checkPermissions 如果准入权限为空，那么直接渲染target 要是authority跟currentAuthority都是数组的时候，那看看有没有交集有交集那就返回target 要是authority为字符串，那么看看我们的current中有没有这个权限就可以了 要是authority为promise那么就进入promise的操作 要是authority为方法，那就执行一下， 参数为current /** * 通用权限检查方法 * Common check permissions method * @param { 权限判定 | Permission judgment } authority * @param { 你的权限 | Your permission description } currentAuthority * @param { 通过的组件 | Passing components } target * @param { 未通过的组件 | no pass components } Exception */ const checkPermissions = &lt;T, K>( authority: IAuthorityType, currentAuthority: string | string[], target: T, Exception: K, ): T | K | React.ReactNode => { // 没有判定权限.默认查看所有 // Retirement authority, return target; if (!authority) { return target; } // 数组处理 if (Array.isArray(authority)) { if (Array.isArray(currentAuthority)) { if (currentAuthority.some((item) => authority.includes(item))) { return target; } } else if (authority.includes(currentAuthority)) { return target; } return Exception; } // string 处理 if (typeof authority === 'string') { if (Array.isArray(currentAuthority)) { if (currentAuthority.some((item) => authority === item)) { return target; } } else if (authority === currentAuthority) { return target; } return Exception; } // Promise 处理 if (authority instanceof Promise) { return &lt;PromiseRender&lt;T, K> ok={target} error={Exception} promise={authority} />; } // Function 处理 if (typeof authority === 'function') { const bool = authority(currentAuthority); // 函数执行后返回值是 Promise if (bool instanceof Promise) { return &lt;PromiseRender&lt;T, K> ok={target} error={Exception} promise={bool} />; } if (bool) { return target; } return Exception; } throw new Error('unsupported parameters'); }; 登录组件pages/user/login 查看 index.tsx Login页面有一个 包裹着两个 &lt;Tab&gt;, &lt;Tab&gt;下面又是一下Input组件，只是被重新包装了 // 我们可以看出 UserName, Password 等等都是LoginForm导出的 const { Tab, UserName, Password, Mobile, Captcha, Submit } = LoginForm; 我们看下 Login 这个页面的大体结构 用一个&lt;LoginForm /&gt; 包裹着两个&lt;Tab&gt;, &lt;Tab&gt; 底下是登录按钮还有其他的登录方式 其中一个&lt;Tab&gt;对应的是账号密码登录， 另一个是短信验证码登录 下面的status, loginType 是 redux的状态，表示登录失败后会有报错信息 &lt;LoginForm&gt; 的 activeKey 只有两个 account, mobile 代表账号登录跟短信登录 &lt;LoginForm activeKey={type} onTabChange={setType} onSubmit={handleSubmit}> &lt;Tab key=\"account\" tab=\"账户密码登录\"> {status === 'error' &amp;&amp; loginType === 'account' &amp;&amp; !submitting &amp;&amp; ( &lt;LoginMessage content=\"账户或密码错误（admin/ant.design）\" /> )} &lt;UserName/> &lt;Password/> &lt;/Tab> &lt;Tab key=\"mobile\" tab=\"手机号登录\"> {status === 'error' &amp;&amp; loginType === 'mobile' &amp;&amp; !submitting &amp;&amp; ( &lt;LoginMessage content=\"验证码错误\" /> )} &lt;Mobile/> &lt;Captcha/> &lt;/Tab> &lt;div> &lt;Checkbox checked={autoLogin} onChange={(e) => setAutoLogin(e.target.checked)}> 自动登录 &lt;/Checkbox> &lt;a>忘记密码&lt;/a> &lt;/div> &lt;Submit loading={submitting}>登录&lt;/Submit> &lt;div className={styles.other}> 其他登录方式 &lt;AlipayCircleOutlined className={styles.icon} /> &lt;TaobaoCircleOutlined className={styles.icon} /> &lt;WeiboCircleOutlined className={styles.icon} /> &lt;Link className={styles.register} to=\"/user/register\"> 注册账户 &lt;/Link> &lt;/div> &lt;/LoginForm> 首先先创建一个 Context， 这个context 主要是给 &lt;LoginTab&gt; 使用的 LoginTab 实现简单看就是 // antd 官网 &lt;Tabs defaultActiveKey=\"1\" onChange={callback}> &lt;TabPane tab=\"Tab 1\" key=\"1\"> Content of Tab Pane 1 &lt;/TabPane> &lt;TabPane tab=\"Tab 2\" key=\"2\"> Content of Tab Pane 2 &lt;/TabPane> &lt;TabPane tab=\"Tab 3\" key=\"3\"> Content of Tab Pane 3 &lt;/TabPane> &lt;/Tabs> const LoginTab: React.FC&lt;LoginTabProps> = (props) => { useEffect(() => { const uniqueId = generateId('login-tab-'); //治理生成唯一的tab id const { tabUtil } = props; if (tabUtil) { tabUtil.addTab(uniqueId); } }, []); const { children } = props; return &lt;TabPane {...props}>{props.active &amp;&amp; children}&lt;/TabPane>; }; const WrapContext: React.FC&lt;TabPaneProps> &amp; { typeName: string; } = (props) => ( &lt;LoginContext.Consumer> {(value) => &lt;LoginTab tabUtil={value.tabUtil} {...props} />} &lt;/LoginContext.Consumer> ); 我们看看provider 的用法 // 此时这里用上了hook然后加载的时候会加载一个tab，当切换的时候会添加另一个tab const [tabs, setTabs] = useState&lt;string[]>([]); // 这个active貌似没什么用 const [active, setActive] = useState({}); // 此时声明当前的tab是哪一个 是 account 还是 mobile const [type, setType] = useMergeValue('', { value: props.activeKey, onChange: props.onTabChange, }); &lt;LoginContext.Provider value={{ tabUtil: { addTab: (id) => { setTabs([...tabs, id]); }, removeTab: (id) => { setTabs(tabs.filter((currentId) => currentId !== id)); }, }, updateActive: (activeItem) => { if (!active) return; if (active[type]) { active[type].push(activeItem); } else { active[type] = [activeItem]; } setActive(active); }, }} > &lt;LoginContext.Provider>","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"antd","slug":"react/antd","permalink":"http://yoursite.com/categories/react/antd/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"antd","slug":"antd","permalink":"http://yoursite.com/tags/antd/"}]},{"title":"电话号码的字母组合","slug":"电话号码的字母组合","date":"2020-08-26T05:32:44.000Z","updated":"2020-08-29T06:42:01.693Z","comments":true,"path":"2020/08/26/电话号码的字母组合/","link":"","permalink":"http://yoursite.com/2020/08/26/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","excerpt":"","text":"电话号码的字母组合 题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例输入：\"23\" 输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. 思路 将 数字跟字母 建立映射关系 {2: &#39;abc&#39;}, 数字的长度，就是遍历的深度，递归时，深度减一，当深度为0的时候，停止递归，返回结果，当深度为1的时候，添加到结果 当需要继续递归的时候，保留之前的结果，此结果为了下一次遍历字母的时候，为每一个结果都要添加新的字符 以 &quot;23&quot; 为例子， 转换字母 array = [&#39;abc&#39;, &#39;def&#39;] prefix = [], result = [], 我们循环 array, 每次抽出 array[0], 对array[0]进行遍历 当 prefix 里面没东西的时候，我们直接将 array[0]的值丢进去， 此时 prefix = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 进入下一次递归 继续上面的操作， 此时我们的 array = [&#39;def&#39;], 抽array[0], 对他进行遍历，prefix = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], result = [], dept = 1 现在要对 def 遍历，跟 prefix 组合成 [&#39;ad&#39;, &#39;bd&#39;, &#39;cd&#39;, &#39;ae&#39;, &#39;be&#39;, &#39;ce&#39;, &#39;af&#39;, &#39;bf&#39;, &#39;cf&#39;], 此时dept = 1 可以将结果放到 result了，继续递归 此时dept = 0 退出递归 代码var letterCombinations = function(digits) { let length = digits.length; let result = []; let string = []; let map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz', } for(let i = 0; i &lt; length; i++) { string.push(map[digits[i]]) } contribute(result, string, [], length); return result; }; var contribute = function(result, array, prefix, dept) { if(dept == 0) { return prefix } let current = array[0]; let temp = [] let prefixLength = prefix.length; // current = \"def\"; prefix = [a, b, c] for(let i = 0; i &lt; current.length; i++) { if(prefixLength == 0) { temp.push(current[i]); if(dept == 1) { result.push(current[i]); } continue; } for(let j = 0; j &lt; prefixLength; j++) { let s = prefix[j] + current[i]; temp.push(s); if(dept == 1) { result.push(s); } } } contribute(result, array.slice(1), temp, --dept) }","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-深度遍历搜索","slug":"algorithm-深度遍历搜索","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2/"},{"name":"algorithm-全排列","slug":"algorithm-全排列","permalink":"http://yoursite.com/tags/algorithm-%E5%85%A8%E6%8E%92%E5%88%97/"}]},{"title":"奇偶链表","slug":"奇偶链表","date":"2020-08-25T10:21:04.000Z","updated":"2020-08-29T06:42:01.691Z","comments":true,"path":"2020/08/25/奇偶链表/","link":"","permalink":"http://yoursite.com/2020/08/25/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/","excerpt":"","text":"奇偶链表 题目描述给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例输入: 1->2->3->4->5->NULL 输出: 1->3->5->2->4->NULL 分析 先建立 odd 和 even 指针，分别指向的是奇链表, 偶链表 建立 p 和 q, 指向 odd 和 even 遍历 head 链表，odd.next 指向 head, even.next = head.next, 就是说一次遍历直接跳两个元素 修改 head 指向 head = head.next.next, 但此时需要判断 head.next是否为null 修改 odd 和 even, odd = odd.next; even = even.next; 最后修改 odd.next 指向 even 的开头即可 题解/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var oddEvenList = function(head) { let odd = new ListNode(\"head\", null); let even = new ListNode(\"head\", null); let p = odd; let q = even; while(head) { odd.next = head; even.next = head.next ? head.next : null head = head.next &amp;&amp; head.next.next ? head.next.next : null; odd = odd.next; even = even.next; } odd.next = q.next; return p.next; };","categories":[],"tags":[{"name":"algorithm-链表","slug":"algorithm-链表","permalink":"http://yoursite.com/tags/algorithm-%E9%93%BE%E8%A1%A8/"}]},{"title":"递增子序列","slug":"递增子序列","date":"2020-08-25T03:43:05.000Z","updated":"2020-08-29T06:42:01.696Z","comments":true,"path":"2020/08/25/递增子序列/","link":"","permalink":"http://yoursite.com/2020/08/25/%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"递增子序列 题目描述给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。 示例1输入: [4, 6, 7, 7] 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] 示例2输入: [4, 3, 2, 1] 输出: [] 题目分析我们以[4, 6, 7, 7]为例子 一开始我们的数组为array = [4,6,7,7], 结果集为result = [], 暂存结果集为 prefix = [], 遍历数组 遍历开始，值为4, 放入暂存结果集，此时prefix = [4], 我们暂时不考虑顺序和是否重复，把剩下的数组继续递归遍历 此时 array = [6, 7, 7], 把 6 取出来，prefix = [4, 6], 此时 prefix 的长度 &gt;= 2 放入 result，此时 result = [[4, 6]], 把剩下的[7,7]继续递归，回溯之后这层可以整 result = [[4,6],[4,7],[4,7]]， 不过这是回溯之后的结果 此时 array = [7, 7], prefix = [4, 6], reuslt = [[4, 6]]; 执行操作像上面一步 实现代码/** * @param {number[]} nums * @return {number[][]} */ var findSubsequences = function(nums) { let result = []; contribute(result, nums, []) return result }; var contribute = function(result, array, prefix) { let length = array.length; if(length == 0) { return result; } let isInlcude = []; for(let i = 0; i &lt; length; i++) { if(isInlcude.includes(array[i])) { // 去重 continue; } const last = prefix.length > 0 ? prefix[prefix.length - 1] : null; // 如果prefix 的最后一个数 比当前数要大，那就不符合，例如 prefix = [4, 5]; 此时last 应该是5，array[i] = 1, 5>1不符合题意 if(last !== null &amp;&amp; last > array[i]) { continue; } const temp = prefix.concat(array[i]); isInlcude.push(array[i]) if(temp.length > 1) { result.push(temp); } contribute(result, array.slice(i + 1, array.length), temp); } return result }","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-深度遍历搜索","slug":"algorithm-深度遍历搜索","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2/"},{"name":"algorithm-全排列","slug":"algorithm-全排列","permalink":"http://yoursite.com/tags/algorithm-%E5%85%A8%E6%8E%92%E5%88%97/"}]},{"title":"回文子串","slug":"回文子串","date":"2020-08-19T06:10:49.000Z","updated":"2020-08-29T06:42:01.690Z","comments":true,"path":"2020/08/19/回文子串/","link":"","permalink":"http://yoursite.com/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"回文子串 题目描述给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例示例1 输入：\"abc\" 输出：3 解释：三个回文子串: \"a\", \"b\", \"c\" 示例2 输入：\"aaa\" 输出：6 解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\" 解决思路方法1 暴力破解我们用ababa做例子, 对字符串做遍历，i 表示字符串的第n个数 i = 0, 字符 a, 判断一下是否是回文，是的话count + 1。 此时我们保留上一次的字符[&#39;a&#39;] i = 1, 字符 b, 此时我们对上一次字符数组的所有子串都添加b, 注意这里也要加上自身b, 也就是 [&#39;b&#39;, &#39;ab&#39;] 去判断一下是否是回文，此时再将上面数组保留下来。 i = 2, 字符 c, 我们继续做上面的操作, 先记录自身c, 再对上面保留下来的字符做c字符添加，也就是 [&#39;c&#39;, &#39;bc&#39;, &#39;abc&#39;], 对数组做回文判断，如此类推 我们总结一下，看下每次操作的数组 [&#39;a&#39;] [&#39;b&#39;, &#39;ab&#39;] [&#39;c&#39;, &#39;bc&#39;, &#39;abc&#39;] [&#39;b&#39;, &#39;cb&#39;, &#39;bcb&#39;, &#39;abcb&#39;], [&#39;a&#39;, &#39;ba&#39;, &#39;cba&#39;, &#39;bcba&#39;, &#39;abcb&#39;] // 完整代码 /** * @param {string} s * @return {number} */ var countSubstrings = function(s) { let count = 0; let length = s.length; if(length === 0) { return count } let prev = [s[0]]; count = 1; for(let i = 1; i &lt; length; i++) { let current = [s[i]]; count++; for(let j = 0; j &lt; prev.length; j++) { let temp = prev[j] + s[i]; if(ishuiwen(temp)) { count++; } current.push(temp); } prev = current; } return count; }; var ishuiwen = function(s) { let start = 0; let end = s.length - 1; while(start &lt; end) { let ss = s[start]; let es = s[end]; if(ss !== es) { return false } start++; end-- } return true } 方法二 动态规划题解 上面 s[i][j] 指的是 s[i:j] 的子串, 比如 i = 1, j = 3, 以ababa 例子, s[i:j] =&gt; s[1:3] 就是字符串中的bab","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"有序链表转换二叉搜索树","slug":"有序链表转换二叉搜索树","date":"2020-08-18T02:38:08.000Z","updated":"2020-08-29T06:42:01.692Z","comments":true,"path":"2020/08/18/有序链表转换二叉搜索树/","link":"","permalink":"http://yoursite.com/2020/08/18/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"有序链表转换二叉搜索树 这道题跟将有序数组转换为二叉搜索树有点相似 题目描述给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 示例1给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 分析 先把链表遍历出来，然后进行下面的操作 具体分析可以看 代码/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {ListNode} head * @return {TreeNode} */ var sortedListToBST = function(head) { let array = getSortedList(head); let res = toBST(array); return res; }; var getSortedList = function(head) { let result = []; let p = head; while(p != null) { result.push(p.val); p = p.next; } return result; } var toBST = function(array) { let length = array.length; if(length == 0) { return null } let mid = Math.floor(length / 2); let left = array.slice(0, mid); let right = array.slice(mid + 1, length); let root = new TreeNode(array[mid]); root.left = toBST(left); root.right = toBST(right); return root; }","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"有效括号","slug":"有效括号","date":"2020-08-14T03:34:28.000Z","updated":"2020-08-29T06:42:01.693Z","comments":true,"path":"2020/08/14/有效括号/","link":"","permalink":"http://yoursite.com/2020/08/14/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"有效的括号 题目描述给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例示例1： 输入: \"()\" 输出: true 示例2： 输入: \"()[]{}\" 输出: true 示例3： 输入: \"([)]\" 输出: false 示例4： 输入: \"{[]}\" 输出: true 思路 遍历 s 当遇到[, (, { 这些括号的时候就入栈。 当遇到], ), } 这些括号的时候就出栈，出栈 判断与当前s[i] 是否匹配为闭合的括号, 即是否是一对。出栈(, 当前s[i]为)则为一对 代码/** * @param {string} s * @return {boolean} */ var isValid = function(s) { let length = s.length; // 做优化，看了答案后添加 if(length % 2 == 1) { return false; } // 建立字典， let map = { \"{\": \"}\", \"(\": \")\", \"[\": \"]\", } let inqueue = [\"{\", \"(\", \"[\"]; let stack = []; for(let i = 0; i &lt; s.length; i++) { const current = s[i]; // 判断以下是否属于开合 的括号 if(inqueue.includes(current)) { stack.unshift(current); continue; } // 出栈， 判断当前出栈的括号是否跟 s[i] 为一对， let pop = stack.shift(); if(current !== map[pop]) { return false } } // 最后判断以下栈里面还有没有数据，有的话那就代表还有没有匹配的括号 return stack.length == 0 ; };","categories":[],"tags":[{"name":"algorithm-栈","slug":"algorithm-栈","permalink":"http://yoursite.com/tags/algorithm-%E6%A0%88/"}]},{"title":"字符串相乘","slug":"字符串相乘","date":"2020-08-13T08:02:26.000Z","updated":"2020-08-29T06:42:01.691Z","comments":true,"path":"2020/08/13/字符串相乘/","link":"","permalink":"http://yoursite.com/2020/08/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/","excerpt":"","text":"字符串相乘 题目描述给定两个字符串 num1 和 num2 ,返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例： 输入: num1 = \"2\", num2 = \"3\" 输出: \"6\" 分析我们以 num1 = &quot;123&quot;, num2 = &quot;456&quot;做例子 1 2 3 4 5 6 -------------- 1 3 6 8 9 1 2 0 4 5 6 ------------------ 5 6 0 8 8 我们循环 123，分别乘以下面的 456, 3 * 456 得到的是 1368 2 * 456 得到的是 912， 但此时的2应该是20， 所以得到的结果是 9120 1 * 456 得到的是 456， 但此时的1应该是100，所以得到的结果是 45600 将这三个结果加起来即可 注意：我们每次相乘的结果都用数组存起来， 1368 =&gt; [1,3,6,8] 如此类推 后面就是大数相加了，将所有的数组都加起来，另外这里使用了分治 代码/** * @param {string} num1 * @param {string} num2 * @return {string} */ var multiply = function(num1, num2) { if(num1 == 0 || num2 == 0) { return \"0\"; } let length1 = num1.length; let length2 = num2.length; let multiplyAdd = 0; let times = 0; let resArr = [] for(let i = length1 - 1; i >= 0; i--) { let currentNum1 = num1[i] * 1 let resultArray = [] for(let j = length2 - 1; j >= 0; j--) { const tempRes = currentNum1 * (num2[j] * 1) + multiplyAdd; const div = tempRes % 10; multiplyAdd = Math.floor(tempRes / 10); resultArray.unshift(div) } if(multiplyAdd > 0) { resultArray.unshift(multiplyAdd); multiplyAdd = 0; } for(let k = 0; k &lt; times; k++) { resultArray.push(0) } times++; resArr.push(resultArray.join(\"\")) } if(resArr.length &lt;= 1) { return resArr.join(\"\") } const test = fenzhi(resArr); return test.join(\"\"); }; /** * [\"1386\", \"9120\", \"45600\"] * 递归分支 * 递归结束条件时，数组只剩下一个的时候, 直接返回 * 剩下的就是左右两个相加了 combine(left, right), // 简单说就是 left + right */ var fenzhi = function(arr) { let length = arr.length; if(length == 1) { return arr.join(\"\"); } const currentIndex = Math.floor(arr.length / 2); let left = arr.slice(0, currentIndex); let right = arr.slice(currentIndex, length); return combine( fenzhi(left) , fenzhi(right) ); } // 我这里使用大数相加 var combine = function(arr1, arr2) { let result = []; let length1 = arr1.length - 1; let length2 = arr2.length - 1; let add = 0; let i = 0; let j = 0; while(length1 >= 0 || length2 >= 0) { let num1 = length1 >= 0 ? arr1[length1] : 0; let num2 = length2 >= 0 ? arr2[length2] : 0 let res = num1 * 1 + num2 * 1 + add * 1; let div = res % 10; add = Math.floor(res / 10); result.unshift(div); length2--; length1--; } if(add > 0) { result.unshift(add); } // console.log(\"result\", result) return result; }","categories":[],"tags":[{"name":"algorithm-数组","slug":"algorithm-数组","permalink":"http://yoursite.com/tags/algorithm-%E6%95%B0%E7%BB%84/"},{"name":"algorithm-分治","slug":"algorithm-分治","permalink":"http://yoursite.com/tags/algorithm-%E5%88%86%E6%B2%BB/"}]},{"title":"剑指 Offer 55 - II. 平衡二叉树","slug":"剑指-Offer-55-II-平衡二叉树","date":"2020-08-12T08:27:13.000Z","updated":"2020-08-29T06:42:01.690Z","comments":true,"path":"2020/08/12/剑指-Offer-55-II-平衡二叉树/","link":"","permalink":"http://yoursite.com/2020/08/12/%E5%89%91%E6%8C%87-Offer-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"剑指 Offer 55 - II. 平衡二叉树 题目描述输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 。 分析 我们每次获取左右节点的最大深度，然后相减要是 &lt;= 1 在递归左右节点 代码var isBalanced = function(root) { if(!root) { return true } let left = dept(root.left); let right = dept(root.right); return Math.abs(left - right) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right) } var dept = function(root) { if(!root) { return 0; } return Math.max( dept(root.left), dept(root.right) ) + 1 }","categories":[],"tags":[{"name":"algorithm-深度遍历搜索","slug":"algorithm-深度遍历搜索","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2/"},{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"关于this","slug":"关于this","date":"2020-08-11T07:19:51.000Z","updated":"2020-08-29T06:42:01.689Z","comments":true,"path":"2020/08/11/关于this/","link":"","permalink":"http://yoursite.com/2020/08/11/%E5%85%B3%E4%BA%8Ethis/","excerpt":"","text":"参考 《你不知道的JavaScript上卷》 我们经常会对this的指向存在疑惑，搞不清楚是指向window，还是本身。 this 的解析 this是在运行时进行绑定的，并不是在编写时绑定， 它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式 this 规则我们要清楚知道在函数的执行过程中调用位置是如何确定this的绑定对象的。 我们分析 函数是属于以下四种规则的哪一种既可。 默认绑定 隐式绑定 显示绑定 硬绑定 默认绑定默认绑定是最常用的一种方式，可以把这条规则看作是无法应用其他规则时的默认规则。 // 例子 function foo() { console.log(this); // this 指向的是window } // 此时我们调用的位置在全局，那么foo 的this指向的是window foo(); 注意：默认绑定在严格模式下，会报错。 严格模式下，默认绑定会将this绑定到undefined 隐式绑定一般来说隐式绑定就是obj.func()这样子。但我们看看下面的注意事项 // 这里要注意foo的声明方式 function foo() { console.log(this.a) // 123 } const obj = { a: \"123\", foo: foo } //obj对象引用了foo, 调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象“拥有”或者“包含”它。 obj.foo(); 隐式调用： 当函数引用有上下文的时候，函数的this会绑定到上下文对象中。 但是对象属性引用链中只有上一层或者说最后一层在调用位置中起作用 // 例子 function foo() { console.log(this.a) } const obj = { a: \"123\", foo: foo } const obj2 = { a: \"2\", // obj: obj } // 这里是最后一层起作用了 obj2.obj.foo(); // 123 隐式丢失 简单说就是函数丢失了原来的绑定对象，然后函数使用默认绑定的方式，导致了this指向window或者是undefined function foo() { console.log(this.a) } const obj = { a: \"123\", foo: foo } var a = \"windows\"; // 虽然 obj.foo 引用的是foo 函数，但是它等同于使用foo(), 这样看的话他的调用方式是全局的，所以使用默认绑定 const test = obj.foo; test() // windows, 另外还有回调函数会造成this的丢失，所以我们一般用call或者apply去改变this的指向 // 例子 function foo() { console.log(this.a) } const obj = { a: \"123\", foo: foo } var a = \"windows\"; function doFoo(fn) { // fn => foo fn() } doFoo(obj.foo) 显示绑定显示绑定主要是使用了 call 和 apply, 我们可以理解 当函数调用是，this 的指向更改为call函数或者apply函数的第一个参数 var obj = { a: \"123\" } function foo() { console.log(this.a) } foo.call(obj); // 123， 我们理解成 当foo函数调用的时候 this 指向 obj 我们可以理解为 foo.call(obj) =&gt; foo(), 但是this指向了obj 我们看下一个最常用的操作 // 辅助函数 function bind(fn, obj) { return function() { return fn.apply(obj, arguments); } } function foo(params) { console.log(this.a, params) } var obj = { a: \"123\" } var test = bind(foo, obj); // bind函数返回的是function test(\"hahah\") // 输出： 123，hahah new 绑定使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行[[Prototype]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 我们先看看new的实现源码 function new(fn, ...args) { let obj = {}; obj._proto_ = fn.prototype; let res = fn.call(obj, ...args); let isObject = typeof res === 'object' &amp;&amp; typeof res !== null; let isFunction = typeof res === 'function'; return isObject || isFunction ? res : obj; } 看到上面第三步，call 改变了fn this的指向 function foo(a) { this.a = a } var obj = new foo(2) console.log(obj.a); // 2 优先级new &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 我们看看 如何实现 apply 和 call方法call// call 方法类似, call 方法实现方式跟下面一样 var foo = { value: 1, bar: function() { console.log(this.value) } } foo.bar() // 1 // fn.call(obj, 1, 2) Function.prototype.imitateCall = function (context) { // 这里的context 同等于上面的 foo， 如果context没有那么我们指定到window context = context || window // 当前this 指的是 function context.invokFn = this // 截取作用域对象参数后面的参数 let args = [...arguments].slice(1) // 执行调用函数，记录拿取返回值 let result = context.invokFn(...args) // 销毁调用函数，以免作用域污染 Reflect.deleteProperty(context, 'invokFn') return result } apply// fn.apply(obj, [1, 2]) Function.prototype.imitateApply = function (context) { // 这里的context 同等于上面的 foo， 如果context没有那么我们指定到window context = context || window // 当前this 指的是 function context.invokFn = this // 截取作用域对象参数后面的参数 let result if (arguments[1]) { result = context.invokFn(...arguments[1]) } else { result = context.invokFn() } // 销毁调用函数，以免作用域污染 Reflect.deleteProperty(context, 'invokFn') return result }","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"计数二进制子串","slug":"计数二进制子串","date":"2020-08-10T05:59:14.000Z","updated":"2020-08-29T06:42:01.695Z","comments":true,"path":"2020/08/10/计数二进制子串/","link":"","permalink":"http://yoursite.com/2020/08/10/%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/","excerpt":"","text":"计数二进制子串 题目描述给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例：输入: \"00110011\" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 请注意，一些重复出现的子串要计算它们出现的次数。 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 分析 我们直接用 1100 做分析例子，我们可以看出其实他的结果就是 2，就只有两种结果[1100, 10] 所以我们循环这个字符串，记录相同的的数字 1的个数 = 2；然后以当前i做起点，往后遍历两位，要是都相同那么就是2种（此时重复的数字还是2），要是只有一位就只有1种（此时重复的数字就变成1了） 代码/** * @param {string} s * @return {number} */ var countBinarySubstrings = function(s) { let length = s.length; if(length == 0) { return 0; } let count = 1; let prev = s[0]; let currentNum = null; let result = 0; // s = \"1100\" let i = 1; while(i &lt; length) { currentNum = s[i]; if(currentNum == prev) { // 为了找相同的数字 count++; // 相同数字的个数 i++; continue; } // prev = 1; count = 2 // currentNum 已经跟prev 不一样了， 就是 0 => 1 , 1 => 0， 然后以i为起点，遍历后面count个数 let j = i; while(j &lt; i + count &amp;&amp; j &lt; length) { // 这里表示 当前数字跟 前一个数字相同的话结果 + 1 ,即当前 prev = 1， s[j] = 0, 就是当前i为去起点，往后两位都是0的话就 + 2 if(s[j] == !(prev * 1)) { result++; } else { // 此时不一样时，重新计算重复的个数 count = j - i break; } j++; } i = i + count; prev = currentNum; } return result };","categories":[],"tags":[{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"}]},{"title":"相同的树","slug":"相同的树","date":"2020-08-07T02:17:43.000Z","updated":"2020-08-09T03:38:24.574Z","comments":true,"path":"2020/08/07/相同的树/","link":"","permalink":"http://yoursite.com/2020/08/07/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/","excerpt":"","text":"题目描述给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例：输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] 输出: true 分析 我们暂定左边的树为p, 右边的树为q 从根分析，要是 p 或 q ，一个为空，另一个不为空，那么我们返回false p 和 q 都为空，那么我们直接返回true p 和 q 都不为空，那么我们判断他们的值是否相同 p.val === q.val 递归操作， 判断 p的左子树 跟 q 的左子树 是否相同，执行上面的操作, 所以isSameTree(p.left, q.left)； p 的右子树 跟 q 的右子树是否相同，执行上面的操作, 所以 isSameTree(p.right, q.right) 代码/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */ var isSameTree = function(p, q) { if(!p &amp;&amp; q) { return false } if(p &amp;&amp; !q) { return false } if(!p &amp;&amp; !q) { return true } if(p.val !== q.val) { return false } return p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); };","categories":[],"tags":[{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"滑动验证码","slug":"滑动验证码","date":"2020-08-06T08:49:31.000Z","updated":"2020-08-30T07:28:47.716Z","comments":true,"path":"2020/08/06/滑动验证码/","link":"","permalink":"http://yoursite.com/2020/08/06/%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"","text":"前言一直想做一个滑动验证码的组件。 html 结构&lt;div className={styles.container}> &lt;div className={styles.slider}> &lt;!-- 滑块 --> &lt;div className={styles.sliderHandle} onMouseDown={mouseDown} style={sliderHandleStyle} > >> &lt;/div> &lt;!-- 轨道 --> &lt;div className={styles.sliderRail}> &lt;div className={styles.text}>向右滑动验证&lt;/div> &lt;/div> &lt;!-- 滑块路线 --> &lt;div className={styles.sliderTrack} style={{width: ((offset.x) / 250 * 100 + \"%\"), borderRadius: (offset.x &lt; 250) ? 'none' : '45px' }}>&lt;/div> &lt;/div> &lt;/div> less 结构主要是一些定位， 相对定位中的绝对定位 .container { width: 400px; height: 400px; margin: 50px auto; display: flex; flex-direction: column; align-items: center; justify-content: center; user-select: none; .slider { width: 250px; height: 45px; position: relative; border-radius: 45px; .sliderHandle { width: 45px; height: 45px; border-radius: 50%; display: flex; flex-direction: row; justify-content: center; align-items: center; background-color: #fff; z-index: 99; position: absolute; left: 0; top: 0; right: auto; transform: translateX(-50%); box-shadow: 1px 5px 2px #eee; cursor: pointer; } .sliderRail { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; border-radius: 45px; background-color: #f5f5f5; display: flex; flex-direction: row; justify-content: center; align-items: center; } .sliderTrack { position: absolute; width: 0%; top: 0; left: 0; z-index: 89; right: 0; bottom: 0; border-top-left-radius: 45px; border-bottom-left-radius: 45px ; background-color: #91d5ff; } } } 代码逻辑代码中主要使用的是 react Hook， 主要的逻辑是使用了 mouseup, mouseover, mouseDown const Block: React.FC = () => { const [dragging, setDragging] = useState(false); const [origin, setOrigin] = useState({ x: 0, y: 0 }); const [offset, setOffset] = useState({ x: 0, y: 0}); const mouseDown = useCallback(({clientX, clientY}) => { console.log(\"mouseDown\", clientX); setOrigin((state) => ({ x: clientX, y: clientY})) setDragging(true); }, []); const mouseMove = useCallback(({clientX, clientY}) => { let x = clientX - origin.x; if( x >= 250 ) { x = 250 } else if(x / 250 * 100 &lt;= 0 ) { x = 0; } const transition = { x, y: clientY - origin.y }; if(x >= 250) { setDragging(() => false) } setOffset(state => { return { ...state, ...transition } }); }, [origin]); const mouseUp = useCallback(() => { console.log(\"up\") setDragging(() => false) }, []); useEffect(() => { if (dragging) { window.addEventListener('mousemove', mouseMove); window.addEventListener('mouseup', mouseUp); } else { window.removeEventListener('mousemove', mouseMove); window.removeEventListener('mouseup', mouseUp); setOffset((state) => { let x = state.x if(x>= 250) { console.log(\"验证通过\") } else if(x&lt; 250) { x = 0 } return { x: x, y: state.y } }) } }, [dragging]); const sliderHandleStyle = useMemo(() => ({ left: (offset.x) / 250 * 100 + \"%\", transition: (!dragging ? 'left 500ms' : 'none' ) }), [offset, dragging]) return ( &lt;div> &lt;div className={styles.container}> &lt;div className={styles.slider}> &lt;div className={styles.sliderHandle} onMouseDown={mouseDown} style={sliderHandleStyle} >&lt;DoubleRightOutlined />&lt;/div> &lt;div className={styles.sliderRail}> &lt;div className={styles.text}>向右滑动验证&lt;/div> &lt;/div> &lt;div className={styles.sliderTrack} style={{width: ((offset.x) / 250 * 100 + \"%\"), borderRadius: (offset.x &lt; 250) ? 'none' : '45px' }}>&lt;/div> &lt;/div> &lt;/div> &lt;/div> ); } 线上仓库demo 这里记录一下在使用 react hook 的一些问题先谈谈 useCallback 这个函数吧 useCallbackuseCallback 提供了两个参数，一个个回调函数，另一个是依赖数组。当依赖数组不改变时，此时回调函数不改变，已达到缓存的效果，减少在re-render的时候重新生成函数 案例1// Child.js const Child = ({cb}) => { return ( &lt;div> &lt;button onClick={cb}>点击&lt;/div> &lt;/div> ) } const App = () => { // 此时 当App 重新渲染的时候，会重新生成 memoClick // const memoClick = () => console.log(\"click\"); // 用了useCallback 后 无论App 是否重新渲染，传给 Child 的 memoClick 都是之前的引用 const memoClick = useCallback(() => console.log(\"click\"), []) return ( &lt;div> &lt;Child cb={cb} /> &lt;/div> ) } 其他当useCallback 的依赖数组 在useCallback内设置变化会导致无限循环 const App = () => { const [a, setA] = useState(1); const memoClick = useCallback(() => { console.log(\"click\") setA((state) => { const after = state.a++; return after }) }, [a]) return ( &lt;div> &lt;div>{a}&lt;/div> &lt;Button onClick={memoClick}>点击&lt;/Button> &lt;/div> ) } 然后我找了很多文章，应该只有这篇是讲的比较清晰的， React Hooks(二): useCallback 之痛 后话验证码组件还没做好，但大体逻辑是这样","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"二叉树的最大深度","slug":"二叉树的最大深度","date":"2020-07-30T05:36:08.000Z","updated":"2020-07-31T08:56:34.257Z","comments":true,"path":"2020/07/30/二叉树的最大深度/","link":"","permalink":"http://yoursite.com/2020/07/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"二叉树的最大深度 题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 分析 题目用递归 递归终止条件： 当当前树节点为空时，返回0 要是根不为空，我们比较 左右节点，看左节点比较深还是右节点深 代码/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function(root) { if(!root) { return 0 } return (1 + Math.max( maxDepth(root.left), maxDepth(root.right) )) };","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"整数拆分","slug":"整数拆分","date":"2020-07-30T02:54:46.000Z","updated":"2020-07-31T08:56:34.258Z","comments":true,"path":"2020/07/30/整数拆分/","link":"","permalink":"http://yoursite.com/2020/07/30/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/","excerpt":"","text":"整数拆分力扣上 题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例2： 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 思想 2 =&gt; 1 + 1 3 =&gt; 2 + 1 4 =&gt; 2 + 2 5 =&gt; 2 + 3 6 =&gt; 3 + 3 7 =&gt; 3 + 4 8 =&gt; 3 + 3 + 2 9 =&gt; 3 + 3 + 3 10 =&gt; 3 + 3 + 2 + 2 观察 10 跟 8, 还有 7 的关系， 观察9 跟 7 还有 6 的关系, 我这里直接用dp表示 dp[10] = max(dp[8] * 2, dp[7] * 3), =&gt; max(3 * 3 * 3 * 2, 3 * 4 * 3) dp[9] = max(dp[7] * 2, dp[6] * 3), =&gt; max(3 * 4 * 2, 3 * 3 * 3) 注意：但你会发现 从dp[6] 往上就不符合上面的方法了， dp[6] = max(dp[4] * 2, dp[3] * 3) 所以我直接做了暴力破解！直接赋值 代码/** * @param {number} n * @return {number} */ var integerBreak = function(n) { let dp = Array(n + 1).fill(1); dp[3] = 2; dp[4] = 4; dp[5] = 6 dp[6] = 9 for(let i = 7; i &lt;= n; i++) { dp[i] = Math.max(dp[i - 3] * 3, dp[i - 2] * 2); } return dp[n] }; 官方题解dp[i]=max(2×(i−2),2×dp[i−2],3×(i−3),3×dp[i−3]) class Solution { public: int integerBreak(int n) { if (n < 4) { return n - 1; } vector dp(n + 1); dp[2] = 1; for (int i = 3; i","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"xlsx 读取写入excel","slug":"xlsx-读取写入excel","date":"2020-07-27T01:38:24.000Z","updated":"2020-07-31T08:56:34.257Z","comments":true,"path":"2020/07/27/xlsx-读取写入excel/","link":"","permalink":"http://yoursite.com/2020/07/27/xlsx-%E8%AF%BB%E5%8F%96%E5%86%99%E5%85%A5excel/","excerpt":"","text":"js-xlsxnpm install xlsx --save 文档地址 读取这里记录一下最经常用的方法，到时候复杂处理再记录 以nodejs 的方式// nodejs 方式读取文件 const filePath = './test.xlsx'; const ws = xlsx.readFile(filePath, { type: 'binary'}); // 传文件路径读取文件 const sheet = ws.Sheets[\"Sheet1\"]; // 指定工作表 const data = xlsx.utils.sheet_to_json(sheet, {header:1}); // 对工作表的内容进行json 转化 const header = data.slice(0, 1); // 第一行就是我们的header const body = data.slice(1); // 数据body browser 方式，上传文件的形式读取excel&lt;input type=\"file\" @change=\"fileChange\" /> function fileChange(e) { var files = e.target.files; console.log(files) var fileReader = new FileReader(); fileReader.readAsBinaryString(files[0]); fileReader.onload = (ev) => { // 读取上传的文件，后面的跟上面类似 const file = ev.target.result; const wb = xlsx.read(file, { type: 'binary' }); const sheet = wb.Sheets[\"Sheet1\"]; const data = xlsx.utils.sheet_to_json(sheet, {header:1}); }; }, 写 Excelnodejs 方式直接导出excel/** * @params dataSource 简单的数据结构 * @params excelName 表名 */ type source { name: string, address: string, phone: number } function json2Excel(dataSource: source, excelName: string) { let wb = xlsx.utils.book_new() let ws = xlsx.utils.aoa_to_sheet(dataSource); // 将简单的数据对象写到工作表里 xlsx.utils.book_append_sheet(wb, ws, \"SheetJS\") xlsx.writeFile(wb, `${excelName}.xlsx`); } 创建a 链接方式导出excel参考 其他链接参考","categories":[{"name":"js-xlsx","slug":"js-xlsx","permalink":"http://yoursite.com/categories/js-xlsx/"}],"tags":[{"name":"js-xlsx","slug":"js-xlsx","permalink":"http://yoursite.com/tags/js-xlsx/"}]},{"title":"除数博弈","slug":"除数博弈","date":"2020-07-24T06:03:55.000Z","updated":"2020-07-31T08:56:34.259Z","comments":true,"path":"2020/07/24/除数博弈/","link":"","permalink":"http://yoursite.com/2020/07/24/%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/","excerpt":"","text":"除数博弈 题目描述爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例1： 输入：2 输出：true 解释：爱丽丝选择 1，鲍勃无法进行操作。示例2： 输入：3 输出：false 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。思想 题目要求能整除那么被除数 一定是 1，2，3，5 这几个数，所以我们只要关注dp[i-1], dp[i-2]和dp[i-3]还有dp[i-5]的值即可 另外题目也说 0 &lt; x &lt; N 所以 i 一定要大于 2, 或者3，或者 5 另外 假设 i = 4时， 可以整除2，所以可以关注dp[2]的值，和dp[3]的值， 如果我们关注dp[3]的话，也就是我先手，先取1，他取1，我再取1，他无法操作，我赢 如果我们关注dp[2]的话，也就是我先手，我先取2， 他取1，我无法操作，我输， 总结： 总体来说是赢的，但dp[4] 要取与dp[2]， dp[3]相反的值. 代码var divisorGame = function(N) { // 这既是一个博弈游戏，类似捡石子 let dp = Array(N + 1).fill(false); dp[0] = false; dp[1] = false; dp[2] = true; for(let i = 3; i &lt; N + 1; i++) { // 1, 2, 3, 5 dp[i] = (i > 5 &amp;&amp; i % 5 == 0 &amp;&amp; !dp[i - 5]) || (i > 2 &amp;&amp; i % 2 == 0 &amp;&amp; !dp[i - 2]) || (i > 3 &amp;&amp; i % 3 == 0 &amp;&amp; !dp[i - 3]) || (!dp[i - 1]); } console.log(dp); return dp[N]; }; 官方解答看了官方解答，我真的是吐了，就一样代码 var divisorGame = function(N) { return N % 2 == 0; };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"最小路径和","slug":"最小路径和","date":"2020-07-23T02:53:00.000Z","updated":"2020-07-31T08:56:34.259Z","comments":true,"path":"2020/07/23/最小路径和/","link":"","permalink":"http://yoursite.com/2020/07/23/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","excerpt":"","text":"最小路径和 这道题跟三角形最小路径和类似 题目描述给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例： 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 思想这是一道二维数组的动态规划题目， 左边表示输入， 右边表示dp 结果集 第一行只能够向右走， 所以 dp[i][j] = grid[i][j] + dp[i][j - 1]; 第一列只能向下走，所以 dp[i][j] = grid[i][j] + dp[i - 1][j] 其余符合 dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]); .minPathSum { display: flex; flex-direction: row; } .minPathSum-right { margin-left: 10px } @media screen and (max-width: 800px) { .minPathSum { display: flex; flex-direction: column; } .minPathSum-right { margin-left: 0px } } w 输入 i / k k = 0 k = 1 k = 2 i = 0 1 3 1 i = 1 1 5 1 i = 2 4 2 1 dp结果集 i / k k = 0 k = 1 k = 2 i = 0 1 4 5 i = 1 2 7 (上面dp值与左边dp值比较取最小 + grid) 6 i = 2 6 8 7 代码/** * 二维数组的动态规划 * 当前 dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]); * 第一行只能够向右走， 所以 dp[i][j] = grid[i][j] + dp[i][j - 1]; * 第一列只能向下走，所以 dp[i][j] = grid[i][j] + dp[i - 1][j] */ var minPathSum = function(grid) { let rows = grid.length; let columns = grid[0].length; let dp = []; for(let i = 0; i &lt; rows; i++) { let temp = []; for(let j = 0; j &lt; columns; j++) { if(i == 0 &amp;&amp; j == 0) { temp.push(grid[i][j]); } else if(j == 0) { temp.push(grid[i][j] + dp[i - 1][j]); } else if(i == 0) { temp.push(grid[i][j] + temp[j - 1]) } else { temp.push(grid[i][j] + Math.min(dp[i - 1][j], temp[j - 1])) } } dp.push(temp); } return dp[rows - 1][columns - 1] };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"React源码 调度","slug":"React-调度","date":"2020-07-21T02:11:25.000Z","updated":"2020-07-31T08:56:34.254Z","comments":true,"path":"2020/07/21/React-调度/","link":"","permalink":"http://yoursite.com/2020/07/21/React-%E8%B0%83%E5%BA%A6/","excerpt":"","text":"继上一遍React源码-ReactDom 我们查看了ReactDom 的render所构成的整个fiber 结构 我们重新看 legacyRenderSubtreeIntoContainer, 我们构建完fiber之后往下走 function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component&lt;any, any>, children: ReactNodeList, container: DOMContainer, forceHydrate: boolean, callback: ?Function, ) { // 一开始进来 container 上是肯定没有这个属性的 let root: Root = (container._reactRootContainer: any); // 没有 root 会执行 if 中的操作 if (!root) { // Initial mount // 创建一个 root 出来，类型是 ReactRoot root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate, ); // ... 这里直接省略callback, 因为我们不关注callback unbatchedUpdates(() => { // 大多数情况parentComponent 为null, 一遍不考虑，我们直接看else if (parentComponent != null) { root.legacy_renderSubtreeIntoContainer( parentComponent, children, callback, ); } else { // 调用的是 ReactRoot.prototype.render，我们直接看这里 root.render(children, callback); } }); } else { // ... 这里直接省略callback, 因为我们不关注callback // Update if (parentComponent != null) { root.legacy_renderSubtreeIntoContainer( parentComponent, children, callback, ); } else { root.render(children, callback); } } return getPublicRootInstance(root._internalRoot); } React.prototype.renderReactRoot.prototype.render = function( children: ReactNodeList, callback: ?() => mixed, ): Work { // 这里指 FiberRoot const root = this._internalRoot; // ReactWork 的功能就是为了在组件渲染或更新后把所有传入 // ReactDom.render 中的回调函数全部执行一遍 // 我们这里callback 为null, 所以其实不用考虑这个 const work = new ReactWork(); callback = callback === undefined ? null : callback; // 如果有 callback，就 push 进 work 中的数组 if (callback !== null) { work.then(callback); } // work._onCommit 就是用于执行所有回调函数的 updateContainer(children, root, null, work._onCommit); return work; }; updateContainer// packages\\react-reconciler\\src\\ReactFiberReconciler.js export function updateContainer( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component&lt;any, any>, callback: ?Function, ): ExpirationTime { // 取出容器的 fiber 对象. const current = container.current; // 计算时间 const currentTime = requestCurrentTime(); // expirationTime 代表优先级，数字越大优先级越高 // sync 的数字是最大的，所以优先级也是最高的 const expirationTime = computeExpirationForFiber(currentTime, current); return updateContainerAtExpirationTime( element, container, parentComponent, expirationTime, callback, ); } requestCurrentTimepackages\\shared\\ReactFeatureFlags.js 的 enableNewScheduler = false; 所以使用的是packages\\react-reconciler\\src\\ReactFiberScheduler.old.js let originalStartTimeMs: number = now(); let currentRendererTime: ExpirationTime = msToExpirationTime( originalStartTimeMs, ); let currentSchedulerTime: ExpirationTime = currentRendererTime; // 承接下面的currentSchedulerTime 和 currentRendererTime function requestCurrentTime() { // 调度程序调用requestCurrentTime来计算到期时间。 // 过期时间是通过将当前时间（开始时间）加起来得出的时间。 // 但是，如果在同一事件中安排了两次更新，即使实际时钟时间在第一次和第二次呼叫之间提前了，我们也应将它们的开始时间视为同时发生。 // 换句话说，由于到期时间决定了更新的批处理方式，因此我们希望在同一事件中发生的所有优先级相同的更新都收到相同的到期时间。。 // 我们跟踪两个不同的时间：当前的“渲染器”时间和当前的“调度器”时间。 渲染器时间可以随时更新。 它只是为了最大程度地降低通话性能。 // 但是，只有在没有待处理的工作，或者确定我们不在某个事件的中间时，才能更新调度程序时间。 if (isRendering) { // 此时在渲染中，直接返回当前作态 return currentSchedulerTime; } // Check if there's pending work. findHighestPriorityRoot(); if ( nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never ) { // 如果没有待处理的工作，那么返回当前的渲染时间 recomputeCurrentRendererTime(); // 此函数 直接修改了currentRendererTime currentSchedulerTime = currentRendererTime; return currentSchedulerTime; } // 有待处理的时间时, 返回上一次的计时器时间 return currentSchedulerTime; } recomputeCurrentRendererTimefunction recomputeCurrentRendererTime() { const currentTimeMs = now() - originalStartTimeMs; currentRendererTime = msToExpirationTime(currentTimeMs); } 过期时间计算 先来看看的当前计算过期时间的公式吧 // packages\\react-reconciler\\src\\ReactFiberExpirationTime.js export const NoWork = 0; export const Never = 1; export const Sync = MAX_SIGNED_31_BIT_INT; // 1073741823 const UNIT_SIZE = 10; const MAGIC_NUMBER_OFFSET = MAX_SIGNED_31_BIT_INT - 1; // ((ms / 10) | 0) 表示的是取整 2.5 | 0 = 2 // ms时间戳 到 expireationTime 的转换， 数值越大优先级越高 export function msToExpirationTime(ms: number): ExpirationTime { return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0); } export function expirationTimeToMs(expirationTime: ExpirationTime): number { return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE; } // 我们可以简单看成 num + 1 * precision， 也就是在一个precision 的范围内 function ceiling(num: number, precision: number): number { return (((num / precision) | 0) + 1) * precision; } //为了计算在某个bucket精度内的expirationTime，输入不同的expirationInMs,bucketSizeMs参数可以定义不同优先级的expirationTime function computeExpirationBucket( currentTime, expirationInMs, bucketSizeMs, ): ExpirationTime { return ( MAGIC_NUMBER_OFFSET - ceiling( MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE, ) ); } export const LOW_PRIORITY_EXPIRATION = 5000; export const LOW_PRIORITY_BATCH_SIZE = 250; // 计算异步事件过期时间，异步事件的优先级比较低 export function computeAsyncExpiration( currentTime: ExpirationTime, ): ExpirationTime { return computeExpirationBucket( currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE, ); } export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150; export const HIGH_PRIORITY_BATCH_SIZE = 100; // 计算交互事件过期时间，用户交互事件的优先级比较高 export function computeInteractiveExpiration(currentTime: ExpirationTime) { return computeExpirationBucket( currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE, ); } // 根据过期时间获取当前优先级， 立即执行，还是普通优先级还是用户交互优先级 export function inferPriorityFromExpirationTime( currentTime: ExpirationTime, expirationTime: ExpirationTime, ): ReactPriorityLevel { if (expirationTime === Sync) { return ImmediatePriority; } if (expirationTime === Never) { return IdlePriority; } const msUntil = msToExpirationTime(expirationTime) - msToExpirationTime(currentTime); if (msUntil &lt;= 0) { return ImmediatePriority; } if (msUntil &lt;= HIGH_PRIORITY_EXPIRATION) { return UserBlockingPriority; } if (msUntil &lt;= LOW_PRIORITY_EXPIRATION) { return NormalPriority; } return IdlePriority; } computeExpirationForFiber我们再回到 updateContainer 继续执行到 computeExpirationForFiber 传的参数是当前时间还有fiber function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) { let expirationTime; // 一开始 expirationContext = Nowork if (expirationContext !== NoWork) { expirationTime = expirationContext; } else if (isWorking) { if (isCommitting) { // 在提交阶段发生的更新应具有同步优先级 expirationTime = Sync; } else { // 更新阶段和渲染阶段的过期时间应该一样 expirationTime = nextRenderExpirationTime; } } else { // 计算新的过期时间 if (fiber.mode &amp; ConcurrentMode) { if (isBatchingInteractiveUpdates) { // 交互事件 expirationTime = computeInteractiveExpiration(currentTime); } else { // 异步事件，计算新的过期时间 expirationTime = computeAsyncExpiration(currentTime); } // 如果我们正在渲染树，请不要在已经渲染的到期时间进行更新。 if (nextRoot !== null &amp;&amp; expirationTime === nextRenderExpirationTime) { expirationTime -= 1; } } else { // 同步时间 expirationTime = Sync; } } if (isBatchingInteractiveUpdates) { // 跟踪最短的未执行互式到期时间。 if ( lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime &lt; lowestPriorityPendingInteractiveExpirationTime ) { lowestPriorityPendingInteractiveExpirationTime = expirationTime; } } return expirationTime; } updateContainerAtExpirationTimeexport function updateContainerAtExpirationTime( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component&lt;any, any>, expirationTime: ExpirationTime, callback: ?Function, ) { // 一样是fiber const current = container.current; // 获取 context 并赋值，这里肯定取不到值得，因为 parentComponent 为 null const context = getContextForSubtree(parentComponent); if (container.context === null) { container.context = context; } else { container.pendingContext = context; } return scheduleRootUpdate(current, element, expirationTime, callback); } scheduleRootUpdate 下面开始调度了 function scheduleRootUpdate( current: Fiber, element: ReactNodeList, expirationTime: ExpirationTime, callback: ?Function, ) { // 创建一个 update，就是内部有几个属性的对象 const update = createUpdate(expirationTime); // Caution: React DevTools currently depends on this property // being called \"element\". update.payload = {element}; // 我们的 callback 是null的所以直接不用考虑二楼 flushPassiveEffects(); // 把 update 入队，内部就是一些创建或者获取 queue（链表结构），然后给链表添加一个节点的操作 enqueueUpdate(current, update); scheduleWork(current, expirationTime); return expirationTime; }","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"两数之和 II - 输入有序数组","slug":"两数之和-II-输入有序数组","date":"2020-07-20T08:06:00.000Z","updated":"2020-07-31T08:56:34.257Z","comments":true,"path":"2020/07/20/两数之和-II-输入有序数组/","link":"","permalink":"http://yoursite.com/2020/07/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"两数之和 II - 输入有序数组 题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明： 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 代码/** * @param {number[]} numbers * @param {number} target * @return {number[]} */ var twoSum = function(numbers, target) { let start = 0; let end = numbers.length - 1; while(start &lt; end) { const temp = numbers[start] + numbers[end] if(temp === target) { return [start + 1, end + 1]; } // 2 + 15 > 9 因为是有序的所以, 应该从 end 减小 if(temp > target) { end--; } else { // 如果target = 22, // 2 + 15 &lt; 22 那么应该从start 往后移动 start++ } } return [start + 1, end + 1] };","categories":[],"tags":[{"name":"algorithm-双指针","slug":"algorithm-双指针","permalink":"http://yoursite.com/tags/algorithm-%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"删除链表的倒数第N个节点","slug":"删除链表的倒数第N个节点","date":"2020-07-20T07:10:32.000Z","updated":"2020-07-31T08:56:34.258Z","comments":true,"path":"2020/07/20/删除链表的倒数第N个节点/","link":"","permalink":"http://yoursite.com/2020/07/20/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"删除链表的倒数第N个节点 题目描述删除链表中倒数的第n个节点 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 分析 先遍历一次获得链表长度length 然后length - n 获取target, 当前target &lt; 0 时， p-&gt;next = p-&gt;next-&gt;next 源码/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ var removeNthFromEnd = function(head, n) { let root = new ListNode(\"head\"); root.next = head; let getLengthsPointer = head; let nums = 0; while(getLengthsPointer) { nums++; getLengthsPointer = getLengthsPointer.next; } let pointer = root; let target = nums - n; while(pointer) { target--; if(target &lt; 0) { pointer.next = pointer.next.next ? pointer.next.next : null; break; } pointer = pointer.next } return root.next; }; 进阶一次遍历, 思想： 用双指针，第一个指针与第二个指针 相隔n, 当第一个指针到达结尾时，那么第二个指针也到了倒数第n个数的前一个了。我们用上面 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 走一遍， n 为2 first 指向 3 , second 指向 head， 同时向后移动 当first 指向到 null的时候，second 走到了 3，此时可以将second.next 指向 second.next.next var removeNthFromEnd = function(head, n) { let root = new ListNode(\"head\"); root.next = head; let first = root; let second = root; for (let i = 1; i &lt;= n + 1; i++) { first = first.next; } while (first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; }","categories":[],"tags":[{"name":"algorithm-双指针","slug":"algorithm-双指针","permalink":"http://yoursite.com/tags/algorithm-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"algorithm-链表","slug":"algorithm-链表","permalink":"http://yoursite.com/tags/algorithm-%E9%93%BE%E8%A1%A8/"}]},{"title":"搜索插入位置","slug":"搜索插入位置","date":"2020-07-17T06:47:33.000Z","updated":"2020-07-19T05:03:38.052Z","comments":true,"path":"2020/07/17/搜索插入位置/","link":"","permalink":"http://yoursite.com/2020/07/17/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"35. 搜索插入位置 题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例： 输入: [1,3,5,6], 0输出: 0 思想 因为是有序的数组，所以我们可以使用二分法找到插入的位置 代码var searchInsert = function(nums, target) { // 二分查找 let left = 0; let right = nums.length - 1; while(left &lt; right) { let m = Math.floor( (right + left) / 2 ); if(nums[m] == target) { return m; } if(target &lt; nums[m]) { right = m - 1; } else { left = m + 1; } } let mid = Math.floor((right + left) / 2); mid = mid > 0 ? mid : 0; // 为了解决负数问题 // 最后我们已经知道了左边跟右边的边界了，然后我们用target 比对一下 nums[mid] 就知道是放在当前位置还是放在后面一个位置了 return target > nums[mid] ? mid + 1 : mid ; };","categories":[],"tags":[{"name":"algorithm-二分法","slug":"algorithm-二分法","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%88%86%E6%B3%95/"}]},{"title":"不同的二叉搜索树","slug":"不同的二叉搜索树","date":"2020-07-17T01:48:21.000Z","updated":"2020-07-19T05:03:38.051Z","comments":true,"path":"2020/07/17/不同的二叉搜索树/","link":"","permalink":"http://yoursite.com/2020/07/17/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"96. 不同的二叉搜索树 题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3搜索二叉树搜索二叉树： 左节点比根节点要小， 根节点永远比右节点要小。 左 &lt; 根 &lt; 右 思路 我们以 n = 5 为例子, [1, 2, 3, 4, 5] 当以3为根节点时， 根据左节点永远比根节点小， 那么左节点只能为 [1,2], 右节点为 [4, 5] 当 [1,2] 为左节点时, 又分成了两种情况， 当1为根节点时，2 为右节点；当 2 为根节点时， 1为左节点 当 [4,5] 为右节点时，跟上面类似 当以2 为根节点时，那么 左节点只有为 [1], 右节点为 [3,4,5] [3,4,5] 又可以以 3 或 4 或 5 做为根节点分析 3 为根节点 的时候为两种 4 为根节点的时候有一种 5 为根节点的时候又两种 所以你会发现节点有两个的时候 f(2) = 2; f(1) = 1, 左右节点相乘就可以得到总数了所以f(2) = f(0) * f(1) + f(1) * f(0)f(3) = f(0) * f(2) + f(1) * f(1) + f(2) * f(0)f[4] = f(0) * f(3) + f(1) * f(2) + f(2) * f(1) + f(3) * f(0) 代码var numTrees = function(n) { const dp = new Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i &lt;= n; ++i) { for (let j = 1; j &lt;= i; ++j) { dp[i] += dp[j - 1] * dp[i - j]; } } return dp[n]; };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"三角形最小路径和","slug":"三角形最小路径和","date":"2020-07-16T05:39:54.000Z","updated":"2020-07-19T05:03:38.051Z","comments":true,"path":"2020/07/16/三角形最小路径和/","link":"","permalink":"http://yoursite.com/2020/07/16/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","excerpt":"","text":"120. 三角形最小路径和 题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。我们用triangle 表示当前数组 i\\k k = 0 k = 1 k = 2 k = 3 i = 0 2 i = 1 3 4 i = 2 6 5 7 i = 3 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 思路这道题用动态规划，我一开始的想法是用一位数组的动态规划，后来提交发现失败了， 一开始想的递推公式是 dp[i + 1] = d[i] + Math.min(triangle[i][j], triangle[i][j + 1])后来发现是一个二维数组的动态规划 二维数组动态规划, 用dp 表示结果集 我们以 i 作为行, k 作为列， 注意题目的相邻节点 我们发现 当 k = 0 时, 那么他当前dp 值 应该是 dp[i][k] = dp[i-1][k] + triangle[i][k], dp[i][k] 因为 k = 0, 它只能从上往下走 我们看第三行即 i = 2时, 看 k = 1, dp[i][k] = triangle[i][k] + Math.min(dp[i - 1][k], dp[i - 1][k - 1]), 当 0 &lt; k &lt; column时我们dp[i][k] 应该 是用左上角的dp, 即dp[i - 1][k - 1]跟正上方的dp值，即dp[i - 1][k]取最小值 加上triangle[i][k] 同样是第三行即 i = 2时，看 k = 2, dp[i][k] = triangle[i][k] + dp[i - 1][k - 1], 此时 只能斜着走 即 2 -&gt; 4 -&gt; 这样走 dp 结果 i\\k k = 0 k = 1 k = 2 k = 3 i = 0 2 i = 1 5 6 i = 2 11 10（这里左上跟正上对比，取小的那个跟triangle相加） 13（这里只能斜着走，取6） i = 3 15 11 18 16 最后取最后一行的最小那个即可 代码var minimumTotal = function(triangle) { // dp[i + 1] = d[i] + Math.min(triangle[i][j], triangle[i][j + 1]) let i = 0; let dp = [] let row = triangle.length; while(i &lt; row) { let column = triangle[i].length; // 获取当前行的列数 let dpColumn = [] for(let k = 0; k &lt; column; k++) { if(k == 0) { // 列 = 0 时只能向下走， dpColumn.push(i == 0 ? triangle[i][k] : dp[i - 1][k] + triangle[i][k]) } else if(k &lt; column - 1) { // 列是中间列的话，就从正上方 或者左上方 dpColumn.push(Math.min(dp[i - 1][k], dp[i - 1][k - 1]) + triangle[i][k]); } else { // 最后一列的时候只能够斜着走 dpColumn.push(dp[i - 1][k - 1] + triangle[i][k]) } } dp.push(dpColumn); i++; } return Math.min.call(null, ...dp[i - 1]); };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"两个数组的交集 II","slug":"两个数组的交集-II","date":"2020-07-13T03:06:04.000Z","updated":"2020-07-19T05:03:38.052Z","comments":true,"path":"2020/07/13/两个数组的交集-II/","link":"","permalink":"http://yoursite.com/2020/07/13/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II/","excerpt":"","text":"两个数组的交集 II 题目描述就是给两个数组，求出他们的交集。 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 思路 使用map 记录其中一个数组数值出现的次数。 遍历另一个数组，判断当前数字是否在map中，是的话添加到结果集中，并且当前map[number] 的值减1， 不是的话，那代表不是交集 var intersect = function(nums1, nums2) { let result = []; let map = new Map(); for(let i = 0; i &lt; nums1.length; i++) { if(map.has(nums1[i])) { map.set(nums1[i], map.get(nums1[i]) + 1) } else { map.set(nums1[i], 1) } } for(let j = 0; j &lt; nums2.length; j++ ) { // 判断当前数字是否在map 中，并且当前map的值是否大于0， 大于0的意思是：map 中还有 没有取交集的数 if(map.has(nums2[j]) &amp;&amp; map.get(nums2[j]) > 0 ) { result.push(nums2[j]); map.set(nums2[j], map.get(nums2[j]) - 1) } } return result; }; 进阶 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 这里只给一个想法吧，既然数组已经排序好了， 那我们就使用双指针的方法去解决这个问题，一个数组一个指针，如果两个指针所指的数相等，那么两个指针向后移，不相等的话判断哪个数值比较大，小的那个向后移，如此类推","categories":[],"tags":[{"name":"algorithm-map","slug":"algorithm-map","permalink":"http://yoursite.com/tags/algorithm-map/"}]},{"title":"面试题 17.13. 恢复空格","slug":"面试题-17-13-恢复空格","date":"2020-07-11T02:51:30.000Z","updated":"2020-07-12T07:16:21.355Z","comments":true,"path":"2020/07/11/面试题-17-13-恢复空格/","link":"","permalink":"http://yoursite.com/2020/07/11/%E9%9D%A2%E8%AF%95%E9%A2%98-17-13-%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"面试题 17.13. 恢复空格 题目描述给定一个字典 dictionary 和 一串字符串sentence， 在这串字符串中尽可能多的从字典中找到相应的值，返回未识别的字符 输入：dictionary = [“looked”,”just”,”like”,”her”,”brother”]sentence = “jesslookedjustliketimherbrother”输出： 7解释： 断句后为”jess looked just like tim her brother”，共7个未识别字符。 解题思路 一开始想的是 根据我们现实生活中这样查字典这样，比如 looked, 先翻到L如果字典有l 开头的那再找 o 如果没有那直接退出，这时候就要构建字典树 我们直接遍历字符串sentence, 然后 跟字典里的那些 词对比一下，然后最小的那个就可以了 我们以 sentence = &#39;jelookedss&#39;, dictionary = [&quot;looked&quot;] 为例子 dp: i 0 1 2 3 4 5 6 7 8 9 10 sentence j e l o o k e d s s dp[] 0 1 2 3 4 5 6 7 2 3 4 请注意我们dp[0] = 0 所以dp[1] 对应的应该是 sentence[0], 就是后移了一位看上面的图，当我们i = 7 的时候 我们找到了looked，这是我们字典里的，所以我们dp[7+1] 的值应该是dp[2] =&gt; dp[7 - 6 + 1] 即 sentence[1] 的时候，因为前面的都是在字典中找不到的,替代公式： 要是找到的情况下 dp[i + 1] = Math.min(dp[i + 1], dp[i - 字典词长度 + 1]) 动态规划var respace = function(dictionary, sentence) { let dp = [0]; let length = sentence.length; if(dictionary.length == 0) { return length; } for(let i = 0; i &lt; length; i++) { dp[i + 1] = dp[i] + 1; for(let j = 0; j &lt; dictionary.length; j++ ) { const l = dictionary[j].length if(dictionary[j] == sentence.substring(i - l + 1 , i + 1 )) { dp[i + 1] = Math.min(dp[i + 1], dp[i - l + 1] ); } } } return dp[length]; }; 字典树var respace = function(dictionary, sentence) { let cache = [] for (let j = 0;j &lt; sentence.length + 1;j ++) { cache.push(new Map) } let dp = new Array(sentence.length+1).fill(0); let trie = {}; let n = sentence.length; if (sentence === \"\") return 0; // 构建字典树 for(let word of dictionary) { let node = trie; for(let c of word) { if (node[c] == undefined) { node[c] = {} } node = node[c]; } node[\"#\"] = \"#\"; } // 预处理出字典中存在的所有下标区间 cache[j].get[k] == true 表示[k,j]区间的单词在字典中能找到。 // 我们寻找字典开头，要是选找到开头的话继续往下找字典，要是遇到 # 那么就结束了，对于每个字符都是都一样，最后记录当前位置字符到字典结束的长度 for(let i = 1; i &lt;= n; i++) { let node = trie; for(let j = i; j &lt;= n; j++) { let c = sentence[j-1]; if (!node[c]) { break; } node = node[c]; if (node['#'] != undefined) { cache[j].set(i, true); } } } for (let j = 1;j &lt;= n;j ++) { dp[j] = dp[j-1] + 1; for(let [k,v] of cache[j]){ dp[j] = Math.min(dp[j], dp[k-1]) } } return dp[n]; };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Hexo自定义案例","slug":"hexo自定义","date":"2020-07-09T06:54:57.000Z","updated":"2020-07-31T08:56:34.256Z","comments":true,"path":"2020/07/09/hexo自定义/","link":"","permalink":"http://yoursite.com/2020/07/09/hexo%E8%87%AA%E5%AE%9A%E4%B9%89/","excerpt":"","text":"我使用的主题是chic 修改主题markdown的高亮代码我当前使用的主题是不支持jsx的，所以对于react代码不能友好支持。所以使用hexo-prism-plugin修改了高亮部分 坑: 我安装了 hexo-prism-plugin 之后发现还是无法高亮 jsx 代码， 后来发现还要要安装 hexo-inject 模块 npm install hexo-prism-plugin hexo-inject --save 修改_config.yml highlight: enable: false # 关闭默认的highlight prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'base16-ateliersulphurpool.light' # 主题 line_number: false # default false # custom_css: 'path/to/your/custom.css' 为主题图片添加大图主题无法对图片进行放大，图片最大也只是 780 * 562, 体验上不是很好，这里我使用了fancybox 进行修改 下载fancybox的文件 将 jquery.fancybox.min.js, jquery.min.js 放入 theme/chic/source/js 目录下 将 jquery.fancybox.min.css 放入 theme/chic/source/css/_lib/目录下 修改 chic/_config.yml, 添加代码 fancybox: enable: true jquery: /js/jquery.min.js fancyjs: /js/jquery.fancybox.min.js 修改 Chic/layout/_partial/head.ejs 添加以下代码 &lt;% if(theme.fancybox.enable!==null&amp;&amp;theme.fancybox.enable===true){ %> &lt;script type=\"text/javascript\" src=\"&lt;%- url_for(theme.fancybox.jquery) %>\">&lt;/script> &lt;script type=\"text/javascript\" src=\"&lt;%- url_for(theme.fancybox.fancyjs) %>\">&lt;/script> &lt;% } %> 在 Chic/source/css/style.styl 添加, @import \"_lib/jquery.fancybox.min.css\" 这里添加css 不知道为什么不可以直接 跟上面添加js 一样，我找了很久都没找到解决方案，只能够在style 下强行添加css 最后在 source/js/script.js 的document.ready()的回调回调函数添加 以下代码就可以 $(\"a.group\").fancybox({ 'transitionIn' : 'elastic', 'transitionOut' : 'elastic', 'speedIn' : 600, 'speedOut' : 200, 'overlayShow' : false }); 使用这里强行使用&lt;a class=&quot;group&quot;&gt;链接 包裹这img 表示使用fancybox &lt;a class=\"group\" rel=\"group1\" href=\"图片url\"> &lt;img src=\"图片url\" /> &lt;/a> 添加力扣页面 我这里是想自定义添加一个新的页面，主要放自己练习算法时的解题思路，叫力扣，但又不想跟原来发表的文章混在一起 添加文件夹 source/algorithm, 只有一个文件index.md # index.md --- title: 力扣 date: 2020-04-08 16:09:43 layout: algorithm --- 在Chic/layout 添加 algorithm.ejs &lt;%- partial('_page/algorithm', {pagination: config.archive, index: true}) %> 在Chic/layout/_page 添加 algorithm.ejs // Chic/layout/_page/algorithm.ejs &lt;div class=\"post-wrap algorithm-page archive\"> &lt;div class=\"tags-algorithm\"> // 这里就是算法 tag, 我只筛选出 tag包含 algorithm- 的那些 &lt;%site.tags.forEach(item=>{%> &lt;% if(item.name.includes(\"algorithm-\")) { %> &lt;a class=\"tags-item\" href=\"&lt;%-url_for(item.path)%>\">&lt;%- item.name.split(\"algorithm-\")[1] %>&lt;span class=\"nums\">&lt;%-item.length%>&lt;/%-item.length%>&lt;/span>&lt;/%->&lt;/a> &lt;% } %> &lt;%})%> 1 &lt; div> &lt;div class=\"\"archive\">\" 每页条数 &lt;% var perpage=\"config.algorithm_generator.per_page\" %> 这里我直接获取当前页面是第几页，没有page的话就是第一页 currentpage=\"url.match(/page\\/(.*)\\//)\" ? url.match( page\\ (.*)\\ )[1] : last_year=\"'';\" 然后我过滤掉 只是type=\"=\" 'algorithm'的那些文章， 这个type, 在我们新键文章的时候跟title，tag那些写在一起 posts=\"site.posts.filter((item)\" => item.type &amp;&amp; 'algorithm') 做一个排序, 按最新的排 posts.data=\"posts.data.sort((a,\" b)=\">\" b.date - a.date) 选择当前页面的文章 posts.slice((currentpage 1) * perpage, ).each(function (post) { cur_year=\"post.date.year();\" if(last_year !=\"=\" cur_year){ &lt;h3>&lt;%- %>&lt; h3> } &lt;article &lt;a href=\"\"&lt;%-\" url_for(post.path) %>\">&lt;%=\"post.title\" a> &lt;span date(post.date, theme.date_format) span> article> }) 分页 if(math.ceil(posts.length perpage) > &lt;nav &lt;%- paginator({ prev_next: false, end_size: 1, mid_size: 2, total: math.ceil(posts.length nav> div>&lt; code>&lt;/%})%>>&lt;/%>&lt;/%> 这里有个坑，我们点击 /algorithm/page/2 的时候会报当前页面存在，我通过 hexo-generator-category 找到类似的解决方案，我通过文档的生成器写了一个类似的解决方案 在 Chic/script 下添加 algorithm.js, 这里为了搞一个分页出来而已 var pagination = require('hexo-pagination'); // 要安装模块啊 hexo.extend.generator.register('algorithm', function(locals){ // 这里不能对locals.post 进行更改，一旦发生更改，网站变量 site.posts 的内容也会跟着更改，这里不知道是为什么，我纠结了很久 let allPost = locals.posts; return pagination('/algorithm', allPost, { perPage: this.config.algorithm_generator.per_page, // 在 _config.yml 添加 algorithm_generator: 配置 类似 category_generator layout: ['algorithm', 'archive', 'index'], // 如果algorith这个layout,没有就会用 archive， 如此类推 format: 'page' + '/%d/', data: { __index: true } }); }); 最后只要修改一下 Chic/layout/_page/archive.ejs 文件跟上面类似第三部就行了, 这里说一下 config ,可以从最外层 _config.yml进行配置 文章搜索 先执行 npm install hexo-generator-search -s, 这个插件是为了生成search.json, 他包含的是文章的基本信息 然后就是写 html 和 css了，我这里使用的是模态框，所以可以根据form 表单提交后唤出modal,然后进行ajax对search.json进行查询. 我们根据关键字对文章content进行匹配，匹配有的加入数组，然后对匹配成功的那些数据进行字符截取，另外对关键字做highlight操作 配置 _config.yml这里需要配置一下 root 下的 _config.yml, 添加以下代码 # search search: enable: true path: search.json field: post content: true 添加modal我这里直接写在了Chic/layout/layout.ejs, 我们只需要控制这个modal的display属性就好了 html&lt;!-- Chic/layout.ejs --> &lt;div id=\"u-search\"> &lt;div class=\"modal\"> &lt;div class=\"modal-header\"> &lt;div class=\"container\"> &lt;form id=\"u-search-modal-form\" class=\"u-search-modal-form\"> &lt;button type=\"submit\" class=\"form-submit-btn\"> &lt;img src=\"&lt;%- url_for(theme.searchImg) %>\" class=\"search-btn-img\" /> &lt;/button> &lt;input placeholder=\"搜索文章。。。\" class=\"form-input\" id=\"modal-form-input\"> &lt;/form> &lt;a class=\"modal-close\">x&lt;/a> &lt;/div> &lt;div class=\"search-loading\"> &lt;div class=\"search-loading-bar\">&lt;/div> &lt;/div> &lt;/div> &lt;div class=\"modal-body\"> &lt;!-- ul 格式如下 --> &lt;!-- &lt;ul class=\"modal-results\"> &lt;li class=\"result-item\"> &lt;a class=\"result-item-detail\"> &lt;span class=\"title\">页面配置&lt;/span> &lt;span class=\"content\"> content &lt;/span> &lt;/a> &lt;/li> &lt;/ul> --> &lt;/div> &lt;/div> &lt;div class=\"modal-overlay\">&lt;/div> &lt;/div> modal 样式我把他放在了Chic/source/css/_lib/search.css 这个要在 Chic\\source\\css\\style.styl 引用,添加代码 @import \"_lib/search.css\" 点击查看样式，这里是search.css 代码 #u-search { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; padding: 60px 20px; z-index: 1001; } #u-search .modal { position: fixed; height: 80%; width: 100%; max-width: 640px; left: 50%; top: 0; margin: 64px 0px 0px -320px; background: #fff; z-index: 3; border-radius: 4px; overflow: hidden; } #u-search .modal-header { position: relative; width: 100%; height: 64px; z-index: 3; border-top-left-radius: 4px; border-top-right-radius: 4px; font-size: 16px; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); background: #fff; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } #u-search .modal-header .container{ display: flex; flex-direction: row; align-items: center; padding: 0px; } #u-search .modal-header .container .u-search-modal-form { display: flex; flex-direction: row; align-items: center; flex: 1; } #u-search .u-search-modal-form .form-submit-btn { width: 50px; height: 64px; background: none; border: none; outline: none; margin: 0 5px 0 5px ; } #u-search .u-search-modal-form .form-submit-btn img { width: 33px; height: 33px; } #u-search .modal-header .container .u-search-modal-form .form-input { flex: 1; margin-right: 15px; border: none; padding: 10px 10px; outline: none; } #u-search .modal-header .modal-close { display: block; width: 55px; height: 64px; top: 0; right: 0; color: #2196f3; cursor: pointer; text-align: center; line-height: 64px; vertical-align: middle; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; z-index: 2; font-size: 22px; } #u-search .modal-header .search-loading { position: absolute; bottom: 0; left: 0; width: 100%; height: 2px; background: transparent; z-index: 1; } #u-search .modal-header .search-loading .search-loading-bar { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; position: relative; display: none; width: 0%; height: 100%; background: #2196f3; } #u-search .modal .modal-body { padding: 15px; height: calc(100% - 85px); overflow: auto; } #u-search .modal .modal-body::-webkit-scrollbar{ width: 5px; height: 5px; /**/ } #u-search .modal .modal-body::-webkit-scrollbar-track{ background: rgb(239, 239, 239); border-radius:2px; } #u-search .modal .modal-body::-webkit-scrollbar-thumb{ background: #bfbfbf; border-radius:10px; } #u-search .modal .modal-body::-webkit-scrollbar-thumb:hover{ background: #333; } #u-search .modal .modal-body::-webkit-scrollbar-corner{ background: #179a16; } #u-search .modal .modal-body .modal-results { list-style: none; padding-left: 0; margin: 0px; } #u-search .modal .modal-body .modal-results .result-item { padding: 15px; } #u-search .modal .modal-body .modal-results .result-item:hover { background: #e8f4fd; } #u-search .modal .modal-body .modal-results .result-item .result-item-detail { display: flex; flex-direction: column; } #u-search .modal .modal-body .modal-results .result-item .result-item-detail .title { color: #6e6e6e; font-weight: 700; font-size: 18px; margin-bottom: 10px; } #u-search .modal .modal-body .modal-results .result-item .result-item-detail .content { display: block; white-space: inherit; word-break: break-all; text-overflow: ellipsis; font-size: 14px; color: rgba(85,85,85,0.65); letter-spacing: 1px; user-select: none; } #u-search .search-keyword { color: #0c7cd5; text-decoration: underline; font-weight: bold; font-style:normal } #u-search .modal-body .no-result { display: flex; flex-direction: column; align-items: center; justify-content: center; } #u-search .modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1; } @media screen and (max-width: 680px) { #u-search { padding: 0px; display: none; } #u-search .modal { box-shadow: none; max-width: none; top: 0; left: 0; margin: 0; height: 100%; border-radius: 0; } #u-search .modal-header { border-radius: 0; padding: 0px; } } .modal-active { position: fixed; top: 0; left: 0; right: 0; bottom: 0; } /* 以下是搜索框 */ .search { margin-right: 6px; display: flex; flex-direction: row; align-items: center; } .search .form-search { padding: 10px 8px; } .search .form-search .input { display: block; line-height: 1.3; color: #555; background: #e8e8e8; padding: 5px 8px; box-shadow: none; box-sizing: border-box; font-size: 1rem; border-radius: 8px; border: none; outline: none; } .search .search-btn { width: 22px; height: 22px; line-height: 22px; margin-right: 5px; } .search .search-btn .search-btn-img { height: 100%; width: 100%; } @media screen and (max-width: 479px) { .navbar-mobile-right { display: flex; flex-direction: row; align-items: center; } .search .search-btn { cursor: pointer; } .search .form-search { display: none; } .mobile-search { position: absolute; top: 0px; left: 0px; right: 50px; padding-left: 15px; background: #fff; height: 80px; display: flex; flex-direction: row; margin-right: 15px; } .mobile-search .form-search { display: block; flex: 1; } .mobile-search .input { width: 100%; } } 增加搜索框我把该文件放在了 Chic/layout/_partial/search.ejs &lt;% if(config.search &amp;&amp; config.search.enable ) { %> &lt;div class=\"search \"> &lt;div class=\"search-btn\" onClick=\"searchToggle()\"> &lt;img src=\"&lt;%- url_for(theme.searchImg) %>\" class=\"search-btn-img\" /> &lt;/div> &lt;form class=\"form-search\"> &lt;input class=\"input\" placeholder=\"搜索文章\" autocomplete=\"off\" id=\"&lt;%= name %>-search-input\"/> &lt;/form> &lt;/div> &lt;% } %> 我们在 Chic\\layout\\_partial\\header.ejs 添加这个搜索框, 要在pc的menu, 和mobile的menu添加, &lt;% var defaultName = 'pc' %> &lt;%- partial('_partial/search', { name: defaultName }) %> // 这里是 mobile 的menu &lt;div class=\"navbar-mobile-right\"> &lt;% var type = 'mobile' %> &lt;%- partial('_partial/search', { name: type }) %> &lt;div class=\"menu-toggle\" onclick=\"mobileBtn()\">&amp;#9776; 目录&lt;/div> &lt;/div> 添加搜索框的js, 搜索代码创建搜索代码 点击查看代码 &lt;script> function searchToggle() { const width = $(document.body).width() if(width > 479) { return; } const search = $('.search'); const searchForm = $('.form-search') if(!search.hasClass(\"mobile-search\")) { search.addClass(\"mobile-search\"); } else { search.removeClass(\"mobile-search\"); } } function search(searchInputEl, formEl, flag) { const path = \"&lt;%= config.root %>\" + \"&lt;%= config.search.path %>\"; // 可以在public 下查看这个search.json $(formEl).submit(function(e){ e.preventDefault(); let target = null if(searchInputEl == null) { const screenWidth = $(document.body).width(); target = screenWidth > 479 ? $('#pc-search-input') : $('#mobile-search-input'); console.log(target); } else { target = $(searchInputEl) } if(!flag &amp;&amp; target.val() === '') { return ; } $(\"#u-search\").fadeIn(500, function() { $(\"body > .wrapper\").addClass(\"modal-active\"); $.ajax({ url: path, dataType: \"json\", beforeSend: function (xhr) { $input = target.val(); $(\".form-input\").val($input); const loadingBar = $('.search-loading-bar') loadingBar.css({ width:'100%', display: 'block' }); }, success: function( datas ) { // console.log(datas); const $resultPanel = $(\".modal-body\")[0]; let str = `&lt;ul class=\"modal-results\">`; var keywords = $(\".form-input\").val().trim().toLowerCase().split(/[\\s\\-]+/); $resultPanel.innerHTML = \"\"; let hasResult = false let text = `&lt;div class=\"no-result\">找不到与关键词相关的内容....&lt;/div>`; if ($(\".form-input\").val().trim().length &lt;= 0) { // 没有结果 $resultPanel.innerHTML = text; return; } datas.forEach(function (data) { var isMatch = true; if (!data.title || data.title.trim() === '') { data.title = \"Untitled\"; } var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^>]+>/g, \"\").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty contents if (data_content !== '') { keywords.forEach(function (keyword, i) { index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if (index_title &lt; 0 &amp;&amp; index_content &lt; 0) { isMatch = false; } else { hasResult = true if (index_content &lt; 0) { index_content = 0; } if (i == 0) { first_occur = index_content; } } }); } else { isMatch = false; } // show search results if (isMatch) { str += `&lt;li class='result-item'>&lt;a href='${data_url}' class='result-item-detail'> &lt;span class=\"title\">${data_title}&lt;/span>`; var content = data.content.trim().replace(/&lt;[^>]+>/g, \"\"); if (first_occur >= 0) { // cut out 200 characters var start = first_occur - 40; var end = first_occur + 160; if (start &lt; 0) { start = 0; } if (start == 0) { end = 200; } if (end > content.length) { end = content.length; } var match_content = content.substring(start, end); // highlight all keywords keywords.forEach(function (keyword) { var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, `&lt;em class=\"search-keyword\">${keyword}&lt;/em>`); }); str += `&lt;span class=\"content\"> ${match_content} ...&lt;/span>&lt;/a>`; } str += \"&lt;/li>\"; } }); str += \"&lt;/ul>\"; if(hasResult) { $resultPanel.innerHTML = str; } else { $resultPanel.innerHTML = text; } }, complete: function() { setTimeout(() => { const loadingBar = $('.search-loading-bar') loadingBar.css({ width:'0%', display: 'none' }); }, 300) } }); }) }); } $(document).ready(function() { $('.modal-close').click(function () { $(\"#u-search\").fadeOut(); $(\"body > .wrapper\").removeClass(\"modal-active\") }) $('.modal-overlay').click(function() { $(\"#u-search\").fadeOut(); $(\"body > .wrapper\").removeClass(\"modal-active\") }) search(null, \".form-search\", false) search(\"#u-search-modal-form .form-input\", \".u-search-modal-form\", true) }) &lt;/script> 在 themes\\Chic\\layout\\_partial\\head.ejs中添加上面的以下代码，表示启动js &lt;%# search %> &lt;% if(config.search &amp;&amp; config.search.enable ) { %> &lt;%- partial('_plugins/search.ejs') %> &lt;% } %> 以上就是创建搜索框的全过程了，当然了我上面写的有点乱，可以自行整理一下","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"路径总和","slug":"路径总和","date":"2020-07-07T03:02:09.000Z","updated":"2020-07-11T02:42:03.856Z","comments":true,"path":"2020/07/07/路径总和/","link":"","permalink":"http://yoursite.com/2020/07/07/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","excerpt":"","text":"题目描述1给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例1 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 [5,4,8,11,null,13,4,7,2, null, null,null,1]22 思想 注意：题目说了叶子节点是没有子节点的节点，那么我们只要判断一下当前节点有没有root.left 和 root.right 即可， 另外每次递归都减去当前target = sum - root.val, 然后递归左右子树就可以了 递归实现/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {number} sum * @return {boolean} */ var hasPathSum = function(root, sum) { if(root == null ) { return false; } const value = root.val; const target = sum - value; if(target == 0 &amp;&amp; (root.left == null &amp;&amp; root.right == null)) { return true; } return hasPathSum(root.left, target) || hasPathSum(root.right, target) };","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"63. 不同路径 II","slug":"63-不同路径-II","date":"2020-07-06T06:53:49.000Z","updated":"2020-07-11T02:42:03.853Z","comments":true,"path":"2020/07/06/63-不同路径-II/","link":"","permalink":"http://yoursite.com/2020/07/06/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/","excerpt":"","text":"63. 不同路径 II 题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 分析题目说明每次 只能向下或者向右移动一步。那么我们分析每次走到a[m][n] 只能从上面那个格子a[m - 1][n] 或者从左边那个格子a[m][n - 1]过来，我们定义 a[m][n]是到当前格子的有多少种路径数。 所以我们的递推公式是： a[m][n] = a[m - 1][n] + a[m][n - 1]; 注意： 第一行我们只能向右走， 第一列只能向下走。 如果上面或者左边格子是障碍物， 那么当前格子应该是 0， 但其实也符合 a[m][n] = a[m - 1][n] + a[m][n - 1] 这个递推公式，这样我们判断格子是否是障碍物那么我们就设置为 0； 代码/** * @param {number[][]} obstacleGrid * @return {number} */ var uniquePathsWithObstacles = function(obstacleGrid) { let result = []; let row = obstacleGrid.length; let column = obstacleGrid[0].length // 递推公式是 result[i][j] = result[i][j - 1] + result[i - 1][j] for(let i = 0; i &lt; row; i++) { if(typeof result[i] == 'undefined') { result[i] = []; } for(let j = 0; j &lt; column; j++) { let temp = obstacleGrid[i][j] if(i === 0 &amp;&amp; j === 0) { result[i][j] = temp === 1 ? 0 : 1; } // 第一行只能向右走, 并且判断一下当前是不是障碍物，是的话那么走到当前路线的次数应该为0 if(i === 0 &amp;&amp; j > 0) { let tempLeft = obstacleGrid[i][j - 1]; result[i][j] = tempLeft || temp ? 0 : result[i][j - 1] ; } // 第一列只能向下走，并且判断一下当前是不是障碍物 if(j === 0 &amp;&amp; i > 0) { let tempUp = obstacleGrid[i - 1][j]; result[i][j] = (tempUp || temp ? 0 : result[i- 1][j]); } if(i > 0 &amp;&amp; j > 0) { const up = result[i - 1][j]; const left = result[i][j - 1]; result[i][j] = temp == 1 ? 0 : ( up + left); } } } return result[row - 1][column - 1] };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"108. 将有序数组转换为二叉搜索树","slug":"108-将有序数组转换为二叉搜索树","date":"2020-07-03T06:16:44.000Z","updated":"2020-07-11T02:42:03.852Z","comments":true,"path":"2020/07/03/108-将有序数组转换为二叉搜索树/","link":"","permalink":"http://yoursite.com/2020/07/03/108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"108. 将有序数组转换为二叉搜索树 题目描述将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例： 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / \\ / -10 n 5 我们再来看一个示例 示例2: nums = [1,2,3,4,5,6,7,8,9,10,11,12], length = 12 7 / \\ 4 10 / \\ / \\ 2 6 9 12 / \\ / \\ /\\ / 1 3 5 n 8 n 11 分析上面 n 代表的是null, 我们直接看示例2的根节点的排列情况 7 的index 为 Math.floor(nums.length / 2) 4 的index 为 1~7的一半， 我们称为左半边的一半 10 的index 为 8~12的一半，我们称为右半边的一半 所以我们总结上面获取根节点的情况是nums[Math.floor(nums.length / 2)],然后反复获取左右半数组进行截取，再获取根节点，这里是一次递归 当nums.length 为0 的时候，我们返回null 根节点的左边数组为左子节点，右数组为右子节点 我们模拟一下nums = [1,2,3]的时候 我们取root = new TreeNode(nums[Math.floor(nums.length / 2)])即为2当根节点。当前左数组为[1], 右半数组为[3] 左节点 应该是左半数组组成的左子树, 左半数组剩下[1], 当前子树root = new TreeNode(nums[Math.floor(nums.length / 2)]), 所以根节点为1, 而后当前左右数组都为[], 再来root.left = 回到第一步 当前数组的长度为0, 所以root.left = null, 所以整个流程是root = 2, root.left = 1, root.left.left = null 右节点跟左节点一样 源码/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ var sortedArrayToBST = function(nums) { //如果当前length 为奇数的话，那切一半，length / 2 + 1 为当前root，偶数为 length / 2 const root = half(nums) return root; }; var half = function(nums) { if(nums.length == 0) { return null } const currentIndex = Math.floor(nums.length / 2); const rootValue = nums[currentIndex]; const currentRoot = new TreeNode(rootValue) // 分治 let left = nums.slice(0, currentIndex); let right = nums.slice(currentIndex + 1); currentRoot.left = half(left); currentRoot.right = half(right); return currentRoot; }","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Z 字形变换","slug":"Z-字形变换","date":"2020-06-30T10:34:47.000Z","updated":"2020-07-11T02:42:03.854Z","comments":true,"path":"2020/06/30/Z-字形变换/","link":"","permalink":"http://yoursite.com/2020/06/30/Z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","excerpt":"","text":"Z 字形变换 其实这道题就是移到数学题 分析 以 LEETCODEISHIRING 为示例，分别对row = 3, row = 4, row = 5, 进行分析, 括号表示index row = 3 row/column c = 0 c = 1 c = 2 c = 3 c = 4 c = 5 c = 6 c = 7 r = 0 L(0) C(4) I(8) R(12) r = 1 E(1) T(3) O(5) E(7) S(9) I(11) I(13) G(15) r = 2 E(2) D(6) H(10) N(14) row = 4 row/column c = 0 c = 1 c = 2 c = 3 c = 4 c = 5 c = 6 r = 0 L(0) D(6) R(12) r = 1 E(1) O(5) E(7) I(11) I(13) r = 2 E(2) C(4) I(8) H(10) N(14) r = 3 T(3) S(9) G(15) row = 5 row/column c = 0 c = 1 c = 2 c = 3 c = 4 c = 5 c = 6 c = 7 r = 0 L(0) I(8) r = 1 E(1) E(7) S(9) G(15) r = 2 E(2) D(6) H(10) N(14) r = 3 T(3) O(5) I(11) I(13) r = 4 C(4) R(12) 我们看这三个 r = 0时，第一个数跟第二数的偏移， 我们称这个为总偏移量 row = 3时, 偏移为 4 - 0 = 4 row = 4时，偏移为 6 - 0 = 6 row = 5时，偏移为 8 - 0 = 8 总结： 偏移 = 2 * row - 2 再看 r = 1时，就是第二行数据， 第一个数跟第二个数以及第三个数的偏移 row = 3 时，偏移为 3 - 1 = 2， 5 - 3 = 2， 上面总偏移量为4，所以第3个数跟第2个数的偏移量为 4-2 =2 row = 4 时，偏移为 5 - 1 = 4， 7 - 5 = 2， 上面总偏移量为6，所以第3个数跟第2个数的偏移量为 6-4 =2。 这一行往后的偏移是 4, 2, 4, 2, 4, 2 这样走 row = 5 时，偏移为 7 - 1 = 6， 9 - 7 = 2， 上面总偏移量为8，所以第3个数跟第2个数的偏移量为 6-4 =2。 这一行往后的偏移是 6, 2, 6, 2, 6, 2 这样 直到前一个数 + 偏移量 &gt;= s.length换下一行。 总结：第一个数与第二个数偏移量为 2 * (row - (r + 1)), 而第二个数跟第三个数的偏移量为 （总偏移量 - 第一个数跟第二个数的偏移量） 往后如此类推，但最后一行跟第一行的偏移量应该一样 源码var convert = function(s, numRows) { let result = []; let length = s.length; if(numRows == 1) { return s; } let totalOffset = 2 * numRows - 2; // 总偏移量 let flag = true; // 标志位 let i = 0; // 表示数组中有几个数 let row = 1; // 表示 第几行 let start = 0; // 表示 当前index let offset = 2 * (numRows - row); while(i &lt; length) { result.push(s[start]); // 第一行的偏移量跟最后一行的偏移量一样 if(row == 1 || row == numRows) { start = start + totalOffset; } else { if(flag) { start = start + offset; flag = false; } else { start = start + (totalOffset - offset); flag = true; } } i++; // 换下一行，同时计算他的偏移值，把flag 重置 if(start >= length) { row++; start = row - 1; flag = true offset = 2 * (numRows - row); } } return result.join(\"\") };","categories":[],"tags":[{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"},{"name":"algorithm-数组","slug":"algorithm-数组","permalink":"http://yoursite.com/tags/algorithm-%E6%95%B0%E7%BB%84/"}]},{"title":"数组中的第K个最大元素","slug":"数组中的第K个最大元素","date":"2020-06-29T03:24:02.000Z","updated":"2020-07-11T02:42:03.856Z","comments":true,"path":"2020/06/29/数组中的第K个最大元素/","link":"","permalink":"http://yoursite.com/2020/06/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","excerpt":"","text":"数组中的第K个最大元素 题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 输入: [3,2,1,5,6,4] 和 k = 2输出: 5解释：排序后数组结果[1,2,3,4,5,6], 取第二大的那个数就是 5 分析 这个题目直接想就是数组通过排序后获取倒数第k个数 这里我使用快速排序 代码// 快速排序 function quicksort(nums, low, high) { let i; let j; let s; while (high > low) { i = low; j = high; s = nums[low]; while (i &lt; j) { while (nums[j] > s) { j--; } nums[i] = nums[j]; while (s >= nums[i] &amp;&amp; i &lt; j) { i++; } nums[j] = nums[i]; } nums[i] = s; quicksort(nums, low, i - 1); low = i + 1; } return nums; } var findKthLargest = function(nums, k) { const newNums = quicksort(nums, 0, nums.length - 1); return newNums[nums.length - k]; };","categories":[],"tags":[{"name":"algorithm-排序","slug":"algorithm-排序","permalink":"http://yoursite.com/tags/algorithm-%E6%8E%92%E5%BA%8F/"},{"name":"algorithm-快速排序","slug":"algorithm-快速排序","permalink":"http://yoursite.com/tags/algorithm-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"React源码-ReactDOM","slug":"React源码-ReactDOM","date":"2020-06-28T02:46:51.000Z","updated":"2020-07-31T08:56:34.254Z","comments":true,"path":"2020/06/28/React源码-ReactDOM/","link":"","permalink":"http://yoursite.com/2020/06/28/React%E6%BA%90%E7%A0%81-ReactDOM/","excerpt":"","text":"文件目录packages/react-dom/src/ReactDOM.js 用法ReactDOM.render(&lt;App />, document.getElementById(\"root\")); 源码ReactDOM.renderconst ReactDOM: Object = { /** * element => &lt;App /> * container => document.getElementById(\"root\") * callback => 回调函数 很少用 */ render( element: React$Element&lt;any>, container: DOMContainer, callback: ?Function, ) { // 下面第四个参数为false， 如果为true那么说明是服务端渲染 return legacyRenderSubtreeIntoContainer( null, element, container, false, callback, ); }; 先为container创建_reactRootContainer属性，其类型是ReactRoot, 同时在这一步中删除掉container中的所有子集 legacyRenderSubtreeIntoContainer/** * parentComponent => null * children => &lt;App> * container => document.getElementById(\"root\") * forceHydrate => false * callback => callback */ function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component&lt;any, any>, children: ReactNodeList, container: DOMContainer, forceHydrate: boolean, callback: ?Function, ) { let root: Root = (container._reactRootContainer: any); // 当前 container 没有 _reactRootContainer, 进去if操作执行legacyCreateRootFromDOMContainer if (!root) { // 初始化操作，创建_reactRootContainer属性， 类型是ReactRoot root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate, ); // 反正我从没传过 callback，不关心实现 if (typeof callback === 'function') { const originalCallback = callback; callback = function() { const instance = getPublicRootInstance(root._internalRoot); originalCallback.call(instance); }; } // Initial mount should not be batched. // 第一次加载的话不需要打包更新 unbatchedUpdates(() => { // 第一次不存在 parentComponent, 然后调用ReactRoot.prototype.render if (parentComponent != null) { root.legacy_renderSubtreeIntoContainer( parentComponent, children, callback, ); } else { root.render(children, callback); } }); } else { if (typeof callback === 'function') { const originalCallback = callback; callback = function() { const instance = getPublicRootInstance(root._internalRoot); originalCallback.call(instance); }; } // Update if (parentComponent != null) { root.legacy_renderSubtreeIntoContainer( parentComponent, children, callback, ); } else { root.render(children, callback); } } return getPublicRootInstance(root._internalRoot); } legacyCreateRootFromDOMContainer 该方法是删除container下的子节点，并且生成ReactRoot function legacyCreateRootFromDOMContainer( container: DOMContainer, forceHydrate: boolean, ): Root { // 这个变量跟服务端渲染有关，我们直接把他看成false const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); if (!shouldHydrate) { let rootSibling; // 这里直接把container的子节点删除，直到没有子节点 // &lt;div id=\"root\">&lt;/div> while ((rootSibling = container.lastChild)) { container.removeChild(rootSibling); } } // 默认情况下root不用异步 const isConcurrent = false; return new ReactRoot(container, isConcurrent, shouldHydrate); } ReactRoot 我们看ReactRoot这个结构函数 createContainer就是一行代码它的作用是创建FiberRoot, 而这个root 其实又是 FiberRootNode 然后创建Fiber, createFiber(HostRoot, null, null, mode);, 然后又返回了FiberNode, 此时container拥有_reactRootContainer属性, 而 _reactRootContainer 拥有 _internalRoot属性, 而_internalRoot又拥有current属性，这个属性类型就是FiberNode 我们可以在react 项目下 打印一下 document.getElementById(&quot;root&quot;)._reactRootContainer /** * container => &lt;div id=\"root\">&lt;/div> * isConcurrent => false * hydrate => false */ function ReactRoot( container: DOMContainer, isConcurrent: boolean, hydrate: boolean, ) { // 这个 root 指的是 FiberRoot // 文件路径 packages/react-reconciler/src/ReactFiberReconciler.js // createContainer 很简单就一行代码 // return createFiberRoot(containerInfo, isConcurrent, hydrate); const root = createContainer(container, isConcurrent, hydrate); this._internalRoot = root; } ReactRoot.prototype.render = function( children: ReactNodeList, callback: ?() => mixed, ): Work { // 这里就是之前的那个createFiberRoot创建的FiberRoot const root = this._internalRoot; // ReactWork 的功能就是为了在组件渲染或更新后把所有传入 // ReactDom.render 中的回调函数全部执行一遍 const work = new ReactWork(); callback = callback === undefined ? null : callback; // 如果有 callback，就 push 进 work 中的数组 if (callback !== null) { work.then(callback); } // work._onCommit 就是用于执行所有回调函数的 updateContainer(children, root, null, work._onCommit); return work; }; // 其实这里的名字已经表达了意思了，将subTree渲染进container ReactRoot.prototype.legacy_renderSubtreeIntoContainer = function( parentComponent: ?React$Component&lt;any, any>, children: ReactNodeList, callback: ?() => mixed, ): Work { const root = this._internalRoot; const work = new ReactWork(); callback = callback === undefined ? null : callback; if (callback !== null) { work.then(callback); } updateContainer(children, root, parentComponent, work._onCommit); return work; }; createContainerexport function createContainer( containerInfo: Container, isConcurrent: boolean, hydrate: boolean, ): OpaqueRoot { return createFiberRoot(containerInfo, isConcurrent, hydrate); } createFiberRootexport function createFiberRoot( containerInfo: any, isConcurrent: boolean, hydrate: boolean, ): FiberRoot { // FiberRootNode 内部创建了很多属性 const root: FiberRoot = (new FiberRootNode(containerInfo, hydrate): any); // document.getElementById(\"root\").._reactRootContainer._internalRoot 是 FiberRoot // document.querySelector('#root')._reactRootContainer._internalRoot.current 是 Fiber const uninitializedFiber = createHostRootFiber(isConcurrent); root.current = uninitializedFiber; uninitializedFiber.stateNode = root; return root; } createHostRootFiberexport function createHostRootFiber(isConcurrent: boolean): Fiber { let mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext; if (enableProfilerTimer &amp;&amp; isDevToolsPresent) { mode |= ProfileMode; } // HostRoot 指的是 classComponent, lazyComponent, functionCompoenent 等等 return createFiber(HostRoot, null, null, mode); } createFiber我们可以从 packages/react-reconciler/src/ReactFiber.js 查看Fiber 的属性 const createFiber = function( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ): Fiber { return new FiberNode(tag, pendingProps, key, mode); }; FiberRoot 的结构 点击查看FiberRoot type BaseFiberRootProperties = {| // Any additional information from the host associated with this root. // 就是 document.getElementById(\"root\") containerInfo: any, // 仅用于持久更新。 pendingChildren: any, // 当前应用对应的Fiber对象，是Root Fiber current: Fiber, // 以下优先级用于区分 // 1) 没有提交(committed)的任务 // 2) 没有提交的挂起任务 // 3) 没有提交的可能被挂起的任务 // 我们选择不追踪每个单独的阻塞登记，为了兼顾性能而是按交易粒度来衡量绩效。 earliestSuspendedTime: ExpirationTime, latestSuspendedTime: ExpirationTime, // The earliest and latest priority levels that are not known to be suspended. earliestPendingTime: ExpirationTime, latestPendingTime: ExpirationTime, // 最新通过的一个被reslove并且可以重新尝试的优先级 latestPingedTime: ExpirationTime, pingCache: | WeakMap&lt;Thenable, Set&lt;ExpirationTime>> | Map&lt;Thenable, Set&lt;ExpirationTime>> | null, // 如果抛出错误，并且队列中没有更多更新，则在处理该错误之前，我们尝试从根目录再次进行一次同步渲染。 didError: boolean, // 正在等待提交的任务的`expirationTime` pendingCommitExpirationTime: ExpirationTime, finishedWork: Fiber | null, // 超时的操作 timeoutHandle: TimeoutHandle | NoTimeout, // Top context object, used by renderSubtreeIntoContainer context: Object | null, pendingContext: Object | null, // Determines if we should attempt to hydrate on the initial mount +hydrate: boolean, // Remaining expiration time on this root. // TODO: Lift this into the renderer nextExpirationTimeToWorkOn: ExpirationTime, expirationTime: ExpirationTime, // List of top-level batches. This list indicates whether a commit should be // deferred. Also contains completion callbacks. // TODO: Lift this into the renderer firstBatch: Batch | null, // root之间关联的链表结构 nextScheduledRoot: FiberRoot | null, // New Scheduler fields callbackNode: *, callbackExpirationTime: ExpirationTime, firstPendingTime: ExpirationTime, lastPendingTime: ExpirationTime, pingTime: ExpirationTime, |}; type ProfilingOnlyFiberRootProperties = {| interactionThreadID: number, memoizedInteractions: Set&lt;Interaction>, pendingInteractionMap: PendingInteractionMap, |}; export type FiberRoot = { ...BaseFiberRootProperties, ...ProfilingOnlyFiberRootProperties, }; FiberRoot 的结构是上面两个合起来 Fiber 结构 点击查看Fiber export type Fiber = {| // 指的是functionComponent 还是 classComponent等等， lazyComponent tag: WorkTag, // Unique identifier of this child. key: null | string, // The value of element.type which is used to preserve the identity during // reconciliation of this child. elementType: any, // The resolved function/class/ associated with this fiber. type: any, // 本地相关联的Fiber stateNode: any, // 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回 return: Fiber | null, // 子节点，兄弟节点 child: Fiber | null, sibling: Fiber | null, index: number, // 就是ref ref: null | (((handle: mixed) => void) &amp; {_stringRef: ?string}) | RefObject, // 将要处理的props, 罪行的props pendingProps: any, // This type will be more specific once we overload the tag. // 上一次的props memoizedProps: any, // The props used to create the output. // A queue of state updates and callbacks. // 用来存放 update，也就是用来记录改变状态的 updateQueue: UpdateQueue&lt;any> | null, // 上一次的state memoizedState: any, // A linked-list of contexts that this fiber depends on contextDependencies: ContextDependencyList | null, mode: TypeOfMode, // Effect effectTag: SideEffectTag, // Singly linked list fast path to the next fiber with side-effects. nextEffect: Fiber | null, firstEffect: Fiber | null, lastEffect: Fiber | null, // Represents a time in the future by which this work should be completed. // Does not include work found in its subtree. expirationTime: ExpirationTime, // This is used to quickly determine if a subtree has no pending changes. childExpirationTime: ExpirationTime, alternate: Fiber | null, actualDuration?: number, actualStartTime?: number, selfBaseDuration?: number, treeBaseDuration?: number, |}; Fiber结构图 函数运行流程图 从demo查看","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"二进制求和","slug":"二进制求和","date":"2020-06-23T09:57:20.000Z","updated":"2020-06-25T02:57:29.046Z","comments":true,"path":"2020/06/23/二进制求和/","link":"","permalink":"http://yoursite.com/2020/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/","excerpt":"","text":"67. 二进制求和 题目描述给定两个二进制字符串，两个相加返回结果 输入: a = “1010”, b = “1011”输出: “10101” 解决方案将指针指向字符串最后一位，两两相加再加上仅为，注意处理进位，两字符串的当前值为1时 * 当前进位为0时，那么1 + 1 + 0 = 2 ，二进制要进位，当前值应该为2 % 2 = 0。进位变为1 * 当前仅为为1时，那么1 + 1 + 1 = 3 ，二进制要进位，当前值应为 3 % 2 = 1。 进位为1 * 将当前值放到数组头部 i = 0 i = 1 i = 2 i = 3 a数组 1 1 1 b数组 1 0 1 result 1 0 0 0 代码var addBinary = function(a, b) { let aLength = a.length; let bLength = b.length; let i = aLength - 1; let j = bLength - 1; let result = []; let add = 0; // 进位 while(i >= 0 || j >= 0) { let atemp = i >= 0 ? a[i] * 1 : 0; // 对i判定大于0为了防止数组溢出 let btemp = j >= 0 ? b[j] * 1 : 0; let current = atemp + btemp + add; if(current >= 2) { add = Math.floor(current / 2); } else { add = 0; } result.unshift(current % 2); // 将当前值放入到数组头 i--; j--; } // 退出循环后如果数组为1表示有进位，那也要加到数组头 if(add != 0) { result.unshift(add) } return result.join(\"\") };","categories":[],"tags":[{"name":"algorithm-双指针","slug":"algorithm-双指针","permalink":"http://yoursite.com/tags/algorithm-%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"盛最多水的容器","slug":"盛最多水的容器","date":"2020-06-23T08:12:00.000Z","updated":"2020-06-25T02:57:29.047Z","comments":true,"path":"2020/06/23/盛最多水的容器/","link":"","permalink":"http://yoursite.com/2020/06/23/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","excerpt":"","text":"11. 盛最多水的容器 题目描述给定一个数组，数组存放的是每个元素的高度，以数组的key做x轴， a[key]做y轴 计算出其中两条与x轴形成的最大面积。 以[1,8,6,2,5,4,8,3,7]为例子最大的面积为49， 以x1轴为1，y1轴为8， 和x2为8，y2为7构成的面积最大为49 暴力破解我们可以用两重循环的方式暴力破解，可是我可以看出我们其实做了一些没必要的计算， * i = 0时，j = 1, j = 2, j = 3, .....j = 7这些都是没必要计算的 * i = 1时，j = 2, j = 3, j = 4, ....j = 7, 这些都是没必要的 * 如此类推 var maxArea = function(height) { let start = 0; let end = height.length - 1; let max = 0; for(let i = 0; i &lt; height.length; i++) { for(let j = i + 1; j &lt; height.length; j++) { let x = j - i; let y = height[i] > height[j] ? height[j] : heigth[i]; max = Math.max(x * y, max) } } return max; }; 分析此题使用双指针，我们看上图，当前值为y, 当y一定时，那么x 尽可能的大，就可以找到最大值了。 定义 头尾指针 如果当前头指针 &lt; 尾指针，那么，头指针到尾指针的距离为 y, 头指针的值为x, 解释一下： 当前值头指针的值固定（y固定），x为最大。所以当前值高度为y的时候，面积最大 如果当前头指针 &gt; 尾指针，那么，头指针到尾指针的距离为 y, 尾指针的值为x, 解释如上 这个时候我们只需要修改头指针和尾指针就可以了。 头指针 &lt; 尾指针时，当前头指针的值y, 头指针到尾指针的距离为x, 当前面积已经最大了，所以头指针向后移 start++ 头指针 &gt; 尾指针时，当前尾指针的值y, 头指针到为指针的距离为x, 当前面积已经醉倒了，所以尾指针向前移 end– 注意：这里需要分析好y轴就可以了 以上面heigth = [1,8,6,2,5,4,8,3,7] 为例子， start = 0; end = heigth.length - 1 当start = 0的时候, 当前y值为 heigth[start]为1，height[end]为7, height[start] &lt; height[end], start到end的距离x 为最大，且y的距离只能为1, 当前y = 1的时候，面积最大为7， 然后start向后移 此时 start = 1, end = heigth.length - 1: height[start] = 8, height[end] = 7, 然而height[start] &gt; height[end], 那y的值只能够取小的那个，即height[end], 当前y=height[end]=7的时候，x = end - start，面积最大为49, end向前移动; 代码var maxArea = function(height) { let start = 0; let end = height.length - 1; let max = 0; while(start != end) { let x = end - start; let y = height[end] > height[start] ? height[start] : height[end]; max = Math.max(x * y, max); if(height[end] > height[start]) { start++; } else { end--; } } return max; };","categories":[],"tags":[{"name":"algorithm-双指针","slug":"algorithm-双指针","permalink":"http://yoursite.com/tags/algorithm-%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"React源码-ReactChildren","slug":"React源码-ReactChildren","date":"2020-06-19T02:57:16.000Z","updated":"2020-07-11T02:42:03.853Z","comments":true,"path":"2020/06/19/React源码-ReactChildren/","link":"","permalink":"http://yoursite.com/2020/06/19/React%E6%BA%90%E7%A0%81-ReactChildren/","excerpt":"","text":"文件目录/packages/react/src/ReactChildren 文档文档地址 ReactChildren 主要用于组合模式，详细可以去看看ant-design的Radio.Group, CheckBox.Group; childrenthis.props.children 其实是一个 ReactElement对象或者是一个数组它的值也是ReactElement, 查看demo可以看到控制台的输出。 React.Children.mapReact.Children.map(this.props.children, (item) =&gt; [item, [item, [item]]])可以看到一个挺有趣的现象，多层嵌套的数组平铺成一维数组，即[item, [item, [item]]] =&gt; [item, item, item], 但可以注意一下各item的key 源码先看看 mapChildren/** * @param {?*} children * @param {function(*, int)} func 遍历的方式 * @param {*} context 上下文 * @return {object} 遍历完后的结果 */ function mapChildren(children, func, context) { if (children == null) { return children; } // 遍历出来的元素会丢到 result 中最后返回出去 const result = []; mapIntoWithKeyPrefixInternal(children, result, null, func, context); return result; } mapIntoWithKeyPrefixInternal/** * @param {?*} children &lt;p>123&lt;p> * @param {Array} array [] * @param {string} prefix \"\" * @param {func} func item => [item, [item, [item]]] * @param {*} context undefined */ function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) { // 这里是处理 key, 看下面 let escapedPrefix = ''; if (prefix != null) { escapedPrefix = escapeUserProvidedKey(prefix) + '/'; } // getPooledTraverseContext 和 releaseTraverseContext 是配套的函数 // 用处其实很简单，就是维护一个大小为 10 的对象重用池 // 每次从这个池子里取一个对象去赋值，用完了就将对象上的属性置空然后丢回池子 const traverseContext = getPooledTraverseContext( array, escapedPrefix, func, context, ); traverseAllChildren(children, mapSingleChildIntoContext, traverseContext); // 将当前 traverseContext 都的属性置空，然后丢回池子 releaseTraverseContext(traverseContext); } escapeUserProvidedKeyeg. &quot;.0/.0&quot;, &quot;.0/.1:0&quot;, &quot;.0/.1:1:0&quot; 将 / 匹配，然后在/加一个/ =&gt; &quot;.0//.0&quot;, replace 的 第二个参数 &#39;$&amp;&#39; 表示匹配的内容 const userProvidedKeyEscapeRegex = /\\/+/g; function escapeUserProvidedKey(text) { return ('' + text).replace(userProvidedKeyEscapeRegex, '$&amp;/'); } getPooledTraverseContext 和 releaseTraverseContextgetPooledTraverseContext 和 releaseTraverseContext 是配套使用的，他们主要是维护一个长度为10对象池，getPooledTraverseContext 就是从对象池中拿一个对象出来然后赋值，releaseTraverseContext 就是将 traverseContext 的属性赋值为空，然后重新放会到池子里面。这样做是因为减少 创建对线和释放对象的性能消耗。 /** * 从池中拿一个对象然后赋值，要是池子没有那直接返回一个对象 * @param {Array} mapResult 遍历后的结果存放 * @param {string} keyPrefix key 值 * @param {func} maoFunction (item) => {} * @param {*} mapContext undefined * @returns {result, keyPrefix, func, context, count = 0} */ function getPooledTraverseContext( mapResult, keyPrefix, mapFunction, mapContext, ) { if (traverseContextPool.length) { const traverseContext = traverseContextPool.pop(); traverseContext.result = mapResult; traverseContext.keyPrefix = keyPrefix; traverseContext.func = mapFunction; traverseContext.context = mapContext; traverseContext.count = 0; return traverseContext; } else { return { result: mapResult, keyPrefix: keyPrefix, func: mapFunction, context: mapContext, count: 0, }; } } // 将对象置空然后放回池子 function releaseTraverseContext(traverseContext) { traverseContext.result = null; traverseContext.keyPrefix = null; traverseContext.func = null; traverseContext.context = null; traverseContext.count = 0; if (traverseContextPool.length &lt; POOL_SIZE) { traverseContextPool.push(traverseContext); } } traverseAllChildren/** * @param {*} children &lt;p>123&lt;/p> 或者是 [&lt;p>123&lt;/p>, &lt;p>456&lt;/p>] * @param callback mapSingleChildIntoContext * @param {result, keyPrefix, func, context, count = 0} traverseContext */ function traverseAllChildren(children, callback, traverseContext) { if (children == null) { return 0; } return traverseAllChildrenImpl(children, '', callback, traverseContext); } traverseAllChildrenImple/** * @param {?*} children &lt;p>123&lt;/p> 或者是 [&lt;p>123&lt;/p>, &lt;p>456&lt;/p>] * @param {!string} nameSoFar 名字路径 * @param {!function} callback mapSingleChildIntoContext * @param {?*} traverseContext {result, keyPrefix, func, context, count = 0} * @return {!number} The number of children in this subtree. */ function traverseAllChildrenImpl( children, nameSoFar, callback, traverseContext, ) { // 这个函数核心作用就是通过把传入的 children 数组通过遍历摊平成单个节点 // 然后去执行 mapSingleChildIntoContext // 开始判断 children 的类型 const type = typeof children; if (type === 'undefined' || type === 'boolean') { // All of the above are perceived as null. children = null; } let invokeCallback = false; if (children === null) { invokeCallback = true; } else { switch (type) { case 'string': case 'number': invokeCallback = true; break; case 'object': switch (children.$$typeof) { case REACT_ELEMENT_TYPE: case REACT_PORTAL_TYPE: invokeCallback = true; } } } // 如果 children 是可以渲染的节点的话， 比如是&lt;Demo>123&lt;/Demo>, 这种情况下，children 是“123”, 就直接调用 callback, // 如果 children 是 [&lt;p>123&lt;/p>, &lt;p>&lt;/p>] 就跳过往下走 // callback 是 mapSingleChildIntoContext if (invokeCallback) { callback( traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar, ); return 1; } // nextName 和 nextNamePrefix 都是在处理 key 的命名 let child; let nextName; let subtreeCount = 0; // Count of children found in the current subtree. const nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR; // 节点是数组的话，就开始遍历数组，并且把数组中的每个元素再递归执行 traverseAllChildrenImpl // 如果children 是数据的话，遍历children数组， 然后在对每个元素进行 // mapSingleChildIntoContext if (Array.isArray(children)) { for (let i = 0; i &lt; children.length; i++) { child = children[i]; nextName = nextNamePrefix + getComponentKey(child, i); subtreeCount += traverseAllChildrenImpl( child, nextName, callback, traverseContext, ); } } else { // 不是数组的话，就看看 children 是否可以支持迭代 // 就是通过 obj[Symbol.iterator] 的方式去取 const iteratorFn = getIteratorFn(children); // 只有取出来对象是个函数类型才是正确的 if (typeof iteratorFn === 'function') { // 然后就是执行迭代器，重复上面 if 中的逻辑了 const iterator = iteratorFn.call(children); let step; let ii = 0; while (!(step = iterator.next()).done) { child = step.value; nextName = nextNamePrefix + getComponentKey(child, ii++); subtreeCount += traverseAllChildrenImpl( child, nextName, callback, traverseContext, ); } } else if (type === 'object') { let addendum = ''; const childrenString = '' + children; } } return subtreeCount; } 该函数用于平铺节点 我们要记住callback 是 mapSingleChildIntoContext 判断children类型 为数字，字符串，还有单个节点的时候直接执行mapSingleChildIntoContext 要是为数组的话遍历数组，再执行traverseAllChildrenImpl 不是数组的话判断一下children 是不是可迭代的，要是是对象的话就抛出对象 mapSingleChildIntoContext/** * 这个函数只有当传入的 child 是单个节点是才会调用 * @param bookKeeping traverseContext * @param child 传入的节点 * @param childKey 节点的 key */ function mapSingleChildIntoContext(bookKeeping, child, childKey) { const {result, keyPrefix, func, context} = bookKeeping; // func => (item) => [item, [item, [item]]] let mappedChild = func.call(context, child, bookKeeping.count++); // 判断函数返回值是否为数组 // mappedChild 的结果是 [item, [item, [item]]] // 我们说 (item) => [item, [item, [item]]] 会平铺成 [item, item, item] if (Array.isArray(mappedChild)) { // 是数组的话就回到最先调用的函数中 // 然后回到之前 traverseAllChildrenImpl 摊平数组的问题 // 假如 c => [item, [item, [item]]]，当执行这个函数时，返回值应该是 [item, [item, [item]]] // 然后 [item, [item, [item]]] 会被当成 children 传入 // traverseAllChildrenImpl 内部逻辑判断是数组又会重新递归执行 mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c); } else if (mappedChild != null) { // 不是数组且返回值不为空，判断返回值是否为有效的 Element // 是的话就把这个元素 clone 一遍并且替换掉 key if (isValidElement(mappedChild)) { mappedChild = cloneAndReplaceKey( mappedChild, // Keep both the (mapped) and old keys if they differ, just as // traverseAllChildren used to do for objects as children keyPrefix + (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey, ); } result.push(mappedChild); } } 看看流程eg. React.Children.map(this.props.children, (item) =&gt; [item, [item, [item]]]) children =&gt; [&lt;p&gt;123&lt;/p&gt;, &lt;p&gt;456&lt;/p&gt;], func =&gt; (item) =&gt; [item, [item, [item]], result = [] 先进行 mapIntoWithKeyPrefixInternal, 传入上面三个值， 我们直接忽略key 然后从池里赋值 func 和result, prefix， 此时 traverseContext result: [], keyPrefix: '', func: (item) => [item, [item, item]], context: undefined count: 0 然后执行 traverseAllChildren 再执行 traverseAllChildrenImpl, 判断 当前children 是不是可以直接渲染 是的话：那直接执行 mapSingleChildIntoContext， 将当前节点放到result 但现在我们的 children 是数组， 所以我们要逐个遍历， 再执行traverseAllChildrenImpl eg.此时我们拿到children[0], 然后执行traverseAllChildrenImpl,然后进入 mapSingleChildIntoContext， // mapSingleChildIntoContext // bookKeeping：{ result: [], keyPrefix: \"\", func: (item) => [item, [item, [item]]] } // child: &lt;p>123&lt;/p> 在mapSingleChildIntoContext内执行了func, 所以得到的结果是mappedChild = [item, [item, [item]]]， 然后判断mappedChild是否是数组，是的话把 mappedChild 当成children 从第一步开始, 但递归后此时func是c =&gt; c, 从 traverseAllChildrenImpl 判断 mappedChild 是数组，然后遍历他，拿出第一个item，再执行了一次 traverseAllChildrenImpl,然后是ReactElement,就执行了mapSingleChildIntoContext, 但注意此时的func 是 c =&gt; c, 判定结果不是数组，将结果push 进result，mapSingleChildIntoContext结束。回到traverseAllChildrenImpl, 然后执行 mappedChild[1], 又在traverseAllChildrenImpl方法判定是数组，再取mappedChild[1][0] 去做 mapSingleChildIntoContext, 然后执行 func c =&gt; c,再push进result，mapSingleChildIntoContext结束, 再一次回到traverseAllChildrenImpl，直到mapChildren遍历完。 以上如此类推 流程图","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"React源码--ReactElement","slug":"React源码-ReactElement","date":"2020-06-18T06:21:43.000Z","updated":"2020-06-20T02:58:14.264Z","comments":true,"path":"2020/06/18/React源码-ReactElement/","link":"","permalink":"http://yoursite.com/2020/06/18/React%E6%BA%90%E7%A0%81-ReactElement/","excerpt":"","text":"文件目录packages/react/src/ReactElement ReactElement指定当前元素是 ReactElement, 但该元素是由 createElement 创建的, 来看一下ReactElement 源码 const ReactElement = function(type, key, ref, self, source, owner, props) { const element = { $$typeof: REACT_ELEMENT_TYPE, // 指Element元素 // 下面几个都是我们 元素的属性， // eg. &lt;div key=\"1\" ref=\"string\" value=\"123\">&lt;/div> type: type, key: key, ref: ref, props: props, // 记录负责创建此元素的组件。 _owner: owner, // 其实是一个FiberNode }; return element; }; createElement文档 根据type 创建一个ReactElement。同时处理ref, key, props, 还有children, 另外对defaultProps 赋值。 我们看一下babel 的转化吧！ &lt;div key=\"1\" ref=\"string\" value=\"123\"> &lt;p>children1&lt;/p> &lt;p>children2&lt;/p> &lt;/div> 会转换成 React.createElement( \"div\", { ref: \"string\", value: \"123\", key: \"1\" }, React.createElement( \"p\", null, \"children1\", ) React.createElement( \"p\", null, \"children12\", ) ) 源码：export function createElement(type, config, children) { // type => div // config => {ref: \"string\",value: \"123\",key: \"1\"} // children => &lt;p>children1&lt;/p>, &lt;p>children2&lt;/p> let propName; const props = {}; let key = null; let ref = null; let self = null; let source = null; // 验证config, 把key 和 ref 从config 单独抽离出来放到props 中 if (config != null) { // 验证 ref 和 key if (hasValidRef(config)) { ref = config.ref; } if (hasValidKey(config)) { key = '' + config.key; } // self 正确获取this, 检测this与 ReactElement.owner是否相等，不相等就发出警告 // source 一个注释对象（由编译器或其他方式添加），指示文件名，行号和/或其他信息。 self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // 遍历配置，把除了key, ref, _self, _source这些以外的数据放到props for (propName in config) { if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) { props[propName] = config[propName]; } } } // 处理children, arguments 后面的参数都是children // 如果children 数大于1个，那么放入到数组中 const childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } props.children = childArray; } // 判断是否有给组件设置 defaultProps，有的话判断是否有给 props 赋值， // 只有当值为 undefined 时，才会设置默认值 if (type &amp;&amp; type.defaultProps) { const defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, ); } cloneElement文档 cloneElement 克隆元素， 大致跟createElement 的处理方式一样 。","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"最佳观光组合","slug":"最佳观光组合","date":"2020-06-17T06:50:13.000Z","updated":"2020-06-20T02:58:14.264Z","comments":true,"path":"2020/06/17/最佳观光组合/","link":"","permalink":"http://yoursite.com/2020/06/17/%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/","excerpt":"","text":"最佳观光组合题目 题目描述给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。返回一对观光景点能取得的最高分。 示例： 输入：[8,1,5,2,6]输出：11解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 暴力破解var maxScoreSightseeingPair = function(A) { let max = 0; const length = A.length; for(let i = 0; i &lt; length; i++) { for(let j = i + 1; j &lt; length; j++) { max = Math.max((A[i] + A[j] + i - j), max); } } return max }; 分析我们可以看方程 A[i] + A[j] + i - j =&gt; A[i] + i + A[j] - j, 我们遍历数组 可以知道 A[j] - j 是可以知道的并且是固定的，所以只要把 A[i] + i 变为最大即可，所以 max + A[j] - j 动态规划 max = A[i] + A[j] + i - j = A[i] + i + A[j] - j var maxScoreSightseeingPair = function(A) { let len = A.length; let dp = []; let max = 0; dp[0] = 0; for(let i = 1; i &lt; len; i++){ dp[i] = Math.max(dp[i - 1], A[i - 1] + i - 1); max = Math.max(max, dp[i] + A[i] - i); } return max; } 优化var maxScoreSightseeingPair = function(A) { let res = 0; let max = 0; const length = A.length; debugger; // A[i] + A[j] + i - j => A[i] + i + A[j] - j // 我们知道A[j] - j 是固定的, 只要维护 A[i] + i 为最大即可，所以就遍历一次 => max + A[j] - j for(let i = 0; i &lt; length; i++) { res = Math.max(max + A[i] - i, res); max = Math.max(max, A[i] + i) } return res; };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"}]},{"title":"React源码--React API","slug":"React源码-React API","date":"2020-06-16T07:00:31.000Z","updated":"2020-06-25T02:57:29.044Z","comments":true,"path":"2020/06/16/React源码-React API/","link":"","permalink":"http://yoursite.com/2020/06/16/React%E6%BA%90%E7%A0%81-React%20API/","excerpt":"","text":"源码版本 16.8.6地址 看看API我们进到packages/src, 看到React.js, 其实这个文件时返回一些基本的API, 比如我们常用的Children, createRef, Component, PureComponent, createContext, forwardRef, lazy, memo 还有 hooks 等等，但我们先不看hooks Children这个Children方法其实是给我们处理props.children的, props.children其实就是一个类数组的东西，Children的用法有遍历React.Children.map 或者 React.Children.forEach，一般情况下我们会配合组合模式cloneElement使用， 有返回children个数 React.Children.count，另外两个不常用toArray和 only 文档 源码解析 createRef我们看看用法 class Demo extends React.Component { constructor() { this.ref = React.createRef() } render() { return ( &lt;div> &lt;Input ref={this.ref} /> // 或者 &lt;Input ref={(inputRef) => this.ref = inputRef } /> &lt;/div> ) } } Component 和 PureComponentComponent 和 PureComponent 就是后者多了一个state 和 props 的浅比较， 也就是相当于在 Component 执行了 shouldComponentUpdate, 简单类型下，可以用PureCompnent 做组件的性能优化 createContext在 react 16后，context 做了改变 const ThemeContext = React.createContext('light'); class App extends React.Component { render() { // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。 // 无论多深，任何组件都能读取这个值。 // 在这个例子中，我们将 “dark” 作为当前的值传递下去。 return ( &lt;ThemeContext.Provider value=\"dark\"> &lt;Toolbar /> &lt;/ThemeContext.Provider> ); } }; // 中间的组件再也不必指明往下传递 theme 了。 function Toolbar() { return ( &lt;div> &lt;ThemedButton /> &lt;/div> ); } class ThemedButton extends React.Component { render() { return ( &lt;ThemeContext.Consumer> { (theme) => ( &lt;Button theme={theme} /> ) } &lt;/ThemeContext.Consumer> ); } } forwardRef其实就是ref 的转发, 一般情况下我们不能用ref 当做props 传递给组件的，但可以通过forwardRef 做强制转发，用的最多的是解决HOC组件传递ref的问题的 const FancyButton = React.forwardRef((props, ref) => ( &lt;button ref={ref} className=\"FancyButton\"> {props.children} &lt;/button> )); // 你可以直接获取 DOM button 的 ref： const ref = React.createRef(); &lt;FancyButton ref={ref}>Click me!&lt;/FancyButton>; lazy简单说就是懒加载 memo简单说就是 PureComponent","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"面试题46. 把数字翻译成字符串","slug":"面试题46-把数字翻译成字符串","date":"2020-06-09T07:58:39.000Z","updated":"2020-06-13T05:15:47.191Z","comments":true,"path":"2020/06/09/面试题46-把数字翻译成字符串/","link":"","permalink":"http://yoursite.com/2020/06/09/%E9%9D%A2%E8%AF%95%E9%A2%9846-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"面试题46. 把数字翻译成字符串 题目描述给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例： 输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi” 分析 一开始想的也是 滑动窗口, 但后来想了一下不太正确，应该用动态规划 过程以 nums = &quot;12258&quot; 为例子 i = 0, nums[0] =&gt; 1, 结果为b,那么结果只有一种， 解释： 只取第一个数1的时候，结果肯定只有一种， 1 转成 b i = 1, nums[1] =&gt; 2, 结果为bc, m, 那么结果有两种，解释： 当数字为12的时候，它可以为 1 =&gt; b, 2 =&gt; c, 为一种：bc 12 =&gt; m, 为一种：m i = 2, nums[2] =&gt; 2, 结果为bcc, mc, bw, 结果有三种，解释：当数字为122的时候,它可以为 1 =&gt; b, 2 =&gt; c, 2 =&gt; c 为一种, bcc 12 =&gt; m, 2 =&gt; c 为一种, mc 1 =&gt; b, 22 =&gt; w 为一种, bw i = 3, nums[3] =&gt; 5, 结果为bccf, mcf, bwf, mz, bcz, 解释： 当数字为1225的时候，他可以为 1 =&gt; b, 2 =&gt; c, 2 =&gt; c, 5 =&gt; f 为一种, bccf 12 =&gt; m, 2 =&gt; c, 5 =&gt; f 为一种, mcf 1 =&gt; b, 22 =&gt; w, 5 =&gt; f 为一种, bwf 1 =&gt; b, 2 =&gt; c, 25 =&gt; z 为一中, bcz 12 =&gt; m, 25 =&gt; z, 为一种：mz i = 4, nums[4] =&gt; 8, 结果为bccfi, mcfi, bwfi, mzi, bczi, 解释： 当数字为12258的时候，他可以为 1 =&gt; b, 2 =&gt; c, 2 =&gt; c, 5 =&gt; f, 8 =&gt; i 为一种, bccfi 12 =&gt; m, 2 =&gt; c, 5 =&gt; f, 8 =&gt; i 为一种, mcfi 1 =&gt; b, 22 =&gt; w, 5 =&gt; f, 8 =&gt; i 为一种, bwfi 1 =&gt; b, 2 =&gt; c, 25 =&gt; z, 8 =&gt; i 为一中, bczi 12 =&gt; m, 25 =&gt; z, 8 =&gt; i, 为一种：mzi 上面我们看 i = 1, i = 2, i = 3 的时候，的结果，我们用dp表示他们的结果 * i = 3的结果bccf, mcf, bwf, mz, bcz, * i = 2的结果bcc, mc, bw, * i = 1的结果m, bc 发现没，其实dp[3] 就是从 dp{2] 和dp[1]的结果过来的, dp[2]的字符串结果都加个f就等于dp[3]的前3个, dp[1]的字符串结果加个z就是dp[3]后三个所以递推公式 dp[i] = dp[i - 1] + dp[i - 2], 但此时递推公式明显不符合i = 4的时候的值, dp[i] 明显等于 dp[i-1], 但前提是nums[i - 1] + nums[i] = 58 &gt; 25 代码var translateNum = function(num) { let numString = num + \"\"; let length = numString.length; if(length &lt; 1) { return 0 } let dp = []; // 递推公式 dp[i] = d[i - 1] + dp[i - 2], 和 dp[i] = dp[i - 1] dp[0] = 1; for(let i = 1; i &lt; length; i++) { const temp = numString[i - 1] + numString[i]; // 当temp = 06 的时候 其实也跟dp[i - 1]一样 if(temp > 25 || numString[i - 1] == '0') { dp[i] = dp[i - 1] } else { dp[i] = dp[i - 1] + (i - 2 &lt; 0 ? 1 : dp[i - 2]) ; // i - 2 &lt; 0 这里是为了解决 dp[i-2]防止溢出问题, 12 结果为2, } } return dp[length - 1] };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"algorithm-面试题","slug":"algorithm-面试题","permalink":"http://yoursite.com/tags/algorithm-%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题29. 顺时针打印矩阵","slug":"面试题29-顺时针打印矩阵","date":"2020-06-09T07:08:16.000Z","updated":"2020-06-13T05:19:09.431Z","comments":true,"path":"2020/06/09/面试题29-顺时针打印矩阵/","link":"","permalink":"http://yoursite.com/2020/06/09/%E9%9D%A2%E8%AF%95%E9%A2%9829-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","excerpt":"","text":"面试题29.顺时针打印矩阵 题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 分析示例1： i/j j = 0 j = 1 j = 2 i = 0 1 2 3 i = 1 4 5 6 i = 2 7 8 9 i = 2 10 11 13 示例2： i/j j = 0 j = 1 j = 2 j = 3 i = 0 1 2 3 4 i = 1 5 6 7 8 i = 2 9 10 11 12 i = 2 13 14 15 16 可以看一下结果，题目说是顺时针打印，可以想象一下 i 跟 j 的变化 循环遍历 结束条件是： 当结果数组的长度 == matrix数组的高 * 宽， 即所有子集都遍历过了 再来分析一下边界问题, 分析一下 i, j 的变化， 这里以 示例2 为例子 开始： 向右走， 那么 j++，i不变， 到 j == 3的时候向下， 所以这里要考虑右边的边界问题 向下走： 那么 i++, j 不变，到 i == 3的时候向左， 所以考虑下边界问题 向左走： 那么 j--, i 不变，到 j == 0的时候向上，所以考虑左边界问题 向上走： 那么 i--, j 不变，到 i == 1的时候再一次重复， 1,2,3,4这四步， 但这里要考虑上边界的问题 我这里用 direction 表示方向， 1 =&gt; 向右， 2 =&gt; 向下， 3 =&gt; 向左， 4 =》 向上 这时候就是想什么时候得到边界，在边界的时候改变方向，所以有 先设置边界 left = 0, right = colums - 1, up = 0, down = rows - 1, 这里表示左右上下的边界，我们只要操作这个边界就可以了另外rows表示有多少行，colums表示有多少列 i == up &amp;&amp; j == left, 我们可以看 i == 0, j == 0的时候，这时候就是向右走 i == up &amp;&amp; j == right, 这时候就是 i == 0， j == 3的时候，那么我们就改变方向，向下走 i == down &amp;&amp; j == right, 这时候就是 i == 3, j == 3，那么又改变方向，向左走 i == down &amp;&amp; j == left, 这时候就是 i == 3, j == 0, 又改变方向，向上走 注意： 此时向上走之后，等 i == up + 1 &amp;&amp; j == left, 即 i == 1, j ==0, 即5这个地方，那么就向右走，同时，更改边界, left++, right--, up++, down-- 再重复上面的事情 整个过程是： 1 =&gt; 2 =&gt; 3 =&gt; 4 =&gt; 8 =&gt; 12 =&gt; 16 =&gt; 15 =&gt; 14 =&gt; 13 =&gt; 9 =&gt; 5 这是一圈 6 =&gt; 7 =&gt; 11 =&gt; 10 这又是一圈 当输入的matrix = [[1],[2],[3]]就只有一列的时候， 另外看示例1, 走完外圈，剩下内圈，只剩下5,8这两个元素的时候也向下走，所以总结 left == right的时候，direction = 2, i++ 代码var spiralOrder = function(matrix) { let rows = matrix.length; let result = []; if(rows == 0) { return result } let columns = matrix[0].length; let count = 0; let i = 0; let j = 0; let direction = 1; // 1 => 向右 2 => 向下 3=> 向左 4 => 向上 let left = 0; // 左边界 let right = columns - 1; // 右边界 let up = 0; let down = rows - 1; while(count &lt; rows * columns) { const current = matrix[i][j]; result.push(current); count++; if(left == right) { // 当剩下的元素只有一列的时候，只能向下走了 direction = 2; i++; continue; } if(i == up &amp;&amp; j == left) { // 拐点向右 direction = 1 } else if(i == up &amp;&amp; j == right) { // 拐点向下 direction = 2 } else if(i == down &amp;&amp; j == right) { // 拐点向左 direction = 3; } else if(i == down &amp;&amp; j == left) { // 拐点向上 direction = 4 } if(i == up + 1 &amp;&amp; j == left) { // 完成一圈后，重设定边界 left = left + 1; right = right - 1; up = up + 1; down = down - 1; direction = 1; } // 根据方向，改变i, j的值 if(direction == 1) { j++; } else if(direction == 2) { i++; } else if(direction == 3) { j--; } else { i--; } } return result };","categories":[],"tags":[{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"},{"name":"algorithm-数组","slug":"algorithm-数组","permalink":"http://yoursite.com/tags/algorithm-%E6%95%B0%E7%BB%84/"},{"name":"algorithm-面试题","slug":"algorithm-面试题","permalink":"http://yoursite.com/tags/algorithm-%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"高德地图滑动验证","slug":"高德地图滑动验证","date":"2020-06-05T09:34:27.000Z","updated":"2020-06-13T05:15:47.192Z","comments":true,"path":"2020/06/05/高德地图滑动验证/","link":"","permalink":"http://yoursite.com/2020/06/05/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/","excerpt":"","text":"高德地图滑动验证 用dispatch 模拟dom的mousedown, mousemove，还有mouseUp 事件 再用 setInterval 执行mouseMove事件即可 但这里有时候会滑动失败，所以要刷新验证码，然后重新滑动， 有时候又是滑动验证码验证成功后。 再一次弹出验证码 注意：滑动验证码请注意滑动的速度和滑动的距离，要是太慢、滑动距离太短的话，滑动验证多数会不通过。 检查验证码// 检查验证码 function checkYzm() { const dom = document.querySelector(\".sufei-dialog\"); if(dom &amp;&amp; dom.style.display == \"block\") { return true; } return false } 滑动验证码async function sliderYzm() { await sleep(1500); const iframe = document.getElementById(\"sufei-dialog-content\"); const btn = iframe.contentWindow.document.getElementById(\"nc_1_n1z\"); const mousedown = document.createEvent(\"MouseEvents\"); const rect = btn.getBoundingClientRect(); var x = rect.x; var y = rect.y; mousedown.initMouseEvent(\"mousedown\", true, true, window, 0, x, y, x, y, false, false, false, false, 0, null); btn.dispatchEvent(mousedown); let dx = 0; let dy = 0; const mousemove = document.createEvent(\"MouseEvents\"); return new Promise((resolve) => { const interval = setInterval(async () => { const _x = x + dx; const _y = y + dy; mousemove.initMouseEvent(\"mousemove\", true, true, window,0 ,_x, _y, _x, _y, false, false, false, false, 0, null); btn.dispatchEvent(mousemove); if(_x - x >= 300){ clearInterval(interval); const mouseup = document.createEvent(\"MouseEvents\"); mouseup.initMouseEvent(\"mouseup\", true, true, window, 0, _x, _y, _x, _y, false, false, false, false, 0, null); btn.dispatchEvent(mouseup); await sleep(2500); if(btn.className.indexOf('btn_ok') > -1){ console.log(btn.className); sleep(1000) resolve({status: 1}); } if(iframe.contentWindow.document.querySelector(\"#nocaptcha > .errloading\")) { console.log(\"error\") sleep(1000) resolve({status: 0}) } } else{ dx += Math.ceil(Math.random() * 300); } }, 30); }) } 上面只是滑动验证 循环检查时候是否有验证码/** * 循环检查是否有验证码 * 1. 要是有验证码窗口，那么滑动验证， 但滑动验证有失败或者成功，失败返回0， 成功返回1 * 2. 滑动成功后，防止验证码再一次出现，我们延迟1500毫秒，再查看一下验证码窗口是否存在，存在就再一次执行loopSlideYzm(), 不存在就直接结束函数了 * 3. 滑动失败后，会有刷新标志，那这时候应该点击刷新后，再一次执行loopSlideYzm(); */ async function loopSlideYzm() { await sleep(1200); const hasYzm = checkYzm(); await sleep(1000); if(hasYzm) { const { status } = await sliderYzm(); await sleep(1500); if(status) { console.log(\"再找一次是否有验证码\") const hasYzmAgain = checkYzm(); await sleep(1500); if(hasYzmAgain) { return await loopSlideYzm(); } else { return Promise.resolve() } } else { console.log(\"给我刷新验证码\"); freshYzm(); await sleep(1500); return await loopSlideYzm(); } } return Promise.resolve() } 刷新验证码function freshYzm() { const iframe = document.getElementById(\"sufei-dialog-content\"); iframe.contentWindow.document.querySelector(\"#nocaptcha > .errloading > .nc-lang-cnt > a\").click() } 以上就是自动跳过高德地图的滑动验证码全过程","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"记录一下react的一些用法","slug":"记录一下react的一些用法","date":"2020-06-03T08:18:46.000Z","updated":"2020-06-05T13:30:57.671Z","comments":true,"path":"2020/06/03/记录一下react的一些用法/","link":"","permalink":"http://yoursite.com/2020/06/03/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Breact%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/","excerpt":"","text":"高阶组件HOC HOC 其实就是一个函数， 接收参数是一个组件，但返回值是一个组件 看一个简单的高阶组件 function visibleHOC(WrappedComponent) { return class extends Component { render() { const { visible } = this.props; if(!visible) return null; return &lt;WrappedComponent {...this.props}> } } } Render Propsconst CustomModal = ({visible, cancel}) => { return ( &lt;Modal visible={visible} onCancel={cancel} > Hello World &lt;/Modal> ) } class ModalContainer extends Component { state = { visible: false } handleCancel = () => { this.setState({ visible: false }) } show = () => { this.setState({ visible: true }) } render() { const { visible } = this.state; const { children } = this.props; return ( children({ visible: visible, show: this.show, cancel: this.handleCancel }) ) } } class App extends Component { render() { return ( &lt;div> &lt;ModalContainer> ({visible, show, cancel}) => ( &lt;> &lt;CustomModal visible={visible} cancel={cancel}>&lt;/CustomModal> &lt;Button type=\"primary\" onClick={show}> Click &lt;/Button> &lt;/> ) &lt;/ModalContainer> &lt;/div> ) } } demo","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"原型与继承","slug":"原型与继承","date":"2020-06-01T09:10:32.000Z","updated":"2020-06-05T13:30:57.670Z","comments":true,"path":"2020/06/01/原型与继承/","link":"","permalink":"http://yoursite.com/2020/06/01/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/","excerpt":"","text":"prototype我们知道每个函数都有一个prototype指向他的原型对象。我们可以这么理解： 每个对象在创建时就与另一个对象产生关联，其实就是对另一个对象的引用。而js 再找对象属性时会顺着原型链一直往上找，直到无法找到为止 来看一下 function Person(name) { this.name = name } // 控制台打印一下， => 是结果 Person.prototype => { constructor: f } // 而 Person.prototype.constructor 又指向与构造函数自己 Person.prototype.constructor == Person // true 用下图表示： proto每个对象都有一个__proto__属性，除了null外，而这个属性又指向他的原型对象 验证一下 function Person(name) { this.name = name } var person = new Person(\"Bill\"); // 控制台打印一下， person.__proto__ person.__proto__ => { constructor: f } // 我们从上面[prototype]看 Person.prototype 也是指向 { constructor: f }, 那么他们是否是同一个东西呢? person.__proto__ == Person.prototype // 结果是 true 的 // 上面一样的话，那么 person.__proto__.contructor == Person // true 用图表示一下就是 new 操作符 这里解释一下new 操作符，其实跟原型有关 首先搞清楚new 做了什么 创建对象 将对象的原型指向函数的原型 改变 this 上下文 返回这个对象 function newObj(fn, ...args) { var obj = {}; obj.__proto__ = fn.prototype; let res = fn.call(obj, ...args); let isObject = typeof res === 'object' &amp;&amp; typeof res !== null; let isFunction = typeof res === 'function'; return isObject || isFunction ? res : obj; // 这里其实可以直接返回obj // 但防止 fn 这个方法直接返回this, 以下这种情况 // function fn(name) { // this.name = name; // return this; // } } function Person(name) { this.name = name; } // 测试一下 person = newObj(Person, \"Bill\") // 打印一下 person // Person {name: Bill} Fn.prototype.proto 我们说Fn.prototype 是一个原型对象，我们上面说只要是对象都有__proto__, 那么Fn.prototype.__proto指向的是什么呢？ 答案是： Object.prototype Object.prototype == Person.prototype.__proto__ // true 所以有了下图 到此原型基本已经讲完了 继承下面写继承 原型链继承function Parent(){ this.role = \"parent\" this.list = [1,2,3] } Parent.prototype.getRole = function() { return this.role } function Child(name) { this.name = name } Child.prototype = new Parent(); Child.prototype.getName = function() { return this.name; } var children = new Child(\"admin\"); children.getName() children.getRole() var parent = new Parent(); console.log(parent.role) // parent Child.prototype.value = \"123\" console.log(parent.value); // \"undefined\" console.log(children.value) // “123” // 以下是原型链的缺点 var children2 = new Child(\"child2\"); console.log(children.list, children2.list) // [1,2,3], [1,2,3,4] children.list.push(4); console.log(children.list, children2.list) // [1,2,3,4], [1,2,3,4] 看下图 当执行了 Child.prototype = new Parent(), 我们说找属性的话,会顺着原型链去找, 比如children要找getRole,那么他会一直找，Child.prototype.__proto__下有getRole, 这就是继承 当执行了 Child.prototype.value = &quot;123&quot;, children实例也拥有了value 。 缺点: 只要在某个子类下改变了父类的引用类型的值，那么子类都会改变，这样做就不能做到相互独立了 无法实现父类构造函数属性的赋值 使用call，改变this 作用域function Parent() { this.role = \"parent\" } function Child(role, name) { Parent.call(this, role) this.name = name; } var children = new Child(\"children\", \"哈哈哈\"); // 注意 Parent.prototype.getRole = function() { return this.role; } // 上面原型方法，子类是无法继承的，即children没有getRole 方法 优点： 解决了原型继承无法向父类赋值的问题 可以继承多个构造函数属性（call多个）； 缺点： 只能继承父类构造函数的属性。原型链新创建的无法被继承 无法实现构造函数的复用。（每次用每次都要重新调用） 每个新实例都有父类构造函数的副本，臃肿。 组合模式将call方式和原型链方式组合起来 function Parent(role) { this.role = role } Parent.prototype.value = \"test\"; function Child(role, name) { Parent.call(this, role); this.name = name; } Child.prototype = new Parent(); var children = new Child(\"child\", \"admin\") 优点： 可以继承父类原型上的属性，可以传参，可复用； 每个新实例引入的构造函数属性是私有的； 缺点： 调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数； 寄生式继承function Parent(role) { this.role = role; this.list = [1,2,3]; } Parent.prototype.value = \"123\" // 原型式继承 function _extend(obj) { function F(){}; F.prototype = obj; // F.prototype = new Parent() -> 还是回到原型链继承 return new F(); // 这里像不像 原型链继承上面的 new Child(); } var parent = new Parent(); // 获取父类实例 // 以上是原型式继承，以下给原型继承在套个壳子传递参数 function wrap(obj, name, role){ var child = _extend(obj); child.role = role; child.name = name; return child; } var child = wrap(parent, 'test', \"child\"); console.log(child.role) // \"test\" console.log(child.value) // \"123\" var child1 = wrap(parent, \"Bill\", \"child1\"); console.log(child1.list) // [1,2,3] child1.list.push(456); console.log(child1.list) // [1,2,3,456] console.log(child.list) // [1,2,3,456] 看上面 又回到了原型链继承的缺点之一了，对于父类引用类型的，一旦做了修改，子类的都会发生改变 寄生组合式继承function Parent(role) { this.role = role; this.list = [1,2,3]; } Parent.prototype.value = \"123\" function Child(name, role) { Parent.call(this, role) // 等于有了父类构造函数的副本 this.name = name; } function _extend(obj) { function F(){}; F.prototype = obj; // F.prototype = new Parent() -> 还是回到原型链继承 return new F(); // 这里像不像 原型链继承上面的 new Child(); } var extendFn = _extend(Parent.prototype); Child.prototype = extendFn; extendFn.constructor = Child; var children = new Child(\"test\", \"child\"); 我们看下图 上面与下面其实大致一样, function F(){}; F.prototype = Parent.prototype; function Child() { Parent.call(this); } Child.prototype = new F(); // 是不是有点像组合模式 // 寄生组合模式理想版 function inheritPrototype(subType, superType){ var prototype = Object.create(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象 } function SuperType(name){ this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function(){ alert(this.name); }; function SubType(name, age){ SuperType.call(this, name); this.age = age; } inheritPrototype(SubType, SuperType);//实现继承 SubType.prototype.sayAge = function(){ alert(this.age); }","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"打家劫舍","slug":"打家劫舍","date":"2020-05-29T15:45:17.000Z","updated":"2020-05-29T16:09:13.544Z","comments":true,"path":"2020/05/29/打家劫舍/","link":"","permalink":"http://yoursite.com/2020/05/29/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","excerpt":"","text":"198. 打家劫舍 题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 尝试 一开始以为是 i奇数的值相加，与偶数的值相加，最后比最大值，提交发现是错误的 然后一想就知道是一位数组的动态规划 题解 定义数组含义： dp[i] 设定第i房间时，所偷的钱为最大 找出数组元素间的关系式 =&gt; 递推公式。 题目规定：小偷不能连续偷窃相邻的房子，至少隔一个房间，那么当我偷到第i房间的时候，我只要求出第i-2房间时跟第i-3房间时的最大值即可，i-2表示隔了一间房间， i-3表示隔了2个房间所以递推公式为 dp[i] = nums[i] + Math.max(dp[i - 3], dp[i - 2]) 找出初始条件： 第0间自然是nums[0], 但我们递推公式 i-3和i-2 理论上没有非正整数的房间，我们手动输入为0吧 var rob = function(nums) { // dp[i] = nums[i] + Max(dp[i-3], dp[i-2]) let dp = new Map(); dp[0] = nums[0]; dp[-1] = 0; dp[-2] = 0; // dp(1) = nums[1] + max(dp(1-3), dp[1-2]) for(let i = 1; i &lt; nums.length; i++) { dp[i] = nums[i] + Math.max(dp[i-3], dp[i-2]); } let result = 0; for(let i = 0; i &lt; nums.length; i++) { result = Math.max(result, dp[i]); } return result };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"字符串解码","slug":"字符串解码","date":"2020-05-29T02:25:49.000Z","updated":"2020-05-29T15:40:08.092Z","comments":true,"path":"2020/05/29/字符串解码/","link":"","permalink":"http://yoursite.com/2020/05/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/","excerpt":"","text":"394. 字符串解码 题目描述编码规则为：k[encoded_string], 即中括号前表示重复的次数，中括号里面的是重复的字符串 例子： s = \"3[a]2[bc]\", 返回 \"aaabcbc\". s = \"3[a2[c]]\", 返回 \"accaccacc\". s = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\". 尝试 用栈的方式去解决问题 用递归的方式 递归解决 以3[a2[c]]为例子, 变量为s 遍历字符串s, 如果是数字, /\\d/.test(s[i]), i++, 如果直接是字母,那直接往后扫, i++ 遇到[进入递归 遇到]结束递归，同时返回[encode_string]中括号里面的内容, 同时返回当前index，即当前]在s[]中第几位 将第6步返回的值和第3步的重复次数，做个for循环就好了 代码实现var decodeString = function(s) { let res = \"\"; const sub = generate(s, 0); res += sub.sub; return res } // 3[a2[c]] function generate(string, start) { let index = start; let temp = \"\"; let tempNum = \"\"; while(index &lt; string.length) { const current = string[index]; if(current == \"[\") { const sub = generate(string, index + 1 ); let res = \"\"; index = (sub.index) for(let i = 0 ; i &lt; tempNum ; i++) { res += sub.sub } temp += res; tempNum = \"\"; } else if(current == \"]\") { let res = temp; return {index: index + 1, sub: res} } else if(/\\d/.test(current)) { tempNum += current index++; } else { temp += current index++ } } return {index: index, sub: temp} }","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"}]},{"title":"和为k的子数组","slug":"和为k的子数组","date":"2020-05-27T15:16:32.000Z","updated":"2020-05-29T15:40:08.091Z","comments":true,"path":"2020/05/27/和为k的子数组/","link":"","permalink":"http://yoursite.com/2020/05/27/%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"","text":"力扣上第560题 题目描述给定一个数组 nums 跟一个 和为k 的值，找到该数组中和为 k 的连续的子数组的个数。 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 尝试 暴力破解, 即每个数跟与他以后的数相加 等于k，那么 res + 1 function subarraySum(nums, k) { let res = 0; for(let i = 0; i &lt; nums.length; i++) { let current = nums[i]; if(current == k) { res += 1; } for(let j = i + 1; j &lt; nums.length; j++) { current += nums[j]; if(current == k) { res += 1; } } } return res; } 滑动窗口，滑动窗口不太好处理，窗口向右扩展的时候，那其实是跟上面算法好像差不多，然后放弃了 看了题解，发现了一个前缀和算法 前缀和算法 将数组中的每一项在遍历时都加起来，然后加入到新的数组中，我们用s[i]表示 定义s[0] = 0 s[1] = a[0] s[2] = s[1] + a[1] 所以得到 s[i + 1] = s[i] + nums[i] 所以移动等式 nums[i] = s[i + 1] - s[i] 所以有以下代码 function subarraySum(nums, k) { let res = 0; let s = [0]; // 多了这一层，结果更慢了 for(let i = 0; i &lt; nums.length; i++) { s[i + 1] = s[i] + nums[i]; } for(let i = 0; i &lt; nums.length; i++) { for(let j = i; j &lt;= nums.length; j++) { if(s[j + 1] - s[i] == k) { res++; } } } return res } 可以看到以上代码其实跟第一种方法是大同小异的，只是使用了前缀和的思想，但这个方法比上面那个还要慢，因为多 前缀和添加这一组循环 优化 看到题解是用前缀和还有哈希表做优化的 思想： 将当前前缀和的值当做哈希表的key。 将当前前缀和出现的次数 当做哈希表的value 具体操作如下: 当遍历 nums时，计算当前前缀和, 存入map 如果 map 中已存在 key 为 当前前缀和 - k, 因为一直遵守 【当前前缀和】-【之前求出的前缀和】 === k, 那么取出哈希表的值，res += value, 如果 map 中， 没有当前前缀和的值 那么把前缀和添加到哈希表中，值为1， 如果有，那么改变哈希表的值: map[prefix]++ function subarraySum(nums, k) { let res = 0; let map = { 0:1 }; let prefixSum = 0; for(let i = 0; i &lt; nums.length; i++) { prefixSum += nums[i]; if(map[prefixSum - k]) { res += map[prefixSum - k] } if(map[prefixSum]) { map[prefixSum]++ } else { map[prefixSum] = 1 } } return res }","categories":[],"tags":[{"name":"algorithm-前缀和","slug":"algorithm-前缀和","permalink":"http://yoursite.com/tags/algorithm-%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"验证回文字符串 Ⅱ","slug":"验证回文字符串 Ⅱ","date":"2020-05-19T09:13:34.000Z","updated":"2020-05-29T15:40:08.093Z","comments":true,"path":"2020/05/19/验证回文字符串 Ⅱ/","link":"","permalink":"http://yoursite.com/2020/05/19/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E2%85%A1/","excerpt":"","text":"验证回文字符串 Ⅱ力扣上第680题 核心思想使用双指针，即使用前后两个指针，同时对前指针和后指针的值做对比，要是相同，那么前指针向后移动，后指针向前移动但这道题说可以删除一个字符, 那么当我们遇到不相等的值的时候，只要前指针向后移动，或者后指针向前移动，然后剩下的做对比即可 终止条件为： 前指针 比 后指针要大，或者说是前指针后于后指针 解释 上图，我们只要判断左指针和右指针的值是否相等，直到终止条件，要是全部都相同，那么就是回文了 但这题说可以删除一个字母，那么等字符不相等的时候，左指针向后移动或者右指针向前移动，将剩下的再做一次回文即可，看下图 代码// \"ebcbb ececabbacec bbcbe\" // \"ebcbb cecabbacece bbcbe\" var validPalindrome = function(s) { let left = 0; let right = s.length - 1; let flag = false; // 标志位 表示要是遇到一个前指针与后指针不相同的值, 退出循环。 while(left &lt; right) { const leftTemp = s[left]; const rightTemp = s[right]; if(leftTemp == rightTemp) { left++; right--; } else { flag = true; break; } } if(flag >= 1) { const tempString = s.slice(left + 1, right + 1); return validChilren(left+1, right, s) || validChilren(left, right - 1, s); } return true; }; function validChilren(left, right, s) { while(left &lt; right) { const leftTemp = s[left]; const rightTemp = s[right]; if(leftTemp == rightTemp) { left++; right--; } else { return false; } } return true; }","categories":[],"tags":[{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"}]},{"title":"大众点评文字数字解密","slug":"大众点评文字数字解密","date":"2020-05-08T02:54:10.000Z","updated":"2020-05-29T15:40:08.092Z","comments":true,"path":"2020/05/08/大众点评文字数字解密/","link":"","permalink":"http://yoursite.com/2020/05/08/%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84%E6%96%87%E5%AD%97%E6%95%B0%E5%AD%97%E8%A7%A3%E5%AF%86/","excerpt":"","text":"原理百度发现大众点评网上面的文字数字加密是通过字体文件加密的，也就是说用css 的class 用不同的类对应的字体文件，再加下面的特殊字符跟字体文件上面的编码一一对应起来 先看一下大众点评吧 我们从上图可以看到，大众点评的地址是加密的，所以我们不能直接从html中获取 发现发现上图 .num 类和 .address 类用的 ba****.css, 打开此css发现这些类使用的字体文件都是不同的，看下图： 我们可以下载FontCreator 打开上图链接的.woff, 或者用百度的FontEditor(之前可以用，后来不行了) 我们用北做例子，在大众点评上加密的字符是 , 我们发现.woff 文件用forntCreator 上面的16进制码是 efa8, js 解析字体文件工具 fonteditor-core它会把.woff 文件中某个 字体转成十进制然后一一对应起来 var Font = require('fonteditor-core').Font; var fs = require('fs'); var buffer = fs.readFileSync('4.woff'); // 不加这个文件会报错 // https://cdn.bootcdn.net/ajax/libs/pako/1.0.10/pako_inflate.min.js let inflate_daddy = require(\"./pako_inflate.min\"); var font = Font.create(buffer, { type: 'woff', // support ttf,woff,eot,otf,svg inflate: inflate_daddy.inflate }); console.log(font.data.cmap); // font.data.cmap // key值代表十进制, value代表的是第几个字体 { '120': 1, '57346': 81, '57348': 275, ... '61352': 125 } 上面北字为例，加密字符 ,转成十进制就是 61352 也就是在.woff 文件第125个字,但机器是不知道上面第125个字是什么字，所以我们做一个.woff文件的所有字体人工抽取出来然后一一对应就好了 woffString = ` 1234567890店中美家馆 小车大市公酒行国品发电金心业商司 超生装园场食有新限天面工服海华水 房饰城乐汽香部利子老艺花专东肉菜 学福饭人百餐茶务通味所山区门药银 农龙停尚安广鑫一容动南具源兴鲜记 时机烤文康信果阳理锅宝达地儿衣特 产西批坊州牛佳化五米修爱北养卖建 材三会鸡室红站德王光名丽油院堂烧 江社合星货型村自科快便日民营和活 童明器烟育宾精屋经居庄石顺林尔县 手厅销用好客火雅盛体旅之鞋辣作粉 包楼校鱼平彩上吧保永万物教吃设医 正造丰健点汤网庆技斯洗料配汇木缘 加麻联卫川泰色世方寓风幼羊烫来高 厂兰阿贝皮全女拉成云维贸道术运都 口博河瑞宏京际路祥青镇厨培力惠连 马鸿钢训影甲助窗布富牌头四多妆吉 苑沙恒隆春干饼氏里二管诚制售嘉长 轩杂副清计黄讯太鸭号街交与叉附近 层旁对巷栋环省桥湖段乡厦府铺内侧 元购前幢滨处向座下臬凤港开关景泉 塘放昌线湾政步宁解白田町溪十八古 双胜本单同九迎第台玉锦底后七斜期 武岭松角纪朝峰六振珠局岗洲横边济 井办汉代临弄团外塔杨铁浦字年岛陵 原梅进荣友虹央桂沿事津凯莲丁秀柳 集紫旗张谷的是不了很还个也这我就 在以可到错没去过感次要比觉看得说 常真们但最喜哈么别位能较境非为欢 然他挺着价那意种想出员两推做排实 分间甜度起满给热完格荐喝等其再几 只现朋候样直而买于般豆量选奶打每 评少算又因情找些份置适什蛋师气你 姐棒试总定啊足级整带虾如态且尝主 话强当更板知己无酸让入啦式笑赞片 酱差像提队走嫩才刚午接重串回晚微 周值费性桌拍跟块调糕 ` 以上获取北字 就是 woffString[font.data.cmap[&#39;61352&#39;]] =&gt; woffString[125] 字符串转进制function stringToEntity(str, radix = 10) { let arr = str.split('') let tmp = arr.map(item => item.charCodeAt(0).toString(radix) ).join(''); // console.log(`'${str}' 转实体为 '${tmp}'`) return tmp } 以上就是解密全过程","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"webpack+vue+electron开发环境搭建","slug":"webpack-vue-electron开发环境搭建","date":"2020-04-23T02:05:49.000Z","updated":"2020-07-11T02:42:03.855Z","comments":true,"path":"2020/04/23/webpack-vue-electron开发环境搭建/","link":"","permalink":"http://yoursite.com/2020/04/23/webpack-vue-electron%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"设置electron 安装路径npm set config ELECTRON_MIRROR=&quot;https://npm.taobao.org/mirrors/electron/&quot; 核心思想electron 分主进程和渲染进程，在这里，我们直接把主进程看成是创建主体窗口，而渲染进程看成是 页面的渲染。 渲染进程当成一般的webpack配置即可， vue-loader, less-loader, style-loader等等照常配置即可, 主进程： 主进程我们只当他是创建主体窗口的，那么我们只需要配置 babel-loader, 当主进程发生改变时，那么就重启窗口， 简单来说就是直接使用 electron .这个命令， 但是我们使用nodejs 的方式启动 当渲染进程文件发生改变时，我们的electron 也跟着刷新，那么就要使用devServer + webpack-hot-middleware, 但我觉得直接使用devServer 也没问题 在主进程中要监听localhost的变化 win.loadURL(&quot;http://localhost:9000&quot;),才能达到 实时更新 配置渲染进程 我们根据 vue-cli 目录文件去配，vue-cli 渲染进程的目录路径：src/render/ 目录下 ├─assets // 资源文件 ├─components // vue 组件 ├─pages // 路由页面 ├─App.vue // vue 主体文件 ├─index.js // 入口文件 └─router.js // 路由文件，配置路由的 渲染进程webpack 配置： // configs/webpack.render.config.js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const VueLoaderPlugin = require('vue-loader/lib/plugin'); const webpack = require('webpack') // loader 自行npm install module.exports = { mode: 'development', entry: './src/render/index.js', devtool: 'eval-source-map', // target: 'electron-renderer', // 加了反而报错 output: { filename: '[name].js', path: path.resolve(__dirname, '../dist/render') }, module: { rules: [ // babel-loader, less-loader 等等 { test: /\\.vue$/, // 编译vue loader: 'vue-loader' } // ... 图片字体文件等等的文件配置 ] }, plugins: [ new VueLoaderPlugin(), // 编译vue new HtmlWebpackPlugin({template: path.resolve(__dirname, '../public/index.html')}), new webpack.HotModuleReplacementPlugin() ], // 往后devServer 会改成nodejs 的方式启动 devServer: { contentBase: path.resolve(__dirname, '../dist/render'), hot: true, compress: true, port: 9000, open: true } } 要是执行命令webpack-dev-server --config ./configs/webpack.dev.config.js 没报错，那没渲染进程基本没问题了，另外我们往后 会把devServer 改成 nodejs的方式启动 配置主进程我们会把主进程的js 放入src/main/目录下， 但其实只有index.js const path = require('path'); module.exports = { entry: './src/main/index.js', mode: 'development', output: { filename: '[name].js', path: path.resolve(__dirname, \"../dist/main\") }, target: 'electron-main' } 用nodejs 的方式启动这些配置// 渲染进程 //https://webpack.docschina.org/guides/development // 因为webpack-hot-middleware 只能检测到文件发生变化时重新加载，但不能刷新浏览器，所以我们加入 webpack-dev-server， 让浏览器自动刷新 function createRendererServer() { return new Promise((resolve, reject) => { // 直接添加 wenpack-hot-middleware/client.js, rendererConfig.entry = ['webpack-hot-middleware/client?noInfo=true&amp;reload=true'].concat(rendererConfig.entry); const compiler = webpack(rendererConfig); hotMiddleware = webpackHotMiddleware(compiler, { log: false, heartbeat: 2500 }) compiler.hooks.done.tap('done', stats => { console.log(\"完成\");}) const server = new webpackDevServer(compiler, { contentBase: path.resolve(__dirname, '..'), quiet: true, before (app, ctx) { // express, 可获取 node 服务 app 实例，执行中间件操作 app.use(hotMiddleware) ctx.middleware.waitUntilValid(() => { resolve() }) } }); server.listen(9000); }) } // 因为主进程的index.js 文件不常改，我们直接使用watch 的方式，监听文件变化，文件一变化，那么我们就重新启动electron function createMainServer() { return new Promise((resolve, reject) => { const compiler = webpack(mainConfig); // 主进程监听文件变化， webpack watch 模式，那么就从起electron, 即调用electron . compiler.watch({ aggregateTimeout: 300, poll: 1000 }, (err, stats) => { if (err) { console.log(err) return } if (electronProcess &amp;&amp; electronProcess.kill) { manualRestart = true process.kill(electronProcess.pid) electronProcess = null startElectron() // 用 nodejs spawn的方式启动electron , 启动加载的js 应该是在 /dist/main/main.js ,该方法就不写了 setTimeout(() => { manualRestart = false }, 5000) } resolve() }) }) } 我们用Promise.all([createRendererServer(), createMainServer()]) 这两个都编译好之后再启动electron .then(() =&gt; startElectron()); 效果 最后浏览器打开localhost:9000 一样也可以，另外就是 nwjs 的开发环境也大致一样吧","categories":[{"name":"electron","slug":"electron","permalink":"http://yoursite.com/categories/electron/"},{"name":"vue","slug":"electron/vue","permalink":"http://yoursite.com/categories/electron/vue/"},{"name":"webpack","slug":"electron/vue/webpack","permalink":"http://yoursite.com/categories/electron/vue/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"electron","slug":"electron","permalink":"http://yoursite.com/tags/electron/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"长列表实践","slug":"长列表实践","date":"2020-04-15T06:33:51.000Z","updated":"2020-04-18T03:12:13.650Z","comments":true,"path":"2020/04/15/长列表实践/","link":"","permalink":"http://yoursite.com/2020/04/15/%E9%95%BF%E5%88%97%E8%A1%A8%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"场景描述当在一些展示性页面的时候，会经常性使用一些列表进行渲染，但是当数据太多的时候，dom 节点不断累加，会造成滚动时页面的卡顿，影响用户体验 解决方案：虚拟列表 核心思想虚拟列表只对可视区域中的列表进行渲染, 滚动时改变渲染的数组 子列表元素高度固定时 整个列表高度固定 可视区域渲染条数固定 可根据滚动距离，得到渲染的数组 移动可视区域到滚动的距离位置 当有10000条数据，屏幕高度为500时, 子元素高度为50，那么可渲染区域应该渲染为10条数据, 整个列表高度为50 * 10000 当我们发生滚动的时候，比如滚动了150px，那么我们可见区域的渲染列表就变成了下图 第4项到第13项了 结构&lt;div className={styles.page} style={{height: pageHeight + \"px\"}} ref=\"container\"> {/* 屏幕高度 */} &lt;div className={styles.infiniteListGhost} style={{height: infiniteListGhostHeight + \"px\"}} >&lt;/div> {/* list 高度 */} &lt;div className={styles.renderList} style={{ transform: `translate3d(0, ${translate}px, 0)`}} > {/* 可见list 高度 */} { renderList.map((item, index) => { return ( &lt;div className={styles.item} key={index} style={{height: itemHeight + \"px\"}}> {/* 子列表元素高度 */} { item } &lt;/div> ) }) } &lt;/div> &lt;/div> .page { overflow-y: auto; width: 100%; position: relative; .infiniteListGhost { position: absolute; left: 0; right: 0; top: 0; z-index: -1; } .renderList { position: absolute; left: 0; right: 0; top: 0; z-index: 1; .item { color: #000; border: 1px solid #ccc; display: flex; flex-direction: row; align-items: center; justify-content: center; } } } 子列表项的高度为 itemHeight = 50, 滚动高度 为 scrollTop 屏幕高度： pageHeight = document.body.clientHeight; 列表高度： infiniteListGhostHeight = list.length * itemHeight 渲染条数： const itemCount = Math.ceil(clientHeight / itemHeight ); startIndex: startIndex = Math.floor(scrollTop / itemHeight) endIndex: endIndex = startIndex + itemCount 列表渲染数组： list.slice(startIndex, endIndex); startOffset: startOffset = scrollTop - (scrollTop % itemHeight); 滚动倍数 state = { pageHeight: 0, //屏幕高度 infiniteListGhostHeight: 0, // 列表总高度 renderList: [], // 渲染列表 itemHeight: 80, translate: 0, // 可视区域偏移 } componentDidMount() { const { itemHeight } = this.state this.refs.container.addEventListener('scroll', this.handleScroll); const clientHeight = document.body.clientHeight; const itemCount = Math.ceil(clientHeight / itemHeight ); this.setState({ pageHeight: clientHeight, infiniteListGhostHeight: result.length * itemHeight, renderList: result.slice(0, itemCount) }) } componentWillUnmount() { this.refs.container.removeEventListener('scroll', this.handleScroll); } handleScroll = (e) => { const { itemHeight, pageHeight, infiniteListGhostHeight } = this.state const scrollTop = e.srcElement.scrollTop || e.srcElement.scrollTop; // 从scrollTop 计算出偏移startIndex const itemCount = Math.ceil(pageHeight / itemHeight ); //可视区域高度 / 子项高度 = 子项个数 const startIndex = Math.floor(scrollTop / itemHeight); const endIndex = startIndex + itemCount; const list = result.slice(startIndex, endIndex ); const startOffset = (scrollTop - (scrollTop % itemHeight)); this.setState({ translate: startOffset, renderList: list }) } 效果 可以看出，只渲染可视区域内的数据 设置上下缓存区 当滚动太块的时候，往下会有一段空白， 往上也有一段空白，那么这时候设置上下缓冲区可以解决此问题 handleScroll = (e) => { // .... const above = Math.min(startIndex, itemCount); const below = Math.min(result.length - endIndex, itemCount);; const start = startIndex - above; const end = endIndex + below; const list = result.slice(start, end); // 注意此时list的渲染会加上缓存区，所以导致了偏移向下了，但实际上应该减掉 上方缓冲区才能渲染中间的 const startOffset = (scrollTop - (scrollTop % itemHeight) - above * itemHeight); } 此时效果：","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"导航栏吸顶","slug":"导航栏吸顶","date":"2020-04-09T08:06:17.000Z","updated":"2020-04-11T02:59:36.898Z","comments":true,"path":"2020/04/09/导航栏吸顶/","link":"","permalink":"http://yoursite.com/2020/04/09/%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%90%B8%E9%A1%B6/","excerpt":"","text":"导航栏吸顶 当页面滚动超过导航栏时，导航栏依附固定在页面顶端 下面介绍两种方式吧， 一种是 position: sticky, 另一种是getBoundingClientRect() position: sticky 实现.stickyPostion { postion: sticky; top: 0; } 使用条件： 父元素不能overflow:hidden或者overflow:auto属性。 必须指定top、bottom、left、right4个值之一，否则只会处于相对定位 父元素的高度不能低于sticky元素的高度 sticky元素仅在其父元素内生效 sticky 坑 兼容性不太好 不能触发 BFC getBoundingClientRect()getBoundingClientRect用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。getBoundingClientRect是DOM元素到浏览器可视范围的距离（不包含文档卷起的部分）。 获取当前 nav 到浏览器顶端的距离。 直接监听scroll 事件， 用div包裹住nav导航栏，我们只需要获取当前div到顶端的距离即可，等到时 top值为0的时候，设置子级的position:fixed, 还原只需取消掉子级的position即可 如果没有用div 包裹 nav导航栏的话，等top 值为0，就无法还原了，position 一直为fix, getBoundingClientRect.top值一直为0; 结构应该如下： &lt;div ref={this.stickyRef} id=\"sticky\"> &lt;div className={isFixed ? styles.fix : styles.static}> // 这个为nav &lt;div>吸顶效果&lt;/div> &lt;/div> &lt;/div> componentDidMount() { const top = this.stickyRef.current.getBoundingClientRect().top; this.setState({ initPostionTop: top }) window.addEventListener('scroll', this.handleScroll); } handleScroll = (e) => { const { isFixed, initPostionTop } = this.state const scrollTop = e.srcElement.body.scrollTop || e.srcElement.documentElement.scrollTop; // 这里做了个优化，防止频繁setState, 如果一开始为吸顶，以及滚动距离大于 nav 到顶部的距离的时候， // 或者 （不吸顶同时当前滚动距离小于nav到顶部的距离时)我们操作 if(isFixed &amp;&amp; scrollTop >= initPostionTop || !isFixed &amp;&amp; scrollTop &lt;= initPostionTop) { return ; } else { this.setState({ isFixed: scrollTop > initPostionTop }) } } 小程序 (我使用的是Taro) 小程序不支持 window.addEventListener(&#39;scroll&#39;, this.handleScroll);，只有onPageScroll 下面是官方说明注意：请只在需要的时候才在 page 中定义此方法，不要定义空方法。以减少不必要的事件派发对渲染层-逻辑层通信的影响。注意：请避免在 onPageScroll 中过于频繁的执行 this.setState() 等引起逻辑层-渲染层通信的操作。尤其是每次传输大量数据，会影响通信耗时。 taro获取节点有点坑 componentDidMount() { // 注意this.$scope const query = Taro.createSelectorQuery().in(this.$scope); query.select('#sticky').boundingClientRect((rect) => { this.setState({ initPostionTop: rect.top }) }).exec(); } onPageScroll 代码基本一样 坑 这种方式有个坑，当吸顶的一瞬间，会发生抖动，这是因为 position变成fixed 的时候脱离了文档流。解决方案是 在postion:fixed;的元素里添加transform: translateZ(0);,我想应该是开启gpu 渲染，所以变得顺滑了吧 关于优化 h5 优化，可以用另一种方式，就是用 监听滚动的时候使用 节流， 可以用 lodash.throttle window.addEventListener(&#39;scroll&#39;, _.throttle(self.handleScrollThree, 50)); 效果","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"一行代码使网站变灰","slug":"一行代码使网站变灰","date":"2020-04-08T08:00:48.000Z","updated":"2020-04-11T02:59:36.897Z","comments":true,"path":"2020/04/08/一行代码使网站变灰/","link":"","permalink":"http://yoursite.com/2020/04/08/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%BD%91%E7%AB%99%E5%8F%98%E7%81%B0/","excerpt":"","text":"先看看效果吧 分析 网站变灰用到的是 css3 的 filter 属性，其实就是滤镜 代码html { filter: grayscale(0.95) } filter 还能做 高斯模糊，色相旋转， 色相透明，调整对比度等等， filter: blur(5px); // 高斯模糊 filter: contrast(200%); // 调整对比度 filter: opacity(30%); // 调整透明度","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-08T03:33:51.000Z","updated":"2020-04-18T15:59:32.828Z","comments":true,"path":"2020/04/08/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"antd","slug":"react/antd","permalink":"http://yoursite.com/categories/react/antd/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"},{"name":"js-xlsx","slug":"js-xlsx","permalink":"http://yoursite.com/categories/js-xlsx/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"},{"name":"electron","slug":"electron","permalink":"http://yoursite.com/categories/electron/"},{"name":"vue","slug":"electron/vue","permalink":"http://yoursite.com/categories/electron/vue/"},{"name":"webpack","slug":"electron/vue/webpack","permalink":"http://yoursite.com/categories/electron/vue/webpack/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"algorithm-深度搜索优先","slug":"algorithm-深度搜索优先","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E4%BC%98%E5%85%88/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-深度遍历搜索","slug":"algorithm-深度遍历搜索","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"antd","slug":"antd","permalink":"http://yoursite.com/tags/antd/"},{"name":"algorithm-全排列","slug":"algorithm-全排列","permalink":"http://yoursite.com/tags/algorithm-%E5%85%A8%E6%8E%92%E5%88%97/"},{"name":"algorithm-链表","slug":"algorithm-链表","permalink":"http://yoursite.com/tags/algorithm-%E9%93%BE%E8%A1%A8/"},{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"algorithm-栈","slug":"algorithm-栈","permalink":"http://yoursite.com/tags/algorithm-%E6%A0%88/"},{"name":"algorithm-数组","slug":"algorithm-数组","permalink":"http://yoursite.com/tags/algorithm-%E6%95%B0%E7%BB%84/"},{"name":"algorithm-分治","slug":"algorithm-分治","permalink":"http://yoursite.com/tags/algorithm-%E5%88%86%E6%B2%BB/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"},{"name":"js-xlsx","slug":"js-xlsx","permalink":"http://yoursite.com/tags/js-xlsx/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"},{"name":"algorithm-双指针","slug":"algorithm-双指针","permalink":"http://yoursite.com/tags/algorithm-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"algorithm-二分法","slug":"algorithm-二分法","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"algorithm-map","slug":"algorithm-map","permalink":"http://yoursite.com/tags/algorithm-map/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"algorithm-排序","slug":"algorithm-排序","permalink":"http://yoursite.com/tags/algorithm-%E6%8E%92%E5%BA%8F/"},{"name":"algorithm-快速排序","slug":"algorithm-快速排序","permalink":"http://yoursite.com/tags/algorithm-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"algorithm-面试题","slug":"algorithm-面试题","permalink":"http://yoursite.com/tags/algorithm-%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"algorithm-前缀和","slug":"algorithm-前缀和","permalink":"http://yoursite.com/tags/algorithm-%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"electron","slug":"electron","permalink":"http://yoursite.com/tags/electron/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}