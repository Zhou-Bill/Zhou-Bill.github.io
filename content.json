{"meta":{"title":"Chow Bill's Blog","subtitle":"","description":"","author":"Chow Bill","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-07-27T03:03:29.000Z","updated":"2023-02-14T15:19:27.748Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于博客我使用的主题是Chic, 该主题没有搜索，所以我自定义了一个搜索，具体操作可以看看hexo自定义案例 另外项目搭建在 github 和 gitee 关于我 既然相遇是偶然，又何必在意分别时的突然 喜欢看电影(强推 《毛骗》)，听歌，写代码, 看看书 坚持每天一道力扣题 QQ: 735051883 wechat：735051883 我关注的技术博客 creeperyang careteenL/blog PDKSophia/blog.io 前端内参 阿里大佬 js、es6专题 九部知识库 canvas yck js-33个概念 前端伪大叔 面试题 js/css/html等等面试题汇总 【前端进阶】 JavaScript Questions js-react-css-html-interview-question Weekly-FE-Interview 源码系列 vue react 正则表达式 正则表达式 regexr-cn 正则练习网站 书籍 《JavaScript 高级程序设计 - 第三版》 《深入浅出webpack》 写个脚本把弹出框删除即可继续阅读 《剑指offer》 微信读书 《你不知道的Javascript》 微信读书 之前在github找到的，后来又没找到"},{"title":"力扣","date":"2020-04-08T08:09:43.000Z","updated":"2023-02-14T15:19:27.748Z","comments":true,"path":"algorithm/index.html","permalink":"http://yoursite.com/algorithm/index.html","excerpt":"","text":""},{"title":"category","date":"2020-04-08T08:12:55.000Z","updated":"2023-02-14T15:19:27.748Z","comments":true,"path":"category/index.html","permalink":"http://yoursite.com/category/index.html","excerpt":"","text":""},{"title":"tag","date":"2020-04-08T08:09:43.000Z","updated":"2023-02-14T15:19:27.748Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"taro 升级遇见的坑","slug":"taro 升级遇见的坑","date":"2023-02-14T15:00:00.000Z","updated":"2023-02-14T15:26:51.727Z","comments":true,"path":"2023/02/14/taro 升级遇见的坑/","link":"","permalink":"http://yoursite.com/2023/02/14/taro%20%E5%8D%87%E7%BA%A7%E9%81%87%E8%A7%81%E7%9A%84%E5%9D%91/","excerpt":"","text":"taro 升级遇见的坑背景：公司的小程序UI库已经多年不更新了，部分UI 有bug，也懒得到原仓库修改，于是便有了这次的升级，将采用@antmjs/vantui 这个新的ui 库， 目前taro 为 3.6.1 使用以下命令升级, 等待依赖下载完成。 taro update project 1. 遇到了平台不兼容问题因为我们包里面使用已.weapp.ts 表示微信小程序。 已.ts 表示pc 或者其他平台，升级后导致 MultiPlatformPlugin 这个插件 使用失败 原来的使用方法是 chain.resolve.plugin('MultiPlatformPlugin').tap((args) => { return [ ...args, { include: ['@gm-mobile', 'gm_api'], }, ] }) 需要更改成，即修改webpack extentions, 去除 MultiPlatformPlugin chain.resolve.extensions.prepend('.weapp.ts') chain.resolve.extensions.prepend('.weapp.tsx') 修改了babel.config.js , 以及 package.json 的 browserslist babel 会根据你设置的浏览器，根据预设值，去使用对应的插件，将代码转换，算是打个补丁 // babel.config.js presets: [ ['taro', { framework: 'react', ts: true }] ], // package.json \"browserslist\": [ \"last 3 versions\", \"Android >= 4.1\", \"ios >= 8\" ], 2. 升级后发现字体，padding 等分辨率 有很大差别原因是： taro 后面基础设计图的尺寸修改成 750, 导致了样式偏大或偏小 解决方法： 参考 Taro 配置 designWidth(input) { if (input.file &amp;&amp; input.file.indexOf('@antmjs/vantui') > -1) { return 750 } return 375 }, deviceRatio: { 375: 2 / 1, // 之前已375 为基础尺寸 640: 2.34 / 2, 750: 1, 828: 1.81 / 2 }, 3. 升级后发现打包后的产物变大了taro 默认使用webpack4 作为打包工具, 打包的产物包含了babel/helper 等 解决方法： 使用webpack5, 但你需要安装webpack5, 依赖里面没有，导致报错了，安装后正常 yarn add webpack // cpnfig/index.js compiler: { type: 'webpack5', prebundle: { enable: false }, }, 4. 升级后发现moment 打包会把其他语言也打包进去项目中之前是用了 ContextReplacementPlugin 去忽略其他语言的加载，但后面失效了。找了很久没找到解决方案，最后在issue 里面获得启发 解决方法：调用webpackChain(chain, webpack) // config/index.js chain .plugin('IgnorePlugin') .use(new webpack.ContextReplacementPlugin(/moment[/\\\\]locale$/, /zh-cn/)) // moment 需要过滤，表示package.json 引用的是main 字段 chain.resolve.mainFields.clear(); chain.merge({ resolve: { mainFields: ['module', 'main', 'jsnext:main'] } }) 5. 引入本地含svg的iconfont报错相关issue 查找了下postcss-url 说可以忽略，但是没找到taro 的配置","categories":[{"name":"taro","slug":"taro","permalink":"http://yoursite.com/categories/taro/"}],"tags":[{"name":"taro","slug":"taro","permalink":"http://yoursite.com/tags/taro/"}]},{"title":"typescript 获取url 参数，类型应该怎么写","slug":"typescript 获取url 参数，类型应该怎么写","date":"2022-05-20T09:10:32.000Z","updated":"2023-02-14T15:19:27.732Z","comments":true,"path":"2022/05/20/typescript 获取url 参数，类型应该怎么写/","link":"","permalink":"http://yoursite.com/2022/05/20/typescript%20%E8%8E%B7%E5%8F%96url%20%E5%8F%82%E6%95%B0%EF%BC%8C%E7%B1%BB%E5%9E%8B%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99/","excerpt":"","text":"前言有天面试的时候，面试官问如何写 获取url 参数类型应该怎么写？ 当时回答用的是 infer，跟泛型还有递归，但是面试官说哪里需要用到 泛型, 说参数不就是一个string吗，后来就不了了之了。 但回家想了一下，确实应该使用泛型，我的解决思路是没有问题的 解决思路 比如当前 url 为 https://www.baidu.com?key12=0123123&amp;key1=1, 那么我们要获取key12 跟 value: 0123123 先截取字符串?之后的值，得到的结果是 key12=0123123&amp;key1=1 然后截取 ${key}=${value} 这个字符串, 得到的结果是 key = key12, value = 0123123&amp;key1=1, 你可以发现value 仍然包含其他值 key value 值， 那么这里我们递归解决就行了 判断逻辑是 如果么有包含 &amp; 那么我们就构建对象，{ [k in key]: value } 最后递归合并对象即可 完整代码type Merge&lt;F, S> = {[key in keyof F | keyof S]: key extends keyof S ? S[key] : key extends keyof F ? F[key] : never}; type getKeys&lt;T extends string> = T extends `${infer K}?${infer Rest}` ? Rest : '' type keyToValue&lt;T extends string> = T extends `${infer key}=${infer value}` ? value extends `${infer V}&amp;${infer rest}` ? Merge&lt;{[k in key]: V}, keyToValue&lt;rest>> : { [k in key]: value } : {} type A = getKeys&lt;'https://www.baidu.com?key12=0123123&amp;key1=1'> type B = keyToValue&lt;A> const url = 'https://www.baidu.com?key12=0123123&amp;key1=1' function getParameter&lt;T extends string>(url: T): keyToValue&lt;getKeys&lt;T>> { const [ , format] = url.split(\"?\"); const data = format.split(\"&amp;\") const result = {} as keyToValue&lt;getKeys&lt;T>> data.forEach((_item) => { const [key, value] = _item.split(\"=\") result[key] = value }) return result } const q = getParameter(url) 在线demodemo","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"在自己的vps上安装Jenkins","slug":"在自己的vps 上安装Jenkins","date":"2022-05-20T09:10:32.000Z","updated":"2023-02-14T15:19:27.735Z","comments":true,"path":"2022/05/20/在自己的vps 上安装Jenkins/","link":"","permalink":"http://yoursite.com/2022/05/20/%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84vps%20%E4%B8%8A%E5%AE%89%E8%A3%85Jenkins/","excerpt":"","text":"安装jdk首先查看是否含有jdk // 执行 javac // 或者 java -version 如果没有安装 yum install -y java-1.8.0-openjdk-devel.x86_64 找到jdk 位置 which java 安装jenkins官方下载，但是下载失败了, 因为被墙了 sudo wget -O /etc/yum.repos.d/jenkins.repo \\ https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key sudo yum upgrade # Add required dependencies for the jenkins package sudo yum install java-11-openjdk sudo yum install jenkins 其他方式下载 wget https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/jenkins-2.332.3-1.1.noarch.rpm rpm -ivh jenkins-2.332.3-1.1.noarch.rpm 启动jenkins# 启动jenkins systemctl start jenkins # 查看jenkins systemctl status jenkins # 重启jenkins systemctl restart jenkins # 停止jenkins systemctl stop jenkins 初始端口是8080, 可以通过修改vim /etc/sysconfig/jenkins 配置文件更改端口号 FAQ打开网站ip:[端口] 配置jenkins, 如果是线上ECS 服务器 有可能访问不成功, 请检查下面几个原因 是否已安装jdk，命令：Java -version 查看防火墙状态： systemctl status firewalld.service 查看端口号是否开放netstat -natp 如果是阿里云等服务器 需要将端口号加入到安全组 安装 nginx 安装额外的软件仓库 sudo yum install epel-release -y 安装nginx sudo yum install nginx -y 在服务器上设置 gitgit config --global user.name \"Bill\" git config --global user.email \"735051883@qq.com\" 设置sshssh-keygen -t rsa -C \"735051883@qq.com\" 验证是否通过ssh -T git@github.com 坑：在jenkins 上建立项目，无法连接github是因为在jenkins 上连接github 是用了jenkins 用户的ssh, 重新生成秘钥，添加到github上即可或者从~/.ssh 复制过去也行 su root cd /var/lib/jenkins/.ssh ssh-keygen -t rsa -C your-email@sample.com # 注意下一步提示保存位置的时候，要再输入 /var/lib/jenkins/.ssh/id_rsa # Enter file in which to save the key (/root/.ssh/id_rsa): /var/lib/jenkins/.ssh/id_rsa # 改变用户 chown jenkins:jenkins id_rsa id_rsa.pub cat id_rsa.pub 或者 sudo mv ~/.ssh/id_rsa.pub /var/lib/jenkins/.ssh/ sudo mv ~/.ssh/id_rsa /var/lib/jenkins/.ssh/ sudo mv ~/.ssh/knows_host /var/lib/jenkins/.ssh/ chown jenkins:jenkins id_rsa id_rsa.pub knows_host 配置nginxcd /etc/nginx/conf.d vi cra-app.conf 使用以下配置 server { listen 80; server_name localhost; root /home/www/cra-app; index index.php index.html; location / { try_files $uri $uri/ /index.php?$query_string; } } 注意： 虚拟机需要关闭 selinux, 否则上面配置会没法显示; # 查看seLinux 状态 getenforce 关闭它 sudo vim /etc/selinux/config # SELINUX=enforcing改为 SELINUX=disabled 这里记录一下nginx root 与alias 的区别 当我们这样设置 root 的时候：location /i/ { root /data/w3; } 当请求 /i/top.gif ，/data/w3/i/top.gif 会被返回。 当我们这样设置 alias 的时候：location /i/ { alias /data/w3/images/; } 当请求 /i/top.gif ，/data/w3/images/top.gif 会被返回。 乍一看两者很像，但细一看，就能看出两者的区别，root 是直接拼接 root + location 而 alias 是用 alias 替换 location，所以 root 中最后的路径里有 /i/，而 alias 中最后的路径里没有 /i/ 。 所以如果你这样使用 allias 定义一个路径： location /images/ { alias /data/w3/images/; } 其实使用 root 会更好： location /images/ { root /data/w3; } server 和 location 中的 rootserver 和 location 中都可以使用 root，举个例子： http { server { listen 80; server_name www.yayujs.com; root /home/www/website/; location / { root /home/www/ts/; index index.html; } } } 如果两者都出现，是怎样的优先级呢？简单的来说，就是就近原则，如果 location 中能匹配到，就是用 location 中的 root 配置，忽略 server 中的 root，当 location 中匹配不到的时候，则使用 server 中的 root 配置。","categories":[{"name":"jenkins","slug":"jenkins","permalink":"http://yoursite.com/categories/jenkins/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://yoursite.com/tags/jenkins/"}]},{"title":"React Router 源码学习","slug":"react-router 学习","date":"2022-05-03T02:11:25.000Z","updated":"2023-02-14T15:19:27.731Z","comments":true,"path":"2022/05/03/react-router 学习/","link":"","permalink":"http://yoursite.com/2022/05/03/react-router%20%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"BrowserRouter先看一些例子 const App = () => { return ( &lt;BrowserRouter> &lt;BrowserRouter> &lt;Routes> &lt;Route path=\"/\" element={&lt;Layout />}> &lt;Route index element={&lt;Home/>} /> &lt;Route path=\"/courses\" element={&lt;CourseLayout />}> &lt;Route index element={&lt;CourseIndex/>} /> &lt;Route path=\"/courses/:id\" element={&lt;Course/>} /> &lt;/Route> &lt;/Route> {/* &lt;Route path=\"*\" element={&lt;NotMatch/>} /> */} &lt;/Routes> &lt;/BrowserRouter> &lt;/BrowserRouter> ) } 源码实现 使用 history 库 创建 BrowserHistory 监听当前history变化, 即当 url 中的location 发生变化时, 会重新setState 讲这些参数传到&lt;Router /&gt;组件中， &lt;Router /&gt; 组件 其实就是包含两个 provider 的 context export function BrowserRouter({ basename, children, window, }: BrowserRouterProps) { let historyRef = React.useRef&lt;BrowserHistory>(); if (historyRef.current == null) { historyRef.current = createBrowserHistory({ window }); } let history = historyRef.current; let [state, setState] = React.useState({ action: history.action, location: history.location, }); React.useLayoutEffect(() => history.listen(setState), [history]); return ( &lt;Router basename={basename} children={children} location={state.location} navigationType={state.action} navigator={history} /> ); } 组件简易实现 传下去的children 就是 , 后面需要对 Routes下的children 进行遍历 const Router = (props) => { const { basename, children, location: locationProps navigator } = props; // 对当前locationProps 做处理，最后返回, 这里我直接用‘’ 表示 const location = { pathname: '', search: '', hash: '', state: '', key: '', } // navigator 就是 history let navigationContext = React.useMemo( () => ({ basename, navigator, static: staticProp }), [basename, navigator, staticProp] ); return ( &lt;NavigationContext.Provider value={navigationContext}> &lt;LocationContext.Provider children={children} value={{ location, navigationType }} /> &lt;/NavigationContext.Provider> ) } 再来看 export function Routes({ children, location, }: RoutesProps): React.ReactElement | null { return useRoutes(createRoutesFromChildren(children), location); } 这里说明一下&lt;Route&gt; 就是一个空方法，但在下面遍历的时候会判断当前组件是不是&lt;Route /&gt; 后面也是会直接收集element 属性createRoutesFromChildren 是对 进行children 遍历，获取路由，这里会进行递归操作，如果 进行嵌套的话，element.props.children 就会进行递归遍历在遍历过程中会判断当前组件是不是，如果不是会报错已上面例子为例： 就会生成以下结果： [ { caseSensitive: '', element: &lt;Layout />, index: '', path: '/', children: [ { caseSensitive: '', element: &lt;Home />, index: true, path: undefined, }, { caseSensitive: '', element: &lt;CourseLayout />, index: undefined, path: \"/courses\", children: [ // 略 ] } ] } ] export function createRoutesFromChildren( children: React.ReactNode ): RouteObject[] { let routes: RouteObject[] = []; React.Children.forEach(children, (element) => { if (!React.isValidElement(element)) { return; } if (element.type === React.Fragment) { routes.push.apply( routes, createRoutesFromChildren(element.props.children) ); return; } // 判断当前children 是不是&lt;Route /> 组件, 如果不是会报错， invariant( element.type === Route, `[${ typeof element.type === \"string\" ? element.type : element.type.name }] is not a &lt;Route> component. All component children of &lt;Routes> must be a &lt;Route> or &lt;React.Fragment>` ); let route: RouteObject = { caseSensitive: element.props.caseSensitive, element: element.props.element, index: element.props.index, path: element.props.path, }; if (element.props.children) { route.children = createRoutesFromChildren(element.props.children); } routes.push(route); }); return routes; } 在来看 useRoutes 这个hook, 这个hook 生成了一个ReactNode, 是一个 RouterContext.Provider 生成的节点 从上面得到的routes列表以及 url 上的location 可以得到符合当前地址的所有路由，数组顺序为路由的辈分关系比如上面的 /courses 连接, 会得到一下匹配的路由 matches = [ { params: {}, pathname: \"/\", pathnameBase: \"/\", route: [ { caseSensitive: '', element: &lt;Layout />, index: '', path: '/', children: [ // 略 ] } ] }, { params: {}, pathname: \"/courses\", pathnameBase: \"/courses\", route: [ { caseSensitive: '', element: &lt;CourseLayout />, index: undefined, path: \"/courses\", children: [ // 略 ] } ] }, { params: {}, pathname: \"/courses/\", pathnameBase: \"/courses\", route: [ { caseSensitive: '', element: &lt;CourseIndex />, index: true, path: undefined, } ] } ] 生成节点, 这里的outlet 可以当做children，在官网上可以用 &lt;Outlet /&gt; 表示 children 如果有element, 那么用provider 包裹一下，注意：这里是从孙子节点到爷爷节点反序构建节点的 export function _renderMatches( matches: RouteMatch[] | null, parentMatches: RouteMatch[] = [] ): React.ReactElement | null { if (matches == null) return null; return matches.reduceRight((outlet, match, index) => { return ( &lt;RouteContext.Provider children={ match.route.element !== undefined ? match.route.element : outlet } value={{ outlet, matches: parentMatches.concat(matches.slice(0, index + 1)), }} /> ); }, null as React.ReactElement | null); } 可以这么理解 // 第一次 let first = ( &lt;RouteContext.Provider> children={ &lt;CourseIndex /> } value={{ outlet: null, matches: matches.slice(0, 3) }} > &lt;/RouteContext.Provider> ) // 第二次 let second = ( &lt;RouteContext.Provider> children={ &lt;CourseLayout /> } value={{ outlet: first, matches: matches.slice(0, 2) }} > &lt;/RouteContext.Provider> ) // 第三次 let third = ( &lt;RouteContext.Provider> children={ &lt;Layout /> } value={{ outlet: second, matches: matches.slice(0, 1) }} > &lt;/RouteContext.Provider> ) 在嵌套的路由中渲染 children 文档地址 嵌套路由中使用children, 是使用 API 中的 &lt;Outlet /&gt;, 我们知道上面在匹配matches 的时候, 会进行&lt;RouteContext.Provider /&gt;封装，同时传递 outlet 给他的子组件，那么&lt;OutLet /&gt;可以消费他的context 实现 const OutletContext = React.createContext&lt;unknown>(null); export function Outlet(props: OutletProps): React.ReactElement | null { return useOutlet(props.context); } export function useOutlet(context?: unknown): React.ReactElement | null { let outlet = React.useContext(RouteContext).outlet; if (outlet) { return ( &lt;OutletContext.Provider value={context}>{outlet}&lt;/OutletContext.Provider> ); } return outlet; } Link 组件实现 Link 其实是用 &lt;a /&gt; 标签 做的, 当我们传入自定义onClick 事件，会在点击时运行，后续会判断一下event.defaultPrevented， 表明当前事件是否被调用了，如果没有则调用内置internalOnClick 事件 export const Link = React.forwardRef&lt;HTMLAnchorElement, LinkProps>( function LinkWithRef( { onClick, reloadDocument, replace = false, state, target, to, ...rest }, ref ) { let href = useHref(to); let internalOnClick = useLinkClickHandler(to, { replace, state, target }); function handleClick( event: React.MouseEvent&lt;HTMLAnchorElement, MouseEvent> ) { if (onClick) onClick(event); if (!event.defaultPrevented &amp;&amp; !reloadDocument) { internalOnClick(event); } } return ( &lt;a {...rest} href={href} onClick={handleClick} ref={ref} target={target} /> ); } ); useLinkClickHandler 的实现 其实就是调用了 history.push 或者是 history.replace 做跳转 export function useLinkClickHandler&lt;E extends Element = HTMLAnchorElement>( to: To, { target, replace: replaceProp, state, }: { target?: React.HTMLAttributeAnchorTarget; replace?: boolean; state?: any; } = {} ): (event: React.MouseEvent&lt;E, MouseEvent>) => void { let navigate = useNavigate(); let location = useLocation(); let path = useResolvedPath(to); return React.useCallback( (event: React.MouseEvent&lt;E, MouseEvent>) => { if ( // 表示用户点击了鼠标左键 event.button === 0 &amp;&amp; (!target || target === \"_self\") &amp;&amp; !isModifiedEvent(event) ) { event.preventDefault(); // 判断一下当前应该用 history.replace 还是 history.push let replace = !!replaceProp || createPath(location) === createPath(path); navigate(to, { replace, state }); } }, [location, navigate, path, replaceProp, state, target, to] ); } useNavigation 实现 一开始 &lt;BrowserHistory /&gt; 下的&lt;Router /&gt; 使用 &lt;NavigationContext.Provider /&gt; 下发 navigator,最后返回 navigate 方法，实际上就是 history.replace 或者是 history.push export type Navigator = Pick&lt;History, \"go\" | \"push\" | \"replace\" | \"createHref\">; export function useNavigate(): NavigateFunction { // 这里拿到 navigator， 实际就是 history， 就是一开始 createBrowserHistory let { basename, navigator } = React.useContext(NavigationContext); let { matches } = React.useContext(RouteContext); let { pathname: locationPathname } = useLocation(); let routePathnamesJson = JSON.stringify( matches.map((match) => match.pathnameBase) ); let activeRef = React.useRef(false); React.useEffect(() => { activeRef.current = true; }); let navigate: NavigateFunction = React.useCallback( (to: To | number, options: NavigateOptions = {}) => { if (!activeRef.current) return; if (typeof to === \"number\") { navigator.go(to); return; } let path = resolveTo( to, JSON.parse(routePathnamesJson), locationPathname ); if (basename !== \"/\") { path.pathname = joinPaths([basename, path.pathname]); } // 最后这里 进行 history.replace 或者是 history.push (!!options.replace ? navigator.replace : navigator.push)( path, options.state ); }, [basename, navigator, routePathnamesJson, locationPathname] ); return navigate; }","categories":[{"name":"react-router","slug":"react-router","permalink":"http://yoursite.com/categories/react-router/"}],"tags":[{"name":"react-router","slug":"react-router","permalink":"http://yoursite.com/tags/react-router/"}]},{"title":"记录一下从rc-tree 里面学到了什么东西","slug":"记录一下从rc-tree 里面学到了什么东西","date":"2022-04-22T03:34:34.000Z","updated":"2023-02-14T15:19:27.745Z","comments":true,"path":"2022/04/22/记录一下从rc-tree 里面学到了什么东西/","link":"","permalink":"http://yoursite.com/2022/04/22/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E4%BB%8Erc-tree%20%E9%87%8C%E9%9D%A2%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/","excerpt":"","text":"rc-tree 该文章主要对 TreeNode 的 onChecked 时，如何跟上级还有下级做联动所记录的 先看传入到tree下的 treeData 结构const treeData = [ { title: '1', key: '1', children: [ { title: '1-1', key: '1-1', children: [ { title: '1-1-1', key: '1-1-1', } ] } ] }, { title: '2', key: '2', children: [ { title: '2-1', key: '2-1', children: [ { title: '2-1-1', key: '2-1-1', } ] } ] } ] Tree 使用了Provider 向下级组件传递onNodeChecked 事件源码中用 class 组件的形式写的， 下面给个例子： export const TreeContext = React.createContext(null); const Tree = () => { const onNodeChecked = () => {} return ( &lt;TreeContext.Provider value={{ onNodeChecked }} > &lt;NodeList> &lt;TreeContext.Provider> ) } 消费provider, 类组件例子 const ContextTreeNode: React.FC&lt;TreeNodeProps> = props => ( &lt;TreeContext.Consumer> {context => &lt;InternalTreeNode {...props} context={context} />} &lt;/TreeContext.Consumer> ); 函数组件，消费context const TreeNode = () => { const context = useContext(TreeContext) return ( &lt;div /> ) } 在Tree 接收到treeData 这个props 的时候会进行数据转换在源码中，在 getDerivedStateFromProps 这个生命周期对treeData 进行转换。 class Tree extends Component { static getDerivedStateFromProps(props, prevState) { const { treeData, fieldNames } = props; const newState = { } if (treeData) { newState.treeData = treeData; const entitiesMap = convertDataToEntities(treeData, { fieldNames }); newState.keyEntities = { ...entitiesMap.keyEntities, }; } } } convertDataToEntities 将 treeData 的key 当作键名，value 是当前节点，另外添加他的父节点，最后数据结构应该是这样：以上面treeData 为例子 { 1: { title: '1', key: '1', parentNode: null, children: [ { title: '1-1', key: '1-1', children: [ { title: '1-1-1', key: '1-1-1', } ] } ] }, '1-1': { title: '1-1', parentNode: '1', key: '1-1', children: [ { title: '1-1-1', key: '1-1-1', } ] } '1-1-1': { parentNode: '1-1', title: '1-1-1', key: '1-1-1', } } 我们尝试自己写一下这个方法 // 建立双链表形式的map数据, const convertDataToEntities = (treeData) => { const result = {}; formatedTreeData(treeData, result, 0, 0); console.log(result); return { keyEntities: result } } const formatedTreeData = (treeData, hash, parentKey, level) => { const parentNode = hash[parentKey] || null; treeData.forEach((_item) => { hash[_item.key] = { ..._item, parentNode: parentNode, level: level, } if (_item.children) { formatedTreeData(_item.children, hash, _item.key, level + 1) } }) } // const { keyEntities } = convertDataToEntities(treeData) 接下来实现 onNodeChecked, 选中当前节点时他的下级节点，以及上级节点联动关系 先根据 keyEntities 获取当前树的最大深度, 因为我们当前keyEntities 已经保存有树的深度了，所以只要一次遍历就可以获取到最大的深度在遍历过程中同时对每一层节点进行保存， 即第一层有哪些节点，第二层有哪些节点，我们命名为levelMap 然后维护chekedKeys 这个已选中的节点 从最开始那层 从上而下，遍历每一层节点， 如果当前checkedKeys 包含 当前levelMap[level][item] 那么他的children 应该也需要添加到checkedKeys 里面 从最后那层 由下而上，遍历每层节点，如果当前checkedKeys 包含当前节点的所有children，那么他的父级节点需要被添加到checkedKeys 里面 const onNodeChecked = (e, checkedNode, isChecked) => { const { levelMap, maxLevel } = getLevelEntities(keyEntities); if (isChecked) { // const keys = [...checkedKeys, checkedNode.key]; const keys = ['1-2'] const { halfChecked, checkedKeys } = fillConductCheck(keys, levelMap, maxLevel); console.log(checkedKeys); // 会发现 [1-1-1, 1-1, 1] } } const getLevelEntities = (keyEntities) => { let maxLevel = 0 const levelMap = {} Object.keys(keyEntities).forEach((_item) => { const current = keyEntities[_item]; const { level } = current; maxLevel = Math.max(maxLevel, level); if (typeof levelMap[level] === 'undefined') { levelMap[level] = []; } levelMap[level].push(current); }) return { levelMap, maxLevel } } const fillConductCheck = (keys, levelEntities, maxLevel) => { const checkedKeys = new Set(keys); const halfCheckedKeys = new Set(); // 从上而下 勾选 for (let level = 0; level &lt;= maxLevel; level += 1) { const entities = levelEntities[level] || new Set(); entities.forEach(entity => { const { key, children = [] } = entity; if (checkedKeys.has(key)) { children .forEach(childEntity => { checkedKeys.add(childEntity.key); }); } }); } const visitedKeys = new Set(); for (let level = maxLevel; level >= 0; level -= 1) { const entities = levelEntities[level] || new Set(); entities.forEach(entity => { const { parentNode, node } = entity; // Skip if no need to check if (!entity.parentNode || visitedKeys.has(entity.parentNode.key)) { return; } let allChecked = true; let partialChecked = false; (parentNode.children || []) .forEach(({ key }) => { const checked = checkedKeys.has(key); if (allChecked &amp;&amp; !checked) { allChecked = false; } if (!partialChecked &amp;&amp; (checked || halfCheckedKeys.has(key))) { partialChecked = true; } }); if (allChecked) { checkedKeys.add(parentNode.key); } if (partialChecked) { halfCheckedKeys.add(parentNode.key); } visitedKeys.add(parentNode.key); }); } return { checkedKeys: Array.from(checkedKeys), halfCheckedKeys: halfCheckedKeys, }; }","categories":[],"tags":[{"name":"antd","slug":"antd","permalink":"http://yoursite.com/tags/antd/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"学习webpack源码(2)","slug":"学习webpack源码(2)","date":"2022-02-22T13:17:43.000Z","updated":"2023-02-14T15:19:27.736Z","comments":true,"path":"2022/02/22/学习webpack源码(2)/","link":"","permalink":"http://yoursite.com/2022/02/22/%E5%AD%A6%E4%B9%A0webpack%E6%BA%90%E7%A0%81(2)/","excerpt":"","text":"调试在vscode 中创建调试文件，进行debug, 点击debug，自动创建即可 { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"debugWebpack\", \"program\": \"${workspaceFolder}/bin/webpack.js\", \"console\": \"integratedTerminal\", \"cwd\": \"${workspaceFolder}\", \"args\": [ // \"${workspaceFolder}/examples/examples.js\", // webpack example 目录，我们选其中一个进行调试即可， 详细 example/README.md \"${workspaceFolder}/examples/commonjs/example.js\", ] } ] } 接之前一篇文章, 创建compiler 接下来可以配合官方文档进行阅读compiler hook按照官方顺序就是compiler整个生命周期 梳理 compiler 生命周期 首先进行环境初始化, 即compiler.hook.environment.call(), 但全局搜索没有做订阅 环境初始化后会到 compiler.hook.afterEnvironment.call(), 说明环境初始化完成， IgnoringWatchFileSystem, 应该是做忽略某些文件的监听 从lib/webpack 中的 new WebpackOptionsApply().process(options, compiler); 这里其实是对 option 的配置进行plugin 的加载，且对compiler 对应周期进行注册监听事件。所以这里会经历一个 entryOption 的周期，例如：entry 入口, // 处理入口文件, SyncBailHook , 当返回为非undefined时停止往下执行 new EntryOptionPlugin().apply(compiler); // 执行入口文件回调 compiler.hooks.entryOption.call(options.context, options.entry); // EntryOptionPlugin class EntryOptionPlugin { apply(compiler) { compiler.hooks.entryOption.tap(\"EntryOptionPlugin\", (context, entry) => { EntryOptionPlugin.applyEntryOption(compiler, context, entry); return true; }); } /** 省略其余code */ } 其余配置也差不多， 然后会执行compiler.hooks.afterPlugins.call(compiler); 说明所有的插件已经加载完毕。最后调用compiler.hooks.afterResolvers.call(compiler); 表示compiler 中3种类型的解析器已经全部设置完成，new WebpackOptionsApply().process(options, compiler); 执行完毕 然后 执行 compiler.hook.initialize.call() 最后回到 lib/webpack 执行 compiler.run() Compiler上面已经通过 new Compiler(options.context) 创建compiler, 然后调用compiler.run()进入lib/compiler.js 可以看到创建了多个hooks, 关于tapable, 我觉得这篇文章挺好 run 方法执行， 经历了两个hooks (hooks.beforeRun, hooks.run), 最后执行 this.compiler() compile(callback) { // 创建 normalFactory, 跟 contextFactory, 创建完成之后调用 hooks.normalModuleFactory.call(); hooks.contextModuleFactory.call() const params = this.newCompilationParams(); this.hooks.beforeCompile.callAsync(params, err => { if (err) return callback(err); this.hooks.compile.call(params); const compilation = this.newCompilation(params); const logger = compilation.getLogger(\"webpack.Compiler\"); logger.time(\"make hook\"); this.hooks.make.callAsync(compilation, err => { logger.timeEnd(\"make hook\"); if (err) return callback(err); logger.time(\"finish make hook\"); this.hooks.finishMake.callAsync(compilation, err => { logger.timeEnd(\"finish make hook\"); if (err) return callback(err); process.nextTick(() => { logger.time(\"finish compilation\"); compilation.finish(err => { logger.timeEnd(\"finish compilation\"); if (err) return callback(err); logger.time(\"seal compilation\"); compilation.seal(err => { logger.timeEnd(\"seal compilation\"); if (err) return callback(err); logger.time(\"afterCompile hook\"); this.hooks.afterCompile.callAsync(compilation, err => { logger.timeEnd(\"afterCompile hook\"); if (err) return callback(err); return callback(null, compilation); }); }); }); }); }); }); }); } 2.创建 NormalModuleFactory, 跟 contextModuleFactory, 创建完成之后调用 hooks.normalModuleFactory.call(),hooks.contextModuleFactory.call()NormalModuleFactory 用来生成模块的 之后调用 hooks.beforeCompile， beforeCompile 在LazyCompilationPlugin 下注册了, 这里跟hmr 热更新相关。 同时在DllReferencePlugin, 它是用来拆分bundle，提升构建速度的 具体可以看这 然后调用 hook.compile, 在这DllReferencePlugin, ExternalsPlugin, DelegatedPlugin三个文件中注册了方法 创建 compilation 实例，该实例可以用于factorizeModule, buildModule, addModule， 以及对module的依赖收集, 执行 compiler.hooks.thisCompilation.call 以及compiler.hooks.compilation.call 执行compiler.hooks.make 正式进入到编译阶段 找到 tapAsync 函数， 通过调用addEntry 添加入口文件 compiler.hooks.make.tapAsync(\"EntryPlugin\", (compilation, callback) => { compilation.addEntry(context, dep, options, err => { callback(err); }); }); addEntry(context, entry, optionsOrName, callback) { // TODO webpack 6 remove const options = typeof optionsOrName === \"object\" ? optionsOrName : { name: optionsOrName }; this._addEntryItem(context, entry, \"dependencies\", options, callback); } 然后 _addEntryItem, 会判断是否是多入口等等，然后执行compilation.hooks.addEntry.call 表示添加入口文件完毕, 最后执行addModuleTree this.addModuleTree( { context, dependency: entry, contextInfo: entryData.options.layer ? { issuerLayer: entryData.options.layer } : undefined }, (err, module) => { if (err) { this.hooks.failedEntry.call(entry, options, err); return callback(err); } this.hooks.succeedEntry.call(entry, options, module); return callback(null, module); } ); 来看看 addModuleTree 函数, addModuleTree 里面会执行一个 handleModuleCreation const Dep = /** @type {DepConstructor} */ (dependency.constructor); // 这里会找到直接找到normalModuleFactory const moduleFactory = this.dependencyFactories.get(Dep); this.handleModuleCreation( { factory: moduleFactory, dependencies: [dependency], originModule: null, contextInfo, context }, (err, result) => { if (err &amp;&amp; this.bail) { // error } else if (!err &amp;&amp; result) { callback(null, result); } else { callback(); } } ); 然后 handleModuleCreation 会执行 factorizeModule, 先不用管回调 this.factorizeModule( { currentProfile, factory, dependencies, factoryResult: true, originModule, contextInfo, context }, (err, factoryResult) => { /** 省略部分代码， 只需要知道后续会进行 this.addModule(newModule, () => {}) */ const newModule = factoryResult.module; this.addModule(newModule, () => { // 下面会执行模块创建以及 依赖收集 this._handleModuleBuildAndDependencies( originModule, module, recursive, callback ); }) } ) this.factorizeModule 其实就是简单的将当前模块 添加到一个异步队列中 // this.factorizeModule 通过new AsyncQueue 创建 this.factorizeQueue.add(options, callback); factorizeQueue.add 它是一个异步执行 队列，当有一个任务加入到队列中，最后会执行setImmediate(root._ensureProcessing);,但值得注意的是root 这个参数设计的有点巧妙，是一种父子关系, this.processDependenciesQueue 的children 包含 this.addModuleQueue, this.factorizeQueue , this.buildQueue 最后会执行 setImmediate(root._ensureProcessing); 当前root 是this.processDependenciesQueue。 setImmediate 会在下一次事件循环中调用 /** @type {AsyncQueue&lt;Module, Module, Module>} */ this.processDependenciesQueue = new AsyncQueue({ name: \"processDependencies\", parallelism: options.parallelism || 100, processor: this._processModuleDependencies.bind(this) }); /** @type {AsyncQueue&lt;Module, string, Module>} */ this.addModuleQueue = new AsyncQueue({ name: \"addModule\", parent: this.processDependenciesQueue, getKey: module => module.identifier(), processor: this._addModule.bind(this) }); /** @type {AsyncQueue&lt;FactorizeModuleOptions, string, Module | ModuleFactoryResult>} */ this.factorizeQueue = new AsyncQueue({ name: \"factorize\", parent: this.addModuleQueue, processor: this._factorizeModule.bind(this) }); /** @type {AsyncQueue&lt;Module, Module, Module>} */ this.buildQueue = new AsyncQueue({ name: \"build\", parent: this.factorizeQueue, processor: this._buildModule.bind(this) }); ensureProcessing 会遍历当前实例的children，简单说就是遍历 addModuleQueue, factorizeQueue, buildQueue 三个AsyncQueue 然后从这三个实例的队列中找任务去执行 _ensureProcessing() { // this = this.processDependenciesQueue, // children 包含 this.addModuleQueue, this.factorizeQueue, this.buildQueue this._willEnsureProcessing = false; if (this._queued.length > 0) return; if (this._children !== undefined) { for (const child of this._children) { while (this._activeTasks &lt; this._parallelism) { const entry = child._queued.dequeue(); if (entry === undefined) break; this._activeTasks++; entry.state = PROCESSING_STATE; child._startProcessing(entry); } if (child._queued.length > 0) return; } } if (!this._willEnsureProcessing) this._needProcessing = false; } child._startProcessing, 因为一直从入口过来， 此时的child 是factorize _startProcessing(entry) { this.hooks.beforeStart.callAsync(entry.item, err => { if (err) { // error 处理 } let inCallback = false; try { // compliation._addModule 或者 compliation._factorizeModule 或者 compliation._buildModule // 此时调用的是 compliation._factorizeModule this._processor(entry.item, (e, r) => { inCallback = true; this._handleResult(entry, e, r); }); } catch (err) { if (inCallback) throw err; this._handleResult(entry, err, null); } this.hooks.started.call(entry.item); }); } _factorizeModule 调用了 NormalModuleFactory.create调用了 NormalModuleFactory.hooks.beforeResolve.callAsync, NormalModuleFactory.hooks.factorize.callAsync在NormalModuleFactory.hooks.factorize.tapAsync中调用了 resolve.callAsync, 在 resolve.tapAsync 主要目的是resolve 模块找到模块对应的loader以及loader的路径，描述文件等，这里会执行 enhance-loader, 并且创建 parse 和 generator 赋值到resolveData.createData Object.assign(data.createData, { layer: layer === undefined ? contextInfo.issuerLayer || null : layer, request: stringifyLoadersAndResource( allLoaders, resourceData.resource ), userRequest, rawRequest: request, loaders: allLoaders, resource: resourceData.resource, context: resourceData.context || getContext(resourceData.resource), matchResource: matchResourceData ? matchResourceData.resource : undefined, resourceResolveData: resourceData.data, settings, type, parser: this.getParser(type, settings.parser), parserOptions: settings.parser, generator: this.getGenerator(type, settings.generator), generatorOptions: settings.generator, resolveOptions }); 继续执行 nmf.hooks.afterResolve.callAsync 和 nmf.hooks.createModule.callAsync this.hooks.afterResolve.callAsync(resolveData, (err, result) => { const createData = resolveData.createData; this.hooks.createModule.callAsync(createData, resolveData, (err, createdModule) => { if(!createModule) { createdModule = new NormalModule(createData); } // SideEffectsFlagPlugin 这里做sideEffect createdModule = this.hooks.module.call( createdModule, createData, resolveData ); // 执行完成后调用 hooks.factorize.callAsync 回调 传入当前module 信息, 也就是factory.create 的callback 再callback 中执行AsyncQueue.handleResult return callback(null, createdModule); }) }) AsyncQueue.handleResult 执行了 加进异步队列的 callback 即 6.5 的回调 addModule, 此时又做了一次6.6 之后的循环 只是改成了addModule addModule 经过上面一轮 后执行 this._handleModuleBuildAndDependencies( originModule, module, recursive, callback ); 在 _handleModuleBuildAndDependencies 会执行 this.buildModule 再回调中会构建依赖","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"学习webpack源码","slug":"学习webpack源码","date":"2022-01-17T02:17:43.000Z","updated":"2023-02-14T15:19:27.738Z","comments":true,"path":"2022/01/17/学习webpack源码/","link":"","permalink":"http://yoursite.com/2022/01/17/%E5%AD%A6%E4%B9%A0webpack%E6%BA%90%E7%A0%81/","excerpt":"","text":"webpack 执行文件/bin/webpack 这个文件相对简单，其实就是判断一下webpack-cli 是否已经安装，没有安装就调用命令安装，要是已经安装则使用webpack-cli 1. 声明 webpack-cli 信息对象const cli = { name: \"webpack-cli\", package: \"webpack-cli\", binName: \"webpack-cli\", installed: isInstalled(\"webpack-cli\"), url: \"https://github.com/webpack/webpack-cli\" }; 2. 判断 webpack-cli 是否有安装, 只要判断目录下node_module 是有webpack-cli 这个文件夹即可const isInstalled = packageName => { if (process.versions.pnp) { return true; } const path = require(\"path\"); const fs = require(\"graceful-fs\"); let dir = __dirname; do { try { if (fs.statSync(path.join(dir, \"node_modules\", packageName)).isDirectory()) { return true; } } catch (_error) { // Nothing } } while (dir !== (dir = path.dirname(dir))); return false; }; 3. 判断 webpack-cli 是否有安装，如果有则调用runCli, 没有则 执行runCommandif (!cli.installed) { const path = require(\"path\"); const fs = require(\"graceful-fs\"); const readLine = require(\"readline\"); const notify = \"CLI for webpack must be installed.\\n\" + ` ${cli.name} (${cli.url})\\n`; console.error(notify); /** 判断是使用yarn 还是node 还是其他的包管理工具 */ let packageManager; if (fs.existsSync(path.resolve(process.cwd(), \"yarn.lock\"))) { packageManager = \"yarn\"; } else if (fs.existsSync(path.resolve(process.cwd(), \"pnpm-lock.yaml\"))) { packageManager = \"pnpm\"; } else { packageManager = \"npm\"; } const installOptions = [packageManager === \"yarn\" ? \"add\" : \"install\", \"-D\"]; console.error( `We will use \"${packageManager}\" to install the CLI via \"${packageManager} ${installOptions.join( \" \" )} ${cli.package}\".` ); const question = `Do you want to install 'webpack-cli' (yes/no): `; const questionInterface = readLine.createInterface({ input: process.stdin, output: process.stderr }); process.exitCode = 1; questionInterface.question(question, answer => { questionInterface.close(); /** 命令行输入y 时，安装`webpack-cli`, 否则提示需要安装webpack-cli */ const normalizedAnswer = answer.toLowerCase().startsWith(\"y\"); if (!normalizedAnswer) { console.error( \"You need to install 'webpack-cli' to use webpack via CLI.\\n\" + \"You can also install the CLI manually.\" ); return; } process.exitCode = 0; runCommand(packageManager, installOptions.concat(cli.package)) .then(() => { runCli(cli); }) .catch(error => { console.error(error); process.exitCode = 1; }); }); } else { runCli(cli); } 4. runCammand 执行命令const runCommand = (command, args) => { const cp = require(\"child_process\"); return new Promise((resolve, reject) => { const executedCommand = cp.spawn(command, args, { stdio: \"inherit\", shell: true }); executedCommand.on(\"error\", error => { reject(error); }); executedCommand.on(\"exit\", code => { if (code === 0) { resolve(); } else { reject(); } }); }); }; 5. 最后 runCli, 执行webpack-cliconst runCli = cli => { const path = require(\"path\"); /** webpack-cli, 这里require.resolve 是获取webpack-cli.package.json 的目录路径 */ const pkgPath = require.resolve(`${cli.package}/package.json`); const pkg = require(pkgPath); require(path.resolve(path.dirname(pkgPath), pkg.bin[cli.binName])); }; webpack-cli 上面所说运行webpack-cli 中的package.json 下的 bin, 即 ./bin/cli.js ./bin/cli.js 执行了 runCli() 从 ../lib/bootstrap 中加载啊 然后执行了cli = new WebpackCli(), 然后调用了cli.run() new WebpackCli() 的构造函数中使用了 commander cli.run 调用了 this.program.action 回调 调用 await loadCommandByName(commandToRun, true);,然后在调用了 makeCommand, makeCommand 调用了 loadWebpack, 并且 getBuiltInOptions 创建了webpack 的option 也就是 webpack.config.js, 最后在makeCommand 调用了command.action 触发回调，调用了await this.runWebpack(options, isWatchCommandUsed);。总结一下流程 this.program.action -&gt; loadCommandByName -&gt; makeCommad( loadWebpack, runWebpack ) runWebpack 执行了 createCompiler 然后返回 this.webpack(option) const webpack = require('webpack'); const config = require('./webpack.config'); compiler = webpack(config) compiler.run((err) => { console.log(err) }) webpack 源码主入口// webpack.js // webpack 函数简易结构 cosnt webpack = (option, callback) => { /** 先忽略掉watch */ const create = () => { let compiler = createCompiler(option); return { compiler }; } /** 判断有没有回调，最终都是返回compiler */ if (callback) { const { compiler } = create() compiler.run(() => { callback() }) return compiler } else { const { compiler } = create(); return compiler } return compiler } createCompiler// lib/webpack.js const createCompiler = rawOptions => { /** 序列化一下option */ const options = getNormalizedWebpackOptions(rawOptions); // 设置一下默认值比如context 设为当前运行目录 applyWebpackOptionsBaseDefaults(options); /** compiler 最主要的函数在于run 函数 */ const compiler = new Compiler(options.context); compiler.options = options; // 加载plugins , 先加载我们配置文件下的plugin if (Array.isArray(options.plugins)) { for (const plugin of options.plugins) { if (typeof plugin === \"function\") { plugin.call(compiler, compiler); } else { plugin.apply(compiler); } } } // 给option默认值 applyWebpackOptionsDefaults(options); /** 触发环境设置hooks */ compiler.hooks.environment.call(); compiler.hooks.afterEnvironment.call(); // 给config 的 key/value 转换成插件 plugin new WebpackOptionsApply().process(options, compiler); compiler.hooks.initialize.call(); return compiler; };","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"typecript 类型体操","slug":"typescript 类型体操","date":"2022-01-05T14:35:35.000Z","updated":"2023-02-14T15:19:27.732Z","comments":true,"path":"2022/01/05/typescript 类型体操/","link":"","permalink":"http://yoursite.com/2022/01/05/typescript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/","excerpt":"","text":"原网站 简单（easy） pick interface Todo { title: string description: string completed: boolean } type TodoPreview = MyPick&lt;Todo, 'title' | 'completed'> const todo: TodoPreview = { title: 'Clean room', completed: false, } 说明 type Pick&lt;T extends Object, K extends keyof T> = { [P in K]: T[P] } ReadOnly interface Todo { title: string description: string } const todo: MyReadonly&lt;Todo> = { title: \"Hey\", description: \"foobar\" } todo.title = \"Hello\" // Error: cannot reassign a readonly property todo.description = \"barFoo\" // Error: cannot reassign a readonly property 说明 type ReadOnly&lt;T extends Object> = { readonly [P in keyof T]: T[P] } 元组转换成对象 const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const type result = TupleToObject&lt;typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'} 说明 type TupleToObject&lt;T extends readonly string[]> = { [P in T[number]]: P } 第一个元素 type arr1 = ['a', 'b', 'c'] type arr2 = [3, 2, 1] type head1 = First&lt;arr1> // expected to be 'a' type head2 = First&lt;arr2> // expected to be 3 查看答案 type First&lt;T extends any[]> = T extends [infer Result,...infer Rest] ? Result : never; 获取元素长度 type tesla = ['tesla', 'model 3', 'model X', 'model Y'] type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT'] type teslaLength = Length&lt;tesla> // expected 4 type spaceXLength = Length&lt;spaceX> // expected 5 查看答案 type Length&lt;T extends readonly any[]> = T['length']; Exclude /** * 实现内置的Exclude &lt;T，U>类型，但不能直接使用它本身。 * 从联合类型T中排除U的类型成员，来构造一个新的类型。 */ 查看答案 type Exclude&lt;T, U> = T extends U ? never : T Awaited 假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。 比如：Promise&lt;ExampleType>，请你返回 ExampleType 类型。 查看答案 type MyAwaited&lt;T> = T extends Promise&lt;infer P> ? MyAwaited&lt;P> : T; IF 实现一个 IF 类型，它接收一个条件类型 C ，一个判断为真时的返回类型 T ，以及一个判断为假时的返回类型 F。 C 只能是 true 或者 false， T 和 F 可以是任意类型。 type A = If&lt;true, 'a', 'b'> // expected to be 'a' type B = If&lt;false, 'a', 'b'> // expected to be 'b' 查看答案 type If&lt;C extends boolean, T, F> = T extends true ? T : F; Concat 在类型系统里实现 JavaScript 内置的 Array.concat 方法，这个类型接受两个参数，返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。 type Result = Concat&lt;[1], [2]> // expected to be [1, 2] 查看答案 type Concat&lt;T extends any[], P extends any[]> = [...T, ...P] Include 在类型系统里实现 JavaScript 的 Array.includes 方法，这个类型接受两个参数，返回的类型要么是 true 要么是 false。 type isPillarMen = Includes&lt;['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'> // expected to be `false` 查看答案 type Include&lt;T extends readonly any[], P> = T extends [infer First,...infer Other] ? (Equal&lt;First,U> extends true ? true: Includes&lt;Other,U>) :false Push 在类型系统里实现通用的 Array.push 。 type Result = Push&lt;[1, 2], '3'> // [1, 2, '3'] 查看答案 type Push&lt;T extends any[], U> = [...T, U] Unshift 实现类型版本的 Array.unshift。 type Result = Unshift&lt;[1, 2], 0> // [0, 1, 2,] 查看答案 type Unshift&lt;T extends any[], U> = [U, ...T] Parameters 实现内置的 Parameters 类型，而不是直接使用它，可参考TypeScript官方文档。 查看答案 type MyParameters&lt;T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never; 中等 获取函数返回类型 ReturnType 不使用 ReturnType 实现 TypeScript 的 ReturnType&lt;T&gt; 范型。 const fn = (v: boolean) => { if (v) return 1 else return 2 } type a = MyReturnType&lt;typeof fn> // 应推导出 \"1 | 2\" 查看答案 type MyReturnType&lt;T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : never 实现 omit 不使用 Omit 实现 TypeScript 的 Omit&lt;T, K&gt; 范型。 Omit 会创建一个省略 K 中字段的 T 对象。 interface Todo { title: string description: string completed: boolean } type TodoPreview = MyOmit const todo: TodoPreview = { completed: false, } 查看答案 type MyPick&lt;T, K extends keyof T> = { [key in K]: T[key] } type MyExclude&lt;T, P> = T extends P ? never : T type MyOmit&lt;T, K extends keyof T> = MyPick&lt;T, MyExclude&lt;keyof T, K>> Readonly 2 实现一个通用MyReadonly2&lt;T, K&gt;，它带有两种类型的参数T和K。 K指定应设置为Readonly的T的属性集。如果未提供K，则应使所有属性都变为只读，就像普通的Readonly&lt;T&gt;一样。 interface Todo { title: string description: string completed: boolean } const todo: MyReadonly2&lt;Todo, 'title' | 'description'> = { title: \"Hey\", description: \"foobar\", completed: false, } todo.title = \"Hello\" // Error: cannot reassign a readonly property todo.description = \"barFoo\" // Error: cannot reassign a readonly property todo.completed = true // OK 查看答案 type MyReadonly&lt;T> = { readonly [P in keyof T]: T[P] } type MyPick&lt;T, K extends keyof T> = { [P in K]: T[P] } type MyExclude&lt;T, K> = T extends K ? never : T; type MyOmit&lt;T, K extends keyof T> = { [P in MyExclude&lt;keyof T, K>]: T[P]} type MyReadonly2&lt;T, K extends keyof T = keyof T> =MyReadonly&lt;MyPick&lt;T, K>> &amp; MyOmit&lt;T, K> 深度Readonly 实现一个通用的DeepReadonly，它将对象的每个参数及其子对象递归地设为只读。 您可以假设在此挑战中我们仅处理对象。数组，函数，类等都无需考虑。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。 type X = { x: { a: 1 b: 'hi' } y: 'hey' } type Expected = { readonly x: { readonly a: 1 readonly b: 'hi' } readonly y: 'hey' } type Todo = DeepReadonly&lt;X> // should be same as `Expected` 查看答案 type DeepReadonly&lt;T extends Object> = { readonly [P in keyof T]: keyof T[P] extends never ? T[P] : DeepReadonly&lt;T[P]> } 元组转合集 实现泛型TupleToUnion&lt;T&gt;，它覆盖元组的值与其值联合。 type Arr = ['1', '2', '3'] type Test = TupleToUnion&lt;Arr> // expected to be '1' | '2' | '3' 查看答案 type TupleToUnion&lt;T extends any[]> = T extends [infer First,...infer Other] ? First | TupleToUnion&lt;Other> : never; // 或者 type TupleToUnion&lt;T extends any[]> = T[number]; 最后一个元素 实现一个通用Last&lt;T&gt;，它接受一个数组T并返回其最后一个元素的类型。 type arr1 = ['a', 'b', 'c'] type arr2 = [3, 2, 1] type tail1 = Last&lt;arr1> // expected to be 'c' type tail2 = Last&lt;arr2> // expected to be 1 查看答案 type Last&lt;T extends any[]> = T extends [...infer K, infer Other] ? Other : never //或者 type Last&lt;T extends any[]> = T extends [any, ...infer Rest] ? T[Rest['length']] : never 出堆 实现一个通用Pop，它接受一个数组T并返回一个没有最后一个元素的数组。 type arr1 = ['a', 'b', 'c', 'd'] type arr2 = [3, 2, 1] type re1 = Pop&lt;arr1> // expected to be ['a', 'b', 'c'] type re2 = Pop&lt;arr2> // expected to be [3, 2] 查看答案 type Pop&lt;T extends any[]> = T extends [...infer K, infer Other] ? K : never promise.all const promise1 = Promise.resolve(3); const promise2 = 42; const promise3 = new Promise((resolve, reject) => { setTimeout(resolve, 100, 'foo'); }); // expected to be `Promise` const p = Promise.all([promise1, promise2, promise3] as const) // declare function PromiseAll(values: any): any 查看答案 // 跟上面awaited 相似 type MyAwaited&lt;T> = T extends Promise&lt;infer P> ? MyAwaited&lt;P> : T; /** declare 重定义function, (values: readonly [...T]) 函数参数 Promise&lt;> */ declare function PromiseAll&lt;T extends any[]>(values: readonly [...T]): Promise&lt;{ [K in keyof T]: MyAwaited&lt;T[K]> }> Type Lookup 在此挑战中，我们想通过在联合Cat | Dog中搜索公共type字段来获取相应的类型。换句话说，在以下示例中，我们期望LookUp&lt;Dog | Cat, &#39;dog&#39;&gt;获得Dog，LookUp&lt;Dog | Cat, &#39;cat&#39;&gt;获得Cat。 interface Cat { type: 'cat' breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal' } interface Dog { type: 'dog' breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer' color: 'brown' | 'white' | 'black' } type MyDog = LookUp&lt;Cat | Dog, 'dog'> // expected to be `Dog` 查看答案 type LookUP&lt;T, U> = T extends { type: string } ? (T['type'] extends U ? T : never ) : never Trim Left 实现 TrimLeft&lt;T&gt; ，它接收确定的字符串类型并返回一个新的字符串，其中新返回的字符串删除了原字符串开头的空白字符串。 type trimed = TrimLeft&lt;' Hello World '> // 应推导出 'Hello World ' 查看答案 type TrimLet&lt;T extends string> = T extends `${' '| '\\n' | '\\t'}${infer Rest}` ? TrimLeft&lt;Rest> : T; Trim type trimed = Trim&lt;' Hello World '> // expected to be 'Hello World' 查看答案 type SpaceChar = ' ' | '\\n' | '\\t' type Trim&lt;S extends string> = S extends (`${SpaceChar}${infer R}` | `${infer R}${SpaceChar}`) ? Trim&lt;R> : S Capitalize 首字母大写 type capitalized = Capitalize&lt;'hello world'> // expected to be 'Hello world' 查看答案 type Capitalize&lt;T extends string> = T extends (`${infer first}${infer R}`) ? `${Uppercase&lt;first>}${R}` : T; Replace 实现 Replace&lt;S, From, To&gt; 将字符串 S 中的第一个子字符串 From 替换为 To 。 type replaced = Replace&lt;'types are fun!', 'fun', 'awesome'> // 期望是 'types are awesome!' 查看答案 type Replace&lt;S extends string, From extends string, To extends string> = From extends '' ? S : S extends `${infer start}${From}${infer end}` ? `${start}${To}${end}` : S ReplaceAll 实现 ReplaceAll&lt;S, From, To&gt; 将一个字符串 S 中的所有子字符串 From 替换为 To。 type replaced = ReplaceAll&lt;'t y p e s', ' ', ''> // 期望是 'types' 查看答案 /** * 请注意以下两种情况 * Expect&lt;Equal&lt;ReplaceAll&lt;'foobarfoobar', 'ob', 'b'>, 'fobarfobar'>>, * Expect&lt;Equal&lt;ReplaceAll&lt;'foboorfoboar', 'bo', 'b'>, 'foborfobar'>>, */ // 错误 type ReplaceAll&lt;S extends string, From extends string, To extends string> = From extends '' ? S : S extends `${infer start}${From}${infer end}` ? ReplaceAll&lt;`${start}${To}${end}`, From, To> : S // 正确 type ReplaceAll&lt;S extends string, From extends string, To extends string> = From extends '' ? S : S extends `${infer start}${From}${infer end}` ? `${start}${To}${ReplaceAll&lt;`${end}`, From, To>}` : S 追加参数 实现一个范型 AppendArgument&lt;Fn, A&gt;，对于给定的函数类型 Fn，以及一个任意类型 A，返回一个新的函数 G。G 拥有 Fn 的所有参数并在末尾追加类型为 A 的参数。 type Fn = (a: number, b: string) => number type Result = AppendArgument&lt;Fn, boolean> // 期望是 (a: number, b: string, x: boolean) => number 查看答案 type AppendArgument&lt;Fn extends (...args: any[]) => any, T> = Fn extends ((...args: infer P) => infer R) ? (...args: [...P, T]) => R : never Permutation Implement permutation type that transforms union types into the array that includes permutations of unions. type perm = Permutation&lt;'A' | 'B' | 'C'>; // ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A'] 查看答案 type Permutation&lt;T, U = T> = [T] extends [never] ? [] : T extends U ? [T, ...Permutation&lt;Exclude&lt;U, T>>] : [] Length of string Compute the length of a string literal, which behaves like String#length. 查看答案 type StringToArr&lt;T extends String> = T extends `${infer F}${infer R}` ? [F, ...StringToArr&lt;R>] : []; type StringLength&lt;T extends String> = StringToArr&lt;T>['length'] Flatten In this challenge, you would need to write a type that takes an array and emitted the flatten array type. type flatten = Flatten&lt;[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, 5] 查看答案 type Flatten&lt;T extends any[]> = T extends [infer First, ...infer Other] ? First extends any[] ? [...Flatten&lt;First>, ...Flatten&lt;Other>] : [First, ...Flatten&lt;Other>] : [] Append to object Implement a type that adds a new field to the interface. The type takes the three arguments. The output should be an object with the new field. type Test = { id: '1' } type Result = AppendToObject&lt;Test, 'value', 4> // expected to be { id: '1', value: 4 } 查看答案 type AppendToObject&lt;T extends object, U extends string, V> = { [K in keyof T | U]: K extends keyof T ? T[K] : V } Absolute 数字绝对值 type Test = -100; type Result = Absolute&lt;Test>; // expected to be \"100\" 查看答案 type Absolute&lt;T extends number | string | bigint> = `${T}` extends `-${infer X}` ? X : `${T}` String to Union Implement the String to Union type. Type take string argument. The output should be a union of input letters type Test = '123'; type Result = StringToUnion&lt;Test>; // expected to be \"1\" | \"2\" | \"3\" 查看答案 type StringToUnion&lt;T extends string> = T extends `${infer F}${infer R}` ? F | StringToUnion&lt;R> : never Merge Merge two types into a new type. Keys of the second type overrides keys of the first type. type Foo = { a: number; b: string; }; type Bar = { b: number; c: boolean; }; type Result = Merge&lt;Foo, Bar>; // { // a: number; // b: number; // c: boolean; // } 查看答案 type Merge&lt;F, S> = {[key in keyof F | keyof S]: key extends keyof S ? S[key] : key extends keyof F ? F[key] : never}; CamelCase for-bar-baz -&gt; forBarBaz 查看答案 type Capitalize&lt;T extends string> = T extends (`${infer first}${infer R}`) ? `${Uppercase&lt;first>}${R}` : T; type CamelCase&lt;T extends string> = T extends `${infer start}-${infer end}` ? `${start}${CamelCase&lt;Capitalize&lt;end>>}` : T type Result = CamelCase&lt;'foo--bar----baz'> // \"fooBarBaz\" type CamelCase&lt;S extends string> = S extends `${infer X}-${infer Y}` ? Y extends Capitalize&lt;Y> ? `${X}-${CamelCase&lt;Y>}` : `${X}${CamelCase&lt;Capitalize&lt;Y>>}` : S ; //foo-Bar---Baz KebabCase FooBarBaz -&gt; foo-bar-baz 查看答案 type KebabCase&lt;S extends string, P extends string = \"\"> = S extends `${infer L}${infer R}` ? L extends Lowercase&lt;L> ? `${L}${KebabCase&lt;R, \"-\">}` : `${P}${Lowercase&lt;L>}${KebabCase&lt;R, \"-\">}` : S; type b = KebabCase&lt;'foo-bar'> Diff Get an Object that is the difference between O &amp; O1 type Foo = { name: string age: string } type Bar = { name: string age: string gender: number } Expect&lt;Equal&lt;Diff&lt;Foo, Bar>, { gender: number }>> 查看答案 type Diff&lt;O, O1> = { [P in (keyof O | keyof O1) as Exclude&lt;P, keyof O &amp; keyof O1>]: P extends keyof O ? O[P] : P extends keyof O1 ? O1[P] : never; }; AnyOf Implement Python liked any function in the type system. A type takes the Array and returns true if any element of the Array is true. If the Array is empty, return false. type Sample1 = AnyOf&lt;[1, \"\", false, [], {}]>; // expected to be true. type Sample2 = AnyOf&lt;[0, \"\", false, [], {}]>; // expected to be false. 查看答案 // solution 1 type False = 0 | '' | false | [] | null | undefined | Record&lt;any, never>; type AnyOf&lt;T extends readonly any[]> = T[number] extends False ? false : true; // solution 2 type False = 0 | '' | false | [] | null | undefined | Record&lt;any, never>; type AnyOf&lt;T extends readonly any[]> = T extends [infer F, ...infer R] ? F extends False ? AnyOf&lt;R> : true : false; isNever Implement a type IsNever, which takes input type T. If the type of resolves to never, return true, otherwise false. type A = IsNever&lt;never&gt; // expected to be true type B = IsNever&lt;undefined&gt; // expected to be false type C = IsNever&lt;null&gt; // expected to be false type D = IsNever&lt;[]&gt; // expected to be false type E = IsNever&lt;number&gt; // expected to be false 查看答案 type isNever&lt;T> = [T] extends [never] ? true : false isUnion Implement a type IsUnion, which takes an input type T and returns whether T resolves to a union type. type case1 = IsUnion&lt;string> // false type case2 = IsUnion&lt;string|number> // true type case3 = IsUnion&lt;[string|number]> // false 查看答案 type IsUnion&lt;T, U = T> = T extends T ? (U | T) extends (U &amp; T) ? false : true : never ReplaceKeys Implement a type ReplaceKeys, that replace keys in union types, if some type has not this key, just skip replacing, A type takes three arguments.如果 type NodeA = { type: 'A' name: string flag: number } type NodeB = { type: 'B' id: number flag: number } type NodeC = { type: 'C' name: string flag: number } type Nodes = NodeA | NodeB | NodeC type ReplacedNodes = ReplaceKeys&lt;Nodes, 'name' | 'flag', {name: number, flag: string}> // {type: 'A', name: number, flag: string} | {type: 'B', id: number, flag: string} | {type: 'C', name: number, flag: string} // would replace name from string to number, replace flag from number to string. type ReplacedNotExistKeys = ReplaceKeys&lt;Nodes, 'name', {aa: number}> // {type: 'A', name: never, flag: number} | NodeB | {type: 'C', name: never, flag: number} // would replace name to never 查看答案 type ReplaceKeys&lt;T, K, V> = { [key in keyof T]: key extends K ? key extends keyof V ? V[key] : never : T[key] } Remove Index Signature Implement RemoveIndexSignature&lt;T&gt;, exclude the index signature from object types. type Foo = { [key: string]: any; foo(): void; } type A = RemoveIndexSignature&lt;Foo> // expected { foo(): void } 查看答案 type RemoveIndexSignature&lt;T> = { [key in keyof T as string extends key ? never : key extends number ? never : key]: T[key] } Percentage Parser Implement PercentageParser. According to the /^(\\+|\\-)?(\\d*)?(\\%)?$/ regularity to match T and get three matches. The structure should be: [plus or minus, number, unit] If it is not captured, the default is an empty string. type PString1 = '' type PString2 = '+85%' type PString3 = '-85%' type PString4 = '85%' type PString5 = '85' type R1 = PercentageParser&lt;PString1> // expected ['', '', ''] type R2 = PercentageParser&lt;PString2> // expected [\"+\", \"85\", \"%\"] type R3 = PercentageParser&lt;PString3> // expected [\"-\", \"85\", \"%\"] type R4 = PercentageParser&lt;PString4> // expected [\"\", \"85\", \"%\"] type R5 = PercentageParser&lt;PString5> // expected [\"\", \"85\", \"\"] 查看答案 type PickPrefix&lt;T extends string, S extends string> = T extends `${S}${infer P}` ? T extends `${infer R}${P}` ? R : never : ''; type PickSuffix&lt;T extends string, S extends string> = T extends `${infer P}${S}` ? T extends `${P}${infer R}` ? R : never : ''; type PercentageParser&lt;T extends string> = T extends `${PickPrefix&lt;T, '+' | '-'>}${infer B}${PickSuffix&lt;T, '%'>}` ? T extends `${infer A}${B}${infer C}` ? [A, B, C] : ['', '', ''] : ['', '', '']; Drop Char Drop a specified char from a string. type Butterfly = DropChar&lt;' b u t t e r f l y ! ', ' '> // 'butterfly!' 查看答案 type DropChar&lt;S, C> = S extends `${infer X}${infer Y}` ? `${X extends C ? \"\" : X}${DropChar&lt;Y, C>}` : \"\" MinusOne Given a number (always positive) as a type. Your type should return the number decreased by one. type Zero = MinusOne&lt;1> // 0 type FiftyFour = MinusOne&lt;55> // 54 查看答案 拓展 type Pop&lt;T extends any[]> = T extends [...infer head, any] ? head : never; type MinusOne&lt;T extends number, A extends any[] = []> = A['length'] extends T ? Pop&lt;A>['length'] : MinusOne&lt;T, [...A, 0]> PickByType From T, pick a set of properties whose type are assignable to U. type OnlyBoolean = PickByType&lt;{ name: string count: number isReadonly: boolean isEnable: boolean }, boolean> // { isReadonly: boolean; isEnable: boolean; } 查看答案 type PickByType&lt;T, U> = { [key in keyof T as T[key] extends U ? key : never]: T[key] } StartsWith Implement StartsWith&lt;T, U&gt; which takes two exact string types and returns whether T starts with U type a = StartsWith&lt;'abc', 'ac'> // expected to be false type b = StartsWith&lt;'abc', 'ab'> // expected to be true type c = StartsWith&lt;'abc', 'abcd'> // expected to be false 查看答案 type StartsWith&lt;T extends string, U extends string> = T extends `${U}${infer Other}` ? true : false EndsWith Implement EndsWith&lt;T, U&gt; which takes two exact string types and returns whether T ends with U type a = EndsWith&lt;'abc', 'bc'> // expected to be true type b = EndsWith&lt;'abc', 'ab'> // expected to be false 查看答案 type EndsWith&lt;T extends string, U extends string> = T extends `${infer Other}${U}` ? true : false PartialByKeys Implement a generic PartialByKeys&lt;T, K&gt; which takes two type argument T and K. K specify the set of properties of T that should set to be optional. When K is not provided, it should make all properties optional just like the normal Partial&lt;T&gt;. interface User { name: string age: number address: string } type UserPartialName = PartialByKeys&lt;User, 'name'> // { name?:string; age:number; address:string } 查看答案 type Merge&lt;A, B> = Pick&lt;A &amp; B, keyof A | keyof B> type PartialByKeys&lt;T , K = keyof T> = Merge&lt;{[key in keyof T as key extends K ? key : never]?: T[key]}, {[key in keyof T as key extends K ? never : key]: T[key]}> RequiredByKeys Implement a generic RequiredByKeys&lt;T, K&gt; which takes two type argument T and K. K specify the set of properties of T that should set to be required. When K is not provided, it should make all properties required just like the normal Required&lt;T&gt;. interface User { name?: string age?: number address?: string } type UserPartialName = RequiredByKeys&lt;User, 'name'> // { name: string; age?: number; address?: string } 查看答案 type Merge&lt;A, B> = Pick&lt;A &amp; B, keyof A | keyof B> type IsRequire&lt;T, U> = { [key in keyof T as key extends U ? key : never]-?: T[key] } type Origin&lt;T, U> = { [key in keyof T as key extends U ? never : key]: T[key] } type RequiredByKeys&lt;T, U = keyof T> = Merge&lt;IsRequire&lt;T, U>, Origin&lt;T, U>> Mutable Implement the generic Mutable&lt;T&gt; which makes all properties in T mutable (not readonly). interface Todo { readonly title: string readonly description: string readonly completed: boolean } type MutableTodo = Mutable&lt;Todo> // { title: string; description: string; completed: boolean; } 查看答案 type Mutable&lt;T> = { -readonly [key in keyof T]: T[key] } OmitByType From T, pick a set of properties whose type are not assignable to U. type OmitBoolean = OmitByType&lt;{ name: string count: number isReadonly: boolean isEnable: boolean }, boolean> // { name: string; count: number } 查看答案 type OmitByType&lt;T, U> = { [key in keyof T as T[key] extends U ? never : key]: T[key] } ObjectEntries Implement the type version of Object.entries interface Model { name: string; age: number; locations: string[] | null; } type modelEntries = ObjectEntries&lt;Model> // ['name', string] | ['age', number] | ['locations', string[] | null]; 查看答案 type ObjectEntries&lt;T, K = keyof T> = K extends keyof T ? [K, Required&lt;T>[K]] : never; Shift Implement the type version of Array.shift type Result = Shift&lt;[3, 2, 1]> // [2, 1] 查看答案 type Shift&lt;T extends any[]> = T extends [infer First, ...infer Other] ? Other : never Tuple to Nested Object Given a tuple type T that only contains string type, and a type U, build an object recursively. type a = TupleToNestedObject&lt;['a'], string> // {a: string} type b = TupleToNestedObject&lt;['a', 'b'], number> // {a: {b: number}} type c = TupleToNestedObject&lt;[], boolean> // boolean. if the tuple is empty, just return the U type 查看答案 type TupleToNestedObject&lt;T extends any[], U> = T['length'] extends 0 ? U : T extends [infer First, ...infer Other] ? { [P in T[0]]: Other['length'] extends 0 ? U : TupleToNestedObject&lt;Other, U> } : never Reverse Implement the type version of Array.reverse type a = Reverse&lt;['a', 'b']> // ['b', 'a'] type b = Reverse&lt;['a', 'b', 'c']> // ['c', 'b', 'a'] 查看答案 type Reverse&lt;T extends any[]> = T extends [...infer Other, infer Last] ? [Last, ...Reverse&lt;Other>] : [] Flip Arguments Implement the type version of lodash’s _.flip. Type FlipArguments&lt;T&gt; requires function type T and returns a new function type which has the same return type of T but reversed parameters. type Flipped = FlipArguments&lt;(arg0: string, arg1: number, arg2: boolean) => void> // (arg0: boolean, arg1: number, arg2: string) => void 查看答案 type Reverse&lt;T extends any[]> = T extends [...infer Other, infer Last] ? [Last, ...Reverse&lt;Other>] : [] type FlipArguments&lt;T extends (...args: any[]) => any > = T extends (...args: infer P) => infer Q ? (...args: Reverse&lt;P>) => Q : never; FlattenDepth Recursively flatten array up to depth times. type a = FlattenDepth&lt;[1, 2, [3, 4], [[[5]]]], 2> // [1, 2, 3, 4, [5]]. flattern 2 times type b = FlattenDepth&lt;[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, [[5]]]. Depth defaults to be 1 查看答案 type FlattenOnce&lt;T extends unknown[]> = T extends [infer First, ...infer Rest] ? First extends unknown[] ? [...First, ...FlattenOnce&lt;Rest>] : [First, ...FlattenOnce&lt;Rest>] : []; type t1 = FlattenOnce&lt;[[2], [[3]], 4]>; type FlattenDepth&lt;T extends unknown[], N extends number = 1, C extends unknown[] = []> = C[\"length\"] extends N ? T : T extends FlattenOnce&lt;T> ? T : FlattenDepth&lt;FlattenOnce&lt;T>, N, [...C, unknown]>;","categories":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"对近期工作的一些思考","slug":"对近期工作的一些思考","date":"2021-10-07T05:32:44.000Z","updated":"2023-02-14T15:19:27.739Z","comments":true,"path":"2021/10/07/对近期工作的一些思考/","link":"","permalink":"http://yoursite.com/2021/10/07/%E5%AF%B9%E8%BF%91%E6%9C%9F%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/","excerpt":"","text":"业务工作之前要做一个类似于装修模块的东西，比如app 首页，活动页等等，如下图所示 左边是一个组件树， 中间是整个内容模块的展示， 右边是对所选中的内容进行编辑 技术栈因为之前同事是使用brick-design 做二次开发的，所以也就继续沿用了。 用lerna 去管理这些包，比如brick-design， 还有一些组件。最后build 的时候会放到私有源上 开发准备工作因为brick-design 作为工具库，所以我们要通过yarn add 的方式去安装，所以在开发时候需要使用到npm link 到brick-design 上。具体查看npm link brick-design 原理brick-design原理: 它是通过去维护整个pageConfig去实现组件自定义，pageConfig就是一个用数据结构表达的一颗树，每个节点都有一个props。 数据结构如下： const pageConfig = { \"1\": { componentName: 'Layout', title: '组件树', props: { style: { width: '100%', } }, childNodes: ['2'] }, \"2\": { componentName: 'CouponContainer', // 需要到 &lt;BrickProvider config={} /> config 需要注册该组件, 不然会找不到该组件 title: '优惠券容器', props: {}, childNodes: ['3'] }, \"3\": { componentName: 'CouponItem', title: '优惠券1', props: { name: '优惠券名', id: '优惠券id' }, } } 在用这个brick-design 的时候感觉原理上跟formily类似，pageConfig 相当于formily 的schema, 他们两同样需要对自定义的组件作注册事件组件注册 实现CouponContainer 和 CouponIteminterface Iprops { children: React.ReactNode, /** 控制显示与隐藏 */ visible: 0 | 1, /** 下面这些是brick-design 的属性，就是给这个容器在选中状态的样式等其余属性 */ className: string, onClick?: () => void, onDrag?: () => void, onDragEnd?: () => void, onDragEnter?: () => void, onDragStart?: () => void, onMouseOver?: () => void, getOperateState?: any, } const Coupon: React.FC&lt;Iprops> &amp; { Item: typeof CouponItem } = (props: Iprops) => { const { children, className, visible = true, ...other } = props; const classNameStr = cx( styles.container, className, ); const { onClick, onDrag, onDragEnd, onDragEnter, onDragStart, onMouseOver, getOperateState } = other; const divProps = { onClick, onDrag, onDragEnd, onDragEnter, onDragStart, onMouseOver, }; // 这里做个提示：使用当前props的theme 配合 React.children.map, 以及React.cloneElement 形成不一样的布局，比如商品两列布局，或者是一行一个， return ( &lt;> { !!visible &amp;&amp; ( &lt;div {...divProps} className={classNameStr}> {children} &lt;/div> ) || null } &lt;/> ); }; interface ItemIprops { id?: number name?: string, className: string, onClick: () => void, onDrag: () => void, onDragEnd: () => void, onDragEnter: () => void, onDragStart: () => void, onMouseOver: () => void, draggable?: false getOperateState: any, } const CouponItem: React.FC&lt;ItemIprops> = (props: ItemIprops) => { const { className, ...other} = props; const { onClick, onDrag, onDragEnd, onDragEnter, onDragStart, onMouseOver, getOperateState, ...rest} = other; const { id, name } = rest; const divProps = { onClick, onDrag, onDragEnd, onDragEnter, onDragStart, onMouseOver, }; const isNotNull = useMemo(() => id, [id]); return ( &lt;div className={cx(styles.item)}> &lt;div {...divProps} className={className}> &lt;CouponsItem id={id} name={name} isNull={!isNotNull} /> &lt;/div> &lt;/div> ); }; Coupon.Item = CouponItem; 迷茫与改进 一开始是跟同事一样的做法，就是先写一个 pageConfig 的一个模板，然后从后端请求接口后把当中的值一一塞进去。 在右边装修内容的时候写成了一个个单独的组件，只要一改变就会触发pageConfig, 修改当前选择的组件的props, 甚至不需要按确认按钮，这样变得非常难处理，无法做数据验证等等。 对于重复数据可继续选择问题， 即当我选择了一个id为1的优惠券时，我再新建一个子节点，我还能再继续选择这张优惠券，数据冗余。 改进 对于第一个问题，解决方案是根据后端返回的数据去构建一个pageConfig, 而不是根据模板去一一塞过去。 hooks 如下 function useGetLayout() { const { id } = usePageStatus(); const [detail, setDetail] = useState&lt;DetailType | null>(null); const [loading, setLoading] = useState&lt;boolean>(false); /** 获取布局 */ useEffect(() => { let isValid = true; if (!id) { return; } async function fetchData() { setLoading(true); const { code, data } = await Api({id: id}); if (!isValid) { return; } setLoading(false); if (code === 1000) { const isEmptyObject = Object.keys(data.adornContent).length === 0; const tempData = { ...data, adornContent: isEmptyObject ? DEFAULT_DATA : data.adornContent }; setDetail(tempData as unknown as DetailType); } } fetchData(); return () => { isValid = false; }; }, [id]); /** 根据后端返回的布局内容去构建pageConfig， 一部分代码 */ useEffect(() => { if (!detail) { return; } async function setData() { const { adornContent } = detail!; let startKey = 0; const firstChildKeys: string[] = []; let pageConfig = {}; /** 未排序数组 */ const dataSourceList: { key: keyof typeof adornContent, sort: number }[] = []; Object.keys(adornContent).map((_item: keyof typeof adornContent) => { dataSourceList.push({ key: _item, sort: adornContent[_item].sort }); }); const sortedList = dataSourceList.sort((a, b) => a.sort - b.sort); for (const _row of sortedList) { startKey = startKey + 1; firstChildKeys.push(startKey.toString()); const target = adornContent[_row.key]; const currentProps = target.props; const childrenData = currentProps.childrenData || []; const props = _row.key === 'top' ? { imageUrl: currentProps.imageUrl } : { visible: currentProps.visible || true, theme: currentProps.theme || 0, title: currentProps.title, }; const childPropsData = _row.key === 'top' ? {} : { childComponentName: `${CHILD_COMPONENT_NAME[_row.key]}`, addBtnText: '添加子节点', childProps: { otherProps: { type: `${_row.key}Item` }, }, }; let tempConfig = { componentName: COMPONENT_NAME[_row.key], title: title[_row.key] || currentProps.title, props: props, otherProps: { type: _row.key }, canDelete: false, ...childPropsData, childNodes: [], }; const childNodesKeys: string[] = []; /** * @tofix * 这里不应该这么写，但是后端的接口分了一块一块，那也没办法 * 这里应该先根据后端返回的结果先在前端处理一遍，变成 {key: [1, 2, 3]， key2: [2,3,4]} 这样的数据结构，然后请求后端接口，让后端一次返回所有数据 * 而不是一块一块的去请求借口 */ if ( childrenData.length > 0) { /** 这里用key value 的形式对应formated data ，格式化请求前的数据*/ const formatedData = formatData[_row.key]?.(childrenData); /** 这里用key value 的形式对应api */ const requestData = await service[_row.key]?.(formatedData, { ctlType: 'none' }); /** 这里用key value 的形式对应formated data ，格式化请求后的数据*/ const afterRequestFormatedData = afterRequestFormat[_row.key]?.(requestData); afterRequestFormatedData?.forEach((_item, _index) => { const keyNum = `${startKey}-${_index + 1}`; childNodesKeys.push(keyNum); const sonConfig = { componentName: `${CHILD_COMPONENT_NAME[_row.key]}`, title: _item?.productName || _item.name, props: { ..._item, }, otherProps: { type: `${_row.key}Item` }, childNodes: [] }; pageConfig[keyNum] = sonConfig; }); } tempConfig = { ...tempConfig, childNodes: childNodesKeys }; pageConfig[startKey] = tempConfig; } pageConfig = { 0: { \"componentName\": \"MallLayout\", title: '组件树', \"props\": { \"style\": { \"width\": \"100%\", } }, \"childNodes\": firstChildKeys }, ...pageConfig, }; console.log(\"pageConfig\", pageConfig); updatePageConfig(pageConfig); } setData(); }, [detail]); } 针对第二个问题，改用formily，把编辑内容变成form, 或者formily 针对第三个问题，再写一个hook，针对pageConfig发生改变时，返回已有的key:value值,根据选择组件获取对应的key.即sameKey[selectInfo.key],在table设置rowSelection 设置disabled既可, 数据接口如下： { coupon: [1, 2], hot: [251, 235], discount: [251, 235] } APP 端显示app 那边使用的是 react-native,那么写一个获取layout 布局以及 获取数据的hook, 这样做既可以把逻辑抽离，又优雅，到时候迁移到小程序上就方便多了 因为我们的数据格式是： { coupon: { sort: 1, title: '优惠券', childrenData: [ { type: 1, id: 1 }, { type: 2, id: 2 } ] }, hot: { sort: 2, title: '推荐', childrenData: [231, 255] }, discount: { sort: 3, title: '折扣', childrenData: [231, 255] }, } 先通过前端筛选数据，将空值筛选掉，然后提交给后端, 后端一样key,value 这样返回数据， // 前端提交给后端的数据格式 { coupon:[ { type: 1, id: 1 }, { type: 2, id: 2 }, ], hot: [231, 255], discount: [231, 255] } // 后端返回给前端的数据格式, 如下 { coupon:[ { type: 1, id: 1, name: '优惠券1' }, { type: 2, id: 2, name: '优惠券2' }, ], hot: [ { title: '商品1', id: 231 }, ] } 迷惑行为：不知道为什么其他同事都是一块内容一个接口，让我感觉非常迷惑。 这样导致的结果就是，一个页面n 多个接口，逻辑难以复用, 且太多if/else。 因为个人不太喜欢写if/else, 本人一般会用 Map 去代替if/else。 最后, 只要遍历activityData 并写相对应的容器组件即可，比如 Coupon, CommodityList, // activityData [ { sort: 1, name: 'coupon', dataSource: [ { type: 1, id: 1, name: '优惠券1' }, { type: 2, id: 2, name: '优惠券2' }, ] }, { sort: 2, name: 'hot', dataSource: [ { title: '商品1', id: 231 }, ] } ] &lt;ScrollView style={styles.scrollView} scrollIndicatorInsets={{ right: 1 }}> { activityData.map((_item: any, _index: number) => { const componentName = ACTIVITY_TYPE.includes(_item.name) 'commodityList' : _item.name const Component = ComponentMap[componentName]; if (!Component) { return null } // eslint-disable-next-line react/no-array-index-key return &lt;Component key={`${_item.name}-${_index}`} activityType={_item.name} {..._item} /> }) } &lt;/ScrollView>","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Antd Alert 组件","slug":"antd alert","date":"2021-09-13T14:31:00.000Z","updated":"2023-02-14T15:19:27.729Z","comments":true,"path":"2021/09/13/antd alert/","link":"","permalink":"http://yoursite.com/2021/09/13/antd%20alert/","excerpt":"","text":"Antd Alert 组件源码地址 这个组件相对简单，就是一个布局组件 传参/** 简化后的属性 **/ export interface AlertProps { type?: 'success' | 'info' | 'warning' | 'error'; message?: React.ReactNode; description?: React.ReactNode; onClose?: React.MouseEventHandler&lt;HTMLButtonElement>; afterClose?: () => void; showIcon?: boolean; icon?: React.ReactNode; } 其实也就是一个用CSSMotion 包裹住的div 组件， 里面渲染了message. description, 等 &lt;CSSMotion visible={!closed} motionName={`${prefixCls}-motion`} motionAppear={false} motionEnter={false} onLeaveStart={node => ({ maxHeight: node.offsetHeight, })} onLeaveEnd={afterClose} > {({ className: motionClassName, style: motionStyle }) => ( &lt;div ref={ref} className={classNames(alertCls, motionClassName)} style={{ ...style, ...motionStyle }} {...props} > {isShowIcon ? renderIconNode() : null} &lt;div className={`${prefixCls}-content`}> {message ? &lt;div className={`${prefixCls}-message`}>{message}&lt;/div> : null} {description ? &lt;div className={`${prefixCls}-description`}>{description}&lt;/div> : null} &lt;/div> {action ? &lt;div className={`${prefixCls}-action`}>{action}&lt;/div> : null} {renderCloseIcon()} &lt;/div> )} &lt;/CSSMotion> 值得学习的地方是，renderIconNode 函数 const renderIconNode = () => { const { icon } = props; // 这里源码中 iconMapOutlined 是一个map, 里面是一个 { [type: string]: AntdIcon } const iconType = (description ? iconMapOutlined : iconMapFilled)[type] || null; if (icon) { /** 这里replaceElement 其实源码是用 React.cloneElement 去实现的， * 就是判断icon 是否是element 不是的话就用第二参数， 是的话就克隆element，然后添加其余属性 */ return replaceElement(icon, &lt;span className={`${prefixCls}-icon`}>{icon}&lt;/span>, () => ({ className: classNames(`${prefixCls}-icon`, { [(icon as any).props.className]: (icon as any).props.className, }), })); } /** 这里如果是自己写的话, 是用一个div 去包裹着， 而不是像他那样创建一个element， 这里如果换成React.cloneElement是不是更加合适？ */ return React.createElement(iconType, { className: `${prefixCls}-icon` }); };","categories":[],"tags":[{"name":"antd","slug":"antd","permalink":"http://yoursite.com/tags/antd/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"ant Switch 组件","slug":"antd-switch","date":"2021-09-13T12:31:00.000Z","updated":"2023-02-14T15:19:27.730Z","comments":true,"path":"2021/09/13/antd-switch/","link":"","permalink":"http://yoursite.com/2021/09/13/antd-switch/","excerpt":"","text":"Antd Switch源码地址 Switch 参数很明显，Switch 的作为一个受控组件， 那么他接受的组件应该有checked, onChange 这两个属性， 查看Switch 的interface interface/** 简化后的interface */ export interface SwitchProps { /** switch 大小 */ size?: SwitchSize; /** 开关状态 */ checked?: boolean; /** 开关状态 */ defaultChecked?: boolean; /** onChange 事件 */ onChange?: (checked: boolean, event: MouseEvent) => void; checkedChildren?: React.ReactNode; unCheckedChildren?: React.ReactNode; disabled?: boolean; } antd 源码中Switch 调用的是 RcSwitch /** 简化后的代码 */ import * as React from 'react'; import RcSwitch from 'rc-switch'; const Switch = React.forwardRef&lt;unknown, SwitchProps>(props, ref) => { const { disabled, ...rest } = props; return ( &lt;RcSwitch {...props} disabled={disabled || loading} ref={ref} /> ) } RcSwitch源码地址 直接看 RcSwitch 的render 函数， 其实就是一个button 包裹着两个propsChildren const RcSwitch = () => { return ( &lt;button {...restProps} aria-checked={innerChecked} disabled={disabled} ref={ref} onClick={onInternalClick} > {loadingIcon} &lt;span className={`${prefixCls}-inner`}> {innerChecked ? checkedChildren : unCheckedChildren} &lt;/span> &lt;/button> ) } 值得学习的是，rc-switch 用一个hook 函数，将value, defaultValue, onChange 三者抽离出来，这样就可以封装一个受控组件或者是一个非受控组件了其实 useMergedState 就是 umi hook 里面的 useControllableValue const RcSwitch = () => { const [innerChecked, setInnerChecked] = useMergedState&lt;boolean>(false, { value: checked, defaultValue: defaultChecked, }); /** 就是一个onChange 函数，同时改变自身innerCheck 状态，如果props 有onChange，那么也触发父级事件 */ function triggerChange( newChecked: boolean, event: React.MouseEvent&lt;HTMLButtonElement> | React.KeyboardEvent&lt;HTMLButtonElement>, ) { let mergedChecked = innerChecked; if (!disabled) { mergedChecked = newChecked; setInnerChecked(mergedChecked); onChange?.(mergedChecked, event); } return mergedChecked; } return ( &lt;button aria-checked={innerChecked} disabled={disabled} ref={ref} onClick={(e) => triggerChange(!innerChecked, e)} > {loadingIcon} &lt;span className={`${prefixCls}-inner`}> {innerChecked ? checkedChildren : unCheckedChildren} &lt;/span> &lt;/button> ) } useMergedState 或者 useControllableValue我们直接查看useControllableValue 这个hooks 是怎么实现的源码 interface StandardProps&lt;T> { value: T; defaultValue?: T; onChange: (val: T) => void; } function useControllableValue&lt;T = any>(props: StandardProps&lt;T>): [T, (val: T) => void]; function useControllableValue&lt;T = any>( props?: Props, options?: Options&lt;T>, ): [T, (v: T, ...args: any[]) => void]; function useControllableValue&lt;T = any>(props: Props = {}, options: Options&lt;T> = {}) { /** 首先获取options 的默认参数， 一般为 value， onChange */ const { defaultValue, defaultValuePropName = 'defaultValue', valuePropName = 'value', trigger = 'onChange', } = options; /** 获取 prop['value'] 的值 */ const value = props[valuePropName] as T; /** 如果value 在 props 中， 那么我们直接用 props[value] 的值， 不然就是用默认值 */ const [state, setState] = useState&lt;T>(() => { if (valuePropName in props) { return value; } if (defaultValuePropName in props) { return props[defaultValuePropName]; } return defaultValue; }); /* init 的时候不用执行了， 当我们传入的props[value] 发生变化的时候，重新setState, 保证state 跟 props[value] 同步 */ useUpdateEffect(() => { if (valuePropName in props) { setState(value); } }, [value, valuePropName]); /** onChange 事件， 分为非受控组件，与受控组件 */ const handleSetState = useCallback( (v: T, ...args: any[]) => { /** 这里判断一下 我们用组件的时候有没有传入value, 有的话就是受控组件， 没有的话就是非受控组件，非受控组件维护内部值 */ if (!(valuePropName in props)) { setState(v); } /** 受控组件， 判断一下是否有onChange, 如果有那么就调用props.onChange */ if (props[trigger]) { props[trigger](v, ...args); } }, [props, valuePropName, trigger], ); return [valuePropName in props ? value : state, handleSetState] as const; } 这个hooks 在antd 中经常被使用到","categories":[],"tags":[{"name":"antd","slug":"antd","permalink":"http://yoursite.com/tags/antd/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"ant Modal 组件","slug":"antd Modal 组件","date":"2021-09-08T12:31:00.000Z","updated":"2023-02-14T15:19:27.729Z","comments":true,"path":"2021/09/08/antd Modal 组件/","link":"","permalink":"http://yoursite.com/2021/09/08/antd%20Modal%20%E7%BB%84%E4%BB%B6/","excerpt":"","text":"这里记录一下查看antd 组件库时学到的东西，或者是想法 源码地址 Modal其实我们可以简单想一下我们需要一个Modal 框那些属性是必要的，很容易想象的到就是visible, onCancel, onOk 这几个属性, 因为这几个属性是控制我们这个Modal 显示隐藏的 所以就有了以下下简易传值 const { toggle, setToggle } = useToggle(); &lt;Modal visible={toggle} onCancel={() => setToggle(false)} onOk={() => doSome()} > &lt;/Modal> Modal.tsx查看源码Modal.tsx, 这个组件很简单，其实就是使用了rc-component 的rc-dialog, 把我们传的visble, onCancel 等传到 Dialog 里面 import Dialog from 'rc-dialog' interface Iprop { visible: boolean, onCancel: () => void, onOk: () => void } const Modal: React.FC&lt;Iprops> = (props: Iprops) => { const { visbile, onCancel, onOk } = props; const handleCancel = () => { onCancel?.() } const handleOk = () => { onOk?.() } return ( &lt;Dialog visible={visible} onCancel={handleCancel} onOk={handleOk} > ) } 在Modal 中我们还有一些用法，比如： Modal.confirm({ title: 'hello,', content: 'world', onOk() { console.log('OK'); }, onCancel() { console.log('Cancel'); }, }); 这样子可以直接调出Modal 看看Modal.confirm 的实现源码地址 Modal.confirm它用了一个高阶函数confirm(withxxx(props)), withxxx函数就是给props 附加一个type, 即 类似Object.assign(props, { type: &#39;xxx&#39; }); Modal.info = function infoFn(props: ModalFuncProps) { return confirm(withInfo(props)); }; withInfo 函数/** withInfo 函数 */ function withInfo(props: ModalFuncProps): ModalFuncProps { return { icon: &lt;InfoCircleOutlined />, okCancel: false, ...props, type: 'info', }; } 重头戏 Confirm 函数其实就是在body 下面 创建一个节点const div = document.createElement(&#39;div&#39;); 然后将div append 到body下， 最后调用 React.render(Modal, div)将model 渲染到div上, function confirm(config: ModalFuncProps) { const div = document.createElement('div'); document.body.appendChild(div); let currentConfig = { ...config, close, visible: true } as any; /** destroy 的时候将visbile 改成false，然后如果有onCancel 就执行onCancle, 将当前div remove掉 **/ function destroy(...args: any[]) { const unmountResult = ReactDOM.unmountComponentAtNode(div); if (unmountResult &amp;&amp; div.parentNode) { div.parentNode.removeChild(div); } const triggerCancel = args.some(param => param &amp;&amp; param.triggerCancel); if (config.onCancel &amp;&amp; triggerCancel) { config.onCancel(...args); } for (let i = 0; i &lt; destroyFns.length; i++) { const fn = destroyFns[i]; if (fn === close) { destroyFns.splice(i, 1); break; } } } /** render 到div上 */ function render(props: { visible: boolean, onOk: () => void, onCancel: () => void }) { setTimeout(() => { ReactDOM.render( &lt;ConfirmDialog {...props} />, div, ); }); } /** close 的时候将visbile 改成false，然后如果有afterClose afterClose, 然后destroy掉 **/ function close(...args: any[]) { currentConfig = { ...currentConfig, visible: false, afterClose: () => { if (typeof config.afterClose === 'function') { config.afterClose(); } destroy.apply(this, args); }, }; render(currentConfig); } /** 向外暴露update 方法，可以修改props等，修改完props然后render一下 */ function update(configUpdate: ConfigUpdate) { if (typeof configUpdate === 'function') { currentConfig = configUpdate(currentConfig); } else { currentConfig = { ...currentConfig, ...configUpdate, }; } render(currentConfig); } render(currentConfig); destroyFns.push(close); /** 暴露update 和destroy 方法 */ /** 可以用 const modal = Modal.info({title: '123'}) */ /** 可以用 modal.update({title: '345'}) 去更新title*/ /** 可以用 modal.destory() 去关闭modal*/ return { destroy: close, update, }; } 注意看这个&lt;ConfirmDialog /&gt; ConfirmDialog源码 这个ConfirmDialog 里面的确认和取消 按钮都用了一个&lt;ActionButton onOk={onOk}/&gt; 其实就是一个&lt;Button /&gt; 下面只看他如何处理onOk 方法 const ActionButton = () => { const handlePromiseOnOk = (returnValueOfOnOk?: PromiseLike&lt;any>) => { const { close } = props; if (!isThenable(returnValueOfOnOk)) { return; } setLoading(true); /** promise 完成后直接close 掉 */ returnValueOfOnOk!.then( (...args: any[]) => { setLoading(false); close(...args); clickedRef.current = false; }, (e: Error) => { console.error(e); setLoading(false); clickedRef.current = false; }, ); }; const onClick = (e: React.MouseEvent&lt;HTMLButtonElement>) => { const { actionFn, close } = props; // 这里处理按钮是否被点击了，如果是, 直接return掉 if (clickedRef.current) { return; } clickedRef.current = true; /** 如果没有onOk 或者是onCancel 方法，直接调用modal.close() 方法，光比弹窗 */ if (!actionFn) { close(); return; } let returnValueOfOnOk; /** 这里我的理解是 处理是否冒泡？ */ if (props.emitEvent) { returnValueOfOnOk = actionFn(e); /** 判断是否是一个promise , 处理onOk 直接return new Promise() */ if (props.quitOnNullishReturnValue &amp;&amp; !isThenable(returnValueOfOnOk)) { clickedRef.current = false; close(e); return; } } else if (actionFn.length) { /** onOk 是否有参数 function onOk(close) 的情况， */ returnValueOfOnOk = actionFn(close); clickedRef.current = false; } else { /** 无参数 */ returnValueOfOnOk = actionFn(); if (!returnValueOfOnOk) { close(); return; } } /** 处理promise 方法 */ handlePromiseOnOk(returnValueOfOnOk); }; return ( &lt;Button OnClick={onClick}> &lt;/Button> ) }","categories":[],"tags":[{"name":"antd","slug":"antd","permalink":"http://yoursite.com/tags/antd/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"系统命令行代理","slug":"系统命令行代理","date":"2021-06-23T15:05:57.000Z","updated":"2023-02-14T15:19:27.745Z","comments":true,"path":"2021/06/23/系统命令行代理/","link":"","permalink":"http://yoursite.com/2021/06/23/%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86/","excerpt":"","text":"windows 终端代理设置cmd我的v2ray 的端口是1080是socks5, http用的是1081 #http set http_proxy=http://127.0.0.1:1081 set https_proxy=http://127.0.0.1:1081 如果是socks5 #socks5 set https_proxy=socks5://127.0.0.1:1080 set http_proxy=socks5://127.0.0.1:1080 powershell理论跟上面一样 换个地址罢了 $env:http_proxy=\"http://127.0.0.1:1080\" $env:https_proxy=\"http://127.0.0.1:1080\" git 下设置代理如果是使用socks代理：就用socks5, 如果是http,那就改成http git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' git 取消代理git config --global --unset http.proxy git config --global --unset https.proxy Mac 下设置vi ~/.zshrc复制一下内容 function proxy_on() { export no_proxy=\"localhost,127.0.0.1,localaddress,.localdomain.com\" export http_proxy=\"http://127.0.0.1:1087\" export https_proxy=$http_proxy #export all_proxy=socks5://127.0.0.1:7890 # or this line echo -e \"已开启代理\" } function proxy_off(){ unset http_proxy unset https_proxy echo -e \"已关闭代理\" } 最后运行source ~/.zshrc 使文件生效 使用只需要打开终端， 输入proxy_on即可， 验证curl cip.cc","categories":[],"tags":[{"name":"代理","slug":"代理","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2021-06-14T15:00:00.000Z","updated":"2023-02-14T15:29:45.630Z","comments":true,"path":"2021/06/14/正则表达式/","link":"","permalink":"http://yoursite.com/2021/06/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式正则表达式是描述一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 我们判断字符串是否含有子串，我们一般会用到indexOf 还有includes方法, 比如 &quot;abc&quot;.includes(&quot;ab&quot;) 或者 &quot;abc&quot;.indexOf(ab), 那么这两个有什么区别？ includes 返回的是Boolean值; 而indexOf 返回的是子串在字符串首次出现的下标，若没有出现返回-1 除了以上两种方法，我们还有正则表达式，/ab/.test(&quot;abc&quot;) 先来看几个常用特殊的字符 * 代表前面的字符0次或多次， 例子 /ac*/.test(&quot;abc&quot;) 说明 ac能匹配“a”，也能匹配“ac”以及“acc”。等价于{0,}。 + 代表前面的字符1次或多次， /ac+/.test(&quot;abc&quot;) 说明 ac+ 能匹配“ac”以及“acc”, 但不能匹配”a”, +等价于{1,}。 ? 代表前面的字符0次或1次, 例子 /ac?/.test(&quot;abc&quot;)例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。 /d 匹配数字 \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_] \\s 匹配所有空白符，包括换行 \\S 匹配非空白符，不包括换行。 [\\s\\S] 匹配所有 基础字符组 []字符组：允许匹配一组可能出现的字符。比如 [Jj], 那么既可以匹配J，也能匹配j, 例子/[Jj]ava[Ss]cript/.test(&quot;JavaScript&quot;) 区间在字符组中用-代表区间，即[0-9]表示的是[0123456789], 同理[a-z]表示的是a到z任意的数字 字符转义上面所说，[]表示字符组， 而- 表示区间连接符，那么如果要匹配[] 那么就需要使用转义符 \\， 答案 /\\[\\]/.test(&quot;[]&quot;) 取反 [^]true 取反 就是false, 在正则这里的取反是指 不会出现的字符 比如： 匹配不包含数字的字符串 /[^0-9]/.test(&quot;abc&quot;), 注意：^符号要在中括号内，不然^代表的是匹配以^后跟随的的字符开头的字符串，/^gg/.test(&quot;gg = good game&quot;), 这里表示的是以gg开头的匹配式。 这里顺带说一下 $, 表示以$前面的字符组做结尾的匹配式 /world$/.test(&quot;hello world&quot;) 不含小写字母的数据 `/[^a-z]/.test(&quot;0123123ADFADJFKL&quot;)` 重复在一个字符组后加上{N} 就可以表示在它之前的字符组出现N次。例如 /\\d{3}/ ,表示数字重复3次 假设要匹配 电话号码，那么应该怎么做， 电话号码的格式是020-12345678 匹配电话号码 `/\\d{3}-\\d{8}/` 重复区间 {M,N}可能有时候，我们不知道具体要匹配字符组要重复的次数，比如身份证有15位也有18位的。那么这时候就可以用重复区间， 语法：{M,N}，M是下界而N是上界。 练习 匹配所有的手机号 我们知道手机号必须为11位数，并符合下列几个规则： 第一位数字必须以1开头，第二位数字可以是[3,4,5,7,8]中的任意一个，后面9个数是[0-9]中的任意一个数字 匹配所有的手机号 `/1[34578]\\d{9}/` 贪婪匹配与非贪婪匹配贪婪模式：在整个表达式匹配成功的前提下，尽可能多的匹配 (*)； 非贪婪模式：在整个表达式匹配成功的前提下，尽可能少的匹配 (?)； 例子： &lt;div&gt;12312&lt;/div&gt;&lt;div&gt;hello world&lt;/div&gt; 贪婪匹配： &quot;&lt;div&gt;12312&lt;/div&gt;&lt;div&gt;hello world&lt;/div&gt;&quot;.match(/&lt;div&gt;.*&lt;/div&gt;/), 会匹配到 &lt;div&gt;12312&lt;/div&gt;&lt;div&gt;hello world&lt;/div&gt; 非贪婪匹配： &quot;&lt;div&gt;12312&lt;/div&gt;&lt;div&gt;hello world&lt;/div&gt;&quot;.match(/&lt;div&gt;.*?&lt;/div&gt;/), 会匹配到 &lt;div&gt;12312&lt;/div&gt;, 这是因为非贪婪匹配，匹配到第一个子串就结束了,不再往后匹配了 分组分组：使用的是（），分组一般用在提取匹配的字符串的子串。 举个例子： 020-12345678 这是我们的电话号码，但我想提取他的区号和真实的电话号码，那么我们只需要/(\\d{3})-(\\d{8})/即可 练习1： 如果我想要提取&lt;div&gt;hello world&lt;/div&gt; 答案 &quot;&lt;div&gt;hello world&lt;/div&gt;&quot;.match(/&lt;div&gt;(.*?)&lt;\\/div&gt;/) 比较： 1. &lt;div&gt;.*?&lt;/div&gt; 2. &lt;div&gt;(.*?)&lt;/div&gt; 练习2： 如果 我们拥有日期的格式为 2020-05-20 或者 2020 05 20 或者 2020/05/20 这样的格式，我们想要获取他的年月日 应该怎么写 答案 /(\\d{4})[\\-\\s\\/](\\d{2})[\\-\\s\\/](\\d{2})/ 测试一下 &quot;2020-05-20&quot;.match(/(\\d{4})[\\-\\s\\/](\\d{2})[\\-\\s\\/](\\d{2})/) 中间分隔符是[\\-\\s\\/], 我们换成[\\s\\S]是否也可以？ 那如果日期的格式是 2020-5-20 或者是 2021-2-2 那应该怎么改造他 答案 /(\\d{4})[-](\\d{1,2})[-](\\d{1,2})/ 非捕获分组有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。即我不要这个分组。非捕获分组： (?:表达式) 例子： 现在有 电话号码 020-12345678 或者tel:12345678, 我只要要他的电话号码，那么(?:\\d{3}|tel)[-:](\\d{8}) 分组回溯引用分组回溯引用的意思就是，我能使用之前匹配的分组, 用\\1表示第一个分组， \\2表示第二个分组，如此类推 例如，要匹配一段 HTML 代码，比如：&lt;font&gt;hello world&lt;/font&gt;，我们会写成 /&lt;\\w+&gt;.*?&lt;\\/\\w+&gt;/, 这样能匹配&lt;font&gt;hello world&lt;/font&gt;， 但是如果数据改成这样：&lt;font&gt;hello world&lt;/bar&gt;, font 和 bar 不是一对正常的标签，所以上面的表达式不太正确， 这个时候就可以使用分组回溯引用, /&lt;(\\w+)&gt;.*?&lt;\\/\\1&gt;/ 练习： 如果要匹配符合 ab ba 这种关系的单词, 应该怎么写? 匹配abba, asffs 答案 (\\w+)(\\w+)\\2\\1 正向先行断言正向先行断言：(?=表达式)，指在某个位置向右看，表示所在位置右侧必须能匹配表达式，但匹配的表达式不会出现在结果组里面 例如： 我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你 如果要取出喜欢两个字，要求这个喜欢后面有你，这个时候就要这么写：喜欢(?=你)，这就是正向先行断言。 看这段正则表达式(?=.*?[a-z])(?=.*?[A-Z]).+, 这段正则能够匹配包含至少一个大小写字母的字符串， 把正则拆开就是 (?=) 说明是后面必须是什么东西， .*? 表示 任意东西 [a-z] 表示 a-z 的小写字母 结合就是 必须包含a到z的任意字符串 练习: 密码强度验证规则如下: 至少一个大写字母 至少一个小写字母 至少一个数字 至少8个字符 答案 /(?=.*?[a-z])(?=.*?[A-Z])(?=.*?[0-9]).{8}/ 反向先行断言反向先行断言：(?!表达式)的作用是保证右边不能出现某字符。 用上面的例子就是，如果要取出喜欢两个字，要求这个喜欢后面没有你，这个时候就要这么写：喜欢(?!你)，这就是反向先行断言。 我觉得：正向先行断言跟反向先行断言基本类似，只是一个取反的操作 练习： 排除qq邮箱 答案 /@(?!qq).*/ @后面没有qq 用正向现行断言以及反向现行断言 千分位格式化数字 &quot;100000&quot;.replace(/\\B(?=(\\d{3})+(?!\\d))/g, &#39;,&#39;) 解析: /\\B(?=(\\d{3})+(?!\\d)) \\B, 首先先理解 \\b, 在字符串中 &quot;here is a word&quot;, 在这个字符串中其实用很多\\b, 就是单词与单词之间有\\b，所以如果用 /\\bhere\\b/ 可以匹配到here这个单词,但如果字符串是hereisaword, 这样就匹配不了here了，我们可以简单是想象成空格符。\\B是只非字间, 和 \\d与\\D, \\w 与 \\W 的取反关系一样 (?=(\\d{3})): 先分组，3个数字为一组，加正向先行断言也就是 必须包含3个数字为一组的字符串 + 一次或多次 (?!\\d): 反向先行断言，后面必须不能包含数字 结合就是 3个数字为一组的子串后面必须没有数字 正向后行断言先行断言和后行断言只有一个区别，即先行断言从左往右看，后行断言从右往左看。 正向后行断言：(?&lt;=表达式)，指在某个位置向左看，表示所在位置左侧必须能匹配表达式 例如：如果要取出喜欢两个字，要求喜欢的前面有我，后面有你，这个时候就要这么写：(?&lt;=我)喜欢(?=你)。 反向后行断言反向后行断言：(?&lt;!表达式)，指在某个位置向左看，表示所在位置左侧不能匹配表达式 用上面的例子就是， 我喜欢你， 喜欢前面没有我 例子： 匹配一个 $ 符号: (?&lt;!\\$)\\$[^\\$]*\\$(?!.) 解析： (?&lt;!\\$)\\$: $ 前面没有$ \\$(?!$): $ 的后面没有$ [^\\$]*: 除了$ 的任意字符 应用 日期转化, 获取年月日，时分秒 获取url中的参数 trim() 函数 模板 function getUrlParams(url) { const pattern = new RegExp(/(\\w+)=(\\w+)/, 'gi') let res = {}; str.replace(reg, (match, p1, p2) => { res[p1] = p2; return `${p1}=${p2}` }) return res; } getUrlParams(\"https://www.baidu.com?username=admin&password=88888888&code=1234\") trim() function trim(str, type: \"left\" | \"right\" | \"both\" | \"all\") { if (type === 'left') { return str.replace(/(^\\s*)/g, \"\"); } if (type === 'right') { return str.replace(/(\\s*$)/g, \"\") } if (type === 'both') { return str.replace(/(^\\s*)|(\\s*$)/g, \"\"); } return str.replace(/(\\s*)/g, \"\"); } 简易模板引擎 const data = {name: 'Bill', age: 111}; const template = ` my name is {{name}} 年龄 {{age}} ` function generate(template, mapData) { const reg = new RegExp(/\\{\\{(.*?)\\}\\}/, \"g\"); const res = template.replace(reg, (match, p1) => mapData[p1]) return res; } const a = generate(template, data); document.body.innerHTML += a …完","categories":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/categories/%E6%AD%A3%E5%88%99/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"git 操作","slug":"git","date":"2021-04-08T03:33:51.000Z","updated":"2023-02-14T15:19:27.730Z","comments":true,"path":"2021/04/08/git/","link":"","permalink":"http://yoursite.com/2021/04/08/git/","excerpt":"","text":"三大工作区 工作区：工作区可以理解成两个分区，一个是已控制的区域，另一个是新文件或文件变动区 暂存区：可以理解成 执行了git add 之后的操作 版本库：可以理解成执行了git commit 之后的操作 记录一下 git 的常用操作 简单操作 git add . git commit -m &quot;&quot; git pull git push 以上是常用操作，就不多解释了 reset 回滚git 回滚可以从3大工作区来回切换 git reset --soft 版本号 指的是从版本库回到暂存区 git reset HEAD . 表示从暂存区回到 工作区(新文件或文件变动区) git reset -mix 版本号 表示从版本号 回到工作区(新文件或文件变动区) git reset --hard 版本号 表示从版本号回到工作区（以控制的区域） 变基(rebase)简单说就是可以简化提交记录， 使用场景 合并提交记录","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"路径总和 II","slug":"路径总和-II","date":"2020-09-26T05:32:57.000Z","updated":"2023-02-14T15:19:27.746Z","comments":true,"path":"2020/09/26/路径总和-II/","link":"","permalink":"http://yoursite.com/2020/09/26/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/","excerpt":"","text":"路径总和 II 题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例给定如下二叉树，以及目标和 sum = 22 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回 [ [5,4,11,2], [5,8,4,5] ]题目分析其实这道题跟路径总和这道题很相似 其实就是将每次遍历的数放到 prefix 中，判断当前 节点是否有子节点 还有 sum - value === 0, 是的话，放入到 res 有 左节点 进入递归 有 右节点 进入递归 实现/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {number} sum * @return {number[][]} */ var pathSum = function(root, sum) { let res = []; let prefix = [] if(!root) { return res } dfs(root, sum, res, prefix); return res; }; var dfs = function(root, sum, res, prefix) { const value = root.val; const remain = sum - value; // 如果叶子节点都没有而且 sum - value == 0, 那么我们将prefix 加进数组 if(!root.left &amp;&amp; !root.right &amp;&amp; remain === 0) { res.push([...prefix, value]) return ; } // 没有子节点 且 remain !== 0 那就停止递归 if(!root.left &amp;&amp; !root.right &amp;&amp; remain !== 0) { return; } // 有左子节点 if(root.left) { dfs(root.left, remain, res, [...prefix, value]) } // 有右子节点, 进入递归 if(root.right) { dfs(root.right, remain, res, [...prefix, value]); } } 总结像这种需要保留 状态集的可以用prefix 装着，最后当符合条件的时候再 把 prefix 装到 result","categories":[],"tags":[{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"algorithm-深度搜索优先","slug":"algorithm-深度搜索优先","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E4%BC%98%E5%85%88/"}]},{"title":"面试总结","slug":"面试总结","date":"2020-09-10T10:37:32.000Z","updated":"2023-02-14T15:19:27.747Z","comments":true,"path":"2020/09/10/面试总结/","link":"","permalink":"http://yoursite.com/2020/09/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"vdom将多次dom修改的结果一次性更新到页面上，从而减少了页面的渲染次数，减少了修改dom之后的回流与重绘，提高了渲染性能VDOM的厉害之处不在于他运行有多快，而在于它在不需要人工优化的情况下，提供一个过得去的性能优化 说一说之前的面试体验吧 有一些纯属浪费时间，技术栈不太符合的也叫你过去面试，以后需要在先问技术栈再决定去不去面试，不然把自己搞的又累又浪费时间 面试本来就是双向选择，所以对面试官不要怂，说不定他比你还垃圾，毕竟面试造火箭，工作拧螺丝 经过这几轮面试， 主要可能问到的是 算法（排序， 动态规划）， react 源码（fiber, react 事件原理, 时间片（time slicing）， setState 在setTimeout 执行为什么是同步的, hook 实现原理也就是闭包， hook ref.current）(前端面试星球小程序有答案) react diff 算法 分3种，1 tree duff 2 component diff 3 element diff 网络问题 （tcp/ip, https, http1.0 与 http 1.1） tcp/ip 三次捂手， 四次挥手 https 基于ssl /tls 对称加密（简单说就是把各自秘钥传给对方），非对称加密 http1.0（一个http 请求连一个tcp, 所以时间耗在3次握手，4次回收）, http 1.1（增加 keep-alive）, http2.0 (头部压缩，二进制流，帧中有报文信息，通过排序重新组合还原报文) 的区别 nodejs (中间件) 插件 umi 底层， 约定式路由实现， dva， cli 集合 （webpack, ssr， UI库） 等等是怎么实现的 设计模式 （工厂， 单例， 观察者模式， 发布订阅） 说一说未来 针对算法 动态规划，DFS, BFS, 二分法，链表， 二叉树， react 源码，继续深入，这次要先看结构，再深入源码 vue 3.0 原理， 深入学习vue生态 （vuex, vue-router, echart） 图表实现 （canvas， three.js） nodejs 一个后端 语言 nodejs / python 书 设计模式 红宝书 图解http 学习本就是输入输出的事情， 学是输入，教别人是输出，多记录多回顾","categories":[],"tags":[]},{"title":"手写源码系列","slug":"手写源码系列","date":"2020-09-08T13:03:38.000Z","updated":"2023-02-14T15:19:27.742Z","comments":true,"path":"2020/09/08/手写源码系列/","link":"","permalink":"http://yoursite.com/2020/09/08/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/","excerpt":"","text":"防抖function debound(fn, wait) { let time; return function(...args) { if(time) { clearTimeOut(time) } time = setTimeOut(() => { fn.apply(this, args) }, wait) } } 节流节流的意思 是在单位时间内只执行一次 function throttle(fn, wait) { let time = null; return function(...args) { if(!time) { // 当前没有事件 time = setTimeOut(() => { time = null; fn.apply(this, args) }, wait) } } } promise参考链接","categories":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"webpack梳理","slug":"webpack-配置梳理","date":"2020-09-05T04:18:33.000Z","updated":"2023-02-14T15:19:27.733Z","comments":true,"path":"2020/09/05/webpack-配置梳理/","link":"","permalink":"http://yoursite.com/2020/09/05/webpack-%E9%85%8D%E7%BD%AE%E6%A2%B3%E7%90%86/","excerpt":"","text":"关于webpackwebpack 其实就是一个打包工具， 他可以把css, js, 图片等等的东西都打包成一个bundle，从entry开始递归分析他的依赖图，把应用到的每一个模块打包成一个或多个bundle webpakc 主要依赖下面几个配置 entry: 主入口文件 output: 输入文件的位置 modules: 里面配置的是loader， 我们可以想象loadder 为一名翻译官，把各种类型文件都翻译成浏览器可以识别的东西 plugins: 插件，我觉得webpack 的强大之处在于他的插件，plugin 可以针对在webpack不同的时期做不同的工作，比如CleanWebpackPlugin可以在打包之前删除清理指定目录 webpack 基础配置const path = require('path'); export default { entry: './src/index.js', // 入口文件 output: { filename: '[name].js', path: path.resolve(__dirname, 'dist'), }, resolve: { modules: ['node_modules'], // 告诉 webpack 解析模块时应该搜索的目录。 // 配置别名 alias: { '@': path.resolve(__dirname, 'src'), // 指定src的别名为 ‘@’ }, ententions: ['.js', '.css'], // 添加文件猴嘴 }, // 定义开发环境下的webpack-dev-server 其实就是动态更新 // 此时没有加载 HotModuleReplacementPlugin 的时候是通过loaction.reload（）重新加载网页的，但有个缺点就是不能记录状态 devServer：{ contentBase: path.resolve(__dirname, 'dist'), open: true, port: 8000, hot: true }, treeShaking: true, // 这里表示将没用过的代码自动删除掉 optimization：{ splitChunks: { cacheGroups: { vendor: { test: /node_modules/, priority: 1, // 数字越大，优先级越高 minChunks: 2, // 表示至少有两个js同事引用的时候，就会打包成vendor。js minSizes: 0, // 表示最小的大小 } } }, }, modules: { noParse: /jquery/, // webpack 优化， 不去递归jquery的依赖库 rules: [ { test: /\\.css$/, use: [ // 请记住loader 的运行顺序是从下到上，从右到左， // 另一种模式是内敛模式， import Styles from 'style-loader!css-loader?module!./styles.css', 忠中模式通过 ! 分割loadder， // 'style-loader!css-loader?module!./styles.css'.split(\"!\") => [\"style-loader\", \"css-loader\"] { loader: 'style-loader' }, { loader: 'css-loader', options: { modules: true } } ] }, { test: /\\.js$/, exclude: /(node_modules|bower_components)/, // 如果使用happypack的话，多线程打包，此时下面就要修改该成 // use: 'Happypack/loader?id=js' use: { loader: 'babel-loader', option: { cacheDirectory: true, // 开启js 打包优化 presets: ['@babel/preset-env', '@babel/preset-react'], plugins: [require('@babel/plugin-transform-object-rest-spread')] }, } } ] }, mode: 'development', // 指定环境， plugins: [ // 编译的时候指定全局变量，我们可以根据这个去定义当前环境是开发环境还是线上环境，定义不通的行为，比如url new webpack.DefinePlugin({ PRODUCTION: JSON.stringify(true), // 此时传过去的 PRODUCTION 是 字符串 “true” VERSION: JSON.stringify(\"5fa3b9\"), // }), // 多线程打包, 要是对css也启动多线程的话，再创建一个happypack， id为css new Happypack({ id: 'js', use: [{ loader: 'babel-loader', option: { cacheDirectory: true, // 开启js 打包优化 presets: ['@babel/preset-env', '@babel/preset-react'], plugins: [require('@babel/plugin-transform-object-rest-spread')] }, }] }), // ignorePlugin， 针对某个包的依赖不进行打包，比如moment， locale 是moment的语言包，要是我们只使用zh-cn 那么我们可以忽略掉其他，所以此时忽略掉locale new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/), // 下面是热更新 new webpack.NamedModulesPlugin(), // 告诉webpack 哪个模块更新了 new webpack.HotModuleReplacementPlugin(); // 进行热更新 ] } 热更新import test from './test'; if(module.hot) { module.hot.accept('./test', () => { console.log('文件已更新'); require('./test'); }) } 我们总结一下上面关于打包优化的几种方式吧 配置resolve 减少目录的搜索路径 同样的在loader 中设置 include 和 exclude 指定loader 编译的目录 设置modules 下的 noParse属性， 这个可以在打包的时候不检查某js 的依赖，这样就可以减少打包时间了 配置DllPlugin 用动态链接库的形式打包，这样的话会根据目录下的manifest.json 进行二次打包， 二次打包不会再对已生成的动态链接库进行打包 使用happyPack 用多线程打包 tapablewebpack 本质上是一种事件流机制，它的工作流程就是把各个插件串联起来， 他的核心就是tapable, tapable 有点像nodejs 的event库， 就是观察者模式 先来看看一个简单的events 库 class EventBus { constructor() { this.maps = {} } on(name, fn) { this.maps[name] = fn; } fire(name, data) { this.maps[name] &amp;&amp; this.maps[name](data); } } // 测试 const eventBus = new EventBus(); eventBus.on(\"click\", (data) => { console.log(\"click\", data) }) eventBus.fire(\"click\", {a: 1, b: 2}) 简单的观察者模式发布订阅其实很简单， 我可以想象成天文台， 当温度改变时， 天文台的数据改变（changes）的时候，我们用户需要做什么，他下雨了，我们需要收衣服， 被观察者是 天文台， 观察者 是我们用户， 具体做法是我们要收衣服， 就是对应下面的update， 简单说就是具体的做法就是观察者了 class Subject { constructor() { this.watchers = [] } addWatch(watcher) { console.log(this.watcher) this.watchers.push(watcher) } removeWatcher(watcher) { let index = this.watchers.indexOf(watcher); if(index > -1) { this.watchers.splice(index, 1) } } notify() { this.watchers.forEach((watcher) => watcher.update()) } } class Watcher { subscribeTo(subject) { subject.addWatch(this); } update() {} } let subject = new Subject() let watcher = new Watcher() watcher.update = function() { console.log('observer update') } watcher.subscribeTo(subject) //观察者订阅主题 let watcher2 = new Watcher() watcher2.update = function() { console.log('我是另一个观察者，我要做其他事情') } watcher2.subscribeTo(subject) subject.notify() 实现 SyncHook我们以上面的例子，实现一个SyncHook class SyncHook { constructor(args) { this.tasks = [] } // 绑定时间 tap(name, fn) { this.tasks.push(fn) } // 运行函数, 在tapabel call(...args) { this.tasks.forEach((task) => task(...args)); } } let hook = new SyncHook(['name']) // ['name'] 指的是我在创建hook的时候， 我tap需要传递的参数 hook.tap(\"test\", (name) => { console.log('test', name) }) hook.tap(\"test2\", (name) => { console.log(\"test2\", name) }) hook.call(\"hello\"); // 这里的hello 对应的是上面的name webpack 原理webapck其实就是自己实现了一个require方法，这里需要对AST进行一部分的了解， AST就是抽象语法树， 简单说就是将 js 转换成 语法树，转换成 方法， 变量等等的属性 我们看看AST 的步骤 AST 将 js 转换成 语法树 修改语法树的值 将 AST 转换成浏览器可以识别的 语法 AST 依赖包 babylon 将 源码 解析成 AST(抽象语法树) @babel/traverse 遍历 AST 中的节点 @babel/types 替换 AST 节点 @babel/generator 将替换的结果生成成js 我们想想webpack 的运行过程， 我们首先配置 webpack.config.js， 然后运行的是 webpack --config webpack.config.js 然后webpack 会根据 entry入口文件进行分析，对它进行AST解析， 如果entry入口文件还有require, 那么继续进行依赖遍历。 loader其实loader 就是一个方法，我们看两个例子, 一个是less-loader, 另一个是style-loader其中 loader-utils 获取loader 的参数就是 loader 的 options less-loader// less-loader /** * 我们less-loader 当然要转换成css，那么我们使用的是less.render * 下面使用less那么肯定需要 npm install less -=save-dev * @param {string} source 这里的source就是指 less源码 */ const loaderUtils = require('loader-utils'); function loader(source) { let css = \"\"; // loaderUtils.getOption(this) 可以拿到他的参数 less.render(source, (err, lessSource) => { css = lessSource.css }) return css; } style-loader/** * 我们style-loader 的作用是将css 写在html 的head 下面的style标签下 */ function loader(source) { let styles = ` const el = document.createElement(\"style\"); const css = ${source.replace(/\\s*/g, \"\")} el.innerHTML = css; document.head.appendChild(css); ` return styles } pluginwebpack 是基于tapable事件流， 你把 plugin 想象成在webapck 中不同的生命周期做不同的事情，我们看看webpack 的hooks吧 entryOption 入口hooks compile 编译时期 afterCompile 完成编译后 afterPlugins 插件完成编译后 run 运行 emit 生成编译文件时 done 执行完成 自定义pluginclass Plugin() { apply(compiler) { // 此时的compiler 是webpack实例 compiler.hooks.done.tap(\"run\", () => { console.log(\"此时是webpack 运行时运行的时间\") }) compiler.hooks.done.tap(\"name\", () => { console.log(\"此时是注册事件，指的是在整个wepack执行完成之后的回调函数\") }) } }","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"841. 钥匙和房间","slug":"841-钥匙和房间","date":"2020-08-31T07:32:23.000Z","updated":"2023-02-14T15:19:27.727Z","comments":true,"path":"2020/08/31/841-钥匙和房间/","link":"","permalink":"http://yoursite.com/2020/08/31/841-%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/","excerpt":"","text":"841. 钥匙和房间 题目描述简单说： 就是给定一个二维数组rooms， rooms[i] 代表的是房间，房间内有n把钥匙 rooms[i][j], 获得所有房间内的钥匙后能不能把房间都打开 示例1输入: [[1],[2],[3],[]] 输出: true 解释: 我们从 0 号房间开始，拿到钥匙 1。 之后我们去 1 号房间，拿到钥匙 2。 然后我们去 2 号房间，拿到钥匙 3。 最后我们去了 3 号房间。 由于我们能够进入每个房间，我们返回 true。 示例2输入：[[1,3],[3,0,1],[2],[0]] 输出：false 解释：我们不能进入 2 号房间。 分析方法一直接暴力破解， 就是遍历数组，把数组中的值放到 Set 里面，然后最后遍历一次状态数组即可 方法二用递归 建立状态机。 建立递归函数 当 当前房间的状态为 true 的时候，那么 表示这个房间已经进来过了，所以不用再继续遍历了 当 当前房间的状态为 false的时候，那么表示当前房间没去过，把当前房间设置为true, 然后遍历当前房间的钥匙，继续递归 最后，遍历上面的状态机，如果有一个为false, 那么返回false，只有全部为true才返回false 代码/** * @param {number[][]} rooms * @return {boolean} */ var canVisitAllRooms = function(rooms) { let length = rooms.length; let result = Array(length).fill(false); setStatus(result, rooms, 0); for(let i = 0; i &lt; result.length; i++) { if(!result[i]) { return false } } return true }; var setStatus = function(result, rooms, roomId) { if(result[roomId]) { return ; } const roomData = rooms[roomId]; result[roomId] = true for(let i = 0; i &lt; roomData.length; i++) { setStatus(result, rooms, roomData[i]) } }","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-深度遍历搜索","slug":"algorithm-深度遍历搜索","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2/"}]},{"title":"对antd-pro一些理解","slug":"对antd-pro一些理解","date":"2020-08-26T08:27:19.000Z","updated":"2023-02-14T15:19:27.739Z","comments":true,"path":"2020/08/26/对antd-pro一些理解/","link":"","permalink":"http://yoursite.com/2020/08/26/%E5%AF%B9antd-pro%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","excerpt":"","text":"umi文档 执行 npm create umi 创建 antd-pro 项目 路由整个 umi 建立的项目可以自定义路由，也可以约定式路由，我就直接对自定义路由展开配置可以写在 config/config.ts 下或者写在根目录下 .umirc.ts 的routes中 { path: '/', component: '../layouts/BlankLayout', routes: [ { path: '/', component: '../layouts/UserLayout', Routes: ['src/pages/Authorized'], authority: ['admin', 'user'], // 权限角色 routes: [ { name: '/test', icon: 'smile', path: '/test', component: './test', }, { name: '/test2', authority: ['admin', 'user'], // 权限角色 routes: [ { name: '', icon: 'smile', path: '/test2/step1' } ] } ], } } 侧边栏/导航栏注意：我们暂时不对它内置路由到底是怎么实现的，但我想的其原理就是对react-router进行配置吧 路由设置完之后对导航栏进行配置, 文档 另外umi文档中的插件 也是可以进行导航栏的废纸的 @ant-design/pro-layout文档 &lt;ProLayout // 这里的route是在上面配置自动获取的，不配置那么就不会显示在导航栏中 route={props.route} > &lt;/ProLayout> 权限说一下antd-pro的权限, 我们可以看到 utils/authority.ts, 作用是获取/设置localstorage中的用户角色，然后通过路由中的 Route跟authority 判断其是否有准入条件。 v4.1.0貌似有bug，不会经过pages/Authority.tsx判断权限 先通过 pages/Authority.tsx 文件判断用户登录以及权限路由 用户已登录， 获取当前location.pathname在路由表中的权限，一直向上找，跟localstorage获取的权限判断，没权限 跳转到 403 用户没登录，跳转登录页 然后再经过路由下的 Component, 或者说是他的Children 查看封装的 组件项目多次使用该组件， 使用方法如下： const notMatch = ( &lt;div>not Match&lt;/div> ) /** * @param {string | string[] | Promise&lt;boolean>} authority * @param { React.ReactNode } notMatch * */ &lt;Authorized authority={authorized!.authority} noMatch={noMatch}> {children} &lt;/Authorized> Authorized 实现// 此时的 RenderAuthorize 来自 src/Authorithy/index // 重新包装了一下Authority，使得 currentAuthority = ['admin', 'user'] 在整个周期都能使用 // getAuthority 就是获取当前权限 let Authorized = RenderAuthorize(getAuthority()); // 此时还是从新包装了一下Authorited RenderAuthorize const RenderAuthorize = renderAuthorize(Authorized); 返回闭包，同时导出CURRENT, 当前current 也就是 getAuthority()的值， 也可以理解成一个HOC吧 /** * use authority or getAuthority * @param {string|()=>String} currentAuthority */ function renderAuthorize(Authorized) { return function (currentAuthority) { if (currentAuthority) { if (typeof currentAuthority === 'function') { CURRENT = currentAuthority(); } if (Object.prototype.toString.call(currentAuthority) === '[object String]' || Array.isArray(currentAuthority)) { CURRENT = currentAuthority; } } else { CURRENT = 'NULL'; } return Authorized; }; } export { CURRENT } export default (Authorized) => renderAuthorize(Authorized); 这个组件逻辑很简单， 需要看check函数，传入的authority 是 [‘admin’] 为例子如果通过check 那么返回children, 否则返回 &lt;notMatch&gt; const Authorized: React.FunctionComponent&lt;AuthorizedProps> = ({ children, authority, noMatch = ( &lt;Result status=\"403\" title=\"403\" subTitle=\"Sorry, you are not authorized to access this page.\" /> ), }) => { const childrenRender: React.ReactNode = typeof children === 'undefined' ? null : children; // const dom = check(authority, childrenRender, noMatch); return &lt;>{dom}&lt;/>; }; 在来看看check函数 下面的CURRENT 就是上面的renderAuthorize 导出的CURRENT /** * @param {string| stirng[]} authority 这里的authority 就是 ['admin'], 也就是准入条件 * @param { React.ReactNode } target 也就是 children * @param { React.ReactNode } Exception notMatch */ function check&lt;T, K>(authority: IAuthorityType, target: T, Exception: K): T | K | React.ReactNode { return checkPermissions&lt;T, K>(authority, CURRENT, target, Exception); } 再来看看 checkPermissions 如果准入权限为空，那么直接渲染target 要是authority跟currentAuthority都是数组的时候，那看看有没有交集有交集那就返回target 要是authority为字符串，那么看看我们的current中有没有这个权限就可以了 要是authority为promise那么就进入promise的操作 要是authority为方法，那就执行一下， 参数为current /** * 通用权限检查方法 * Common check permissions method * @param { 权限判定 | Permission judgment } authority * @param { 你的权限 | Your permission description } currentAuthority * @param { 通过的组件 | Passing components } target * @param { 未通过的组件 | no pass components } Exception */ const checkPermissions = &lt;T, K>( authority: IAuthorityType, currentAuthority: string | string[], target: T, Exception: K, ): T | K | React.ReactNode => { // 没有判定权限.默认查看所有 // Retirement authority, return target; if (!authority) { return target; } // 数组处理 if (Array.isArray(authority)) { if (Array.isArray(currentAuthority)) { if (currentAuthority.some((item) => authority.includes(item))) { return target; } } else if (authority.includes(currentAuthority)) { return target; } return Exception; } // string 处理 if (typeof authority === 'string') { if (Array.isArray(currentAuthority)) { if (currentAuthority.some((item) => authority === item)) { return target; } } else if (authority === currentAuthority) { return target; } return Exception; } // Promise 处理 if (authority instanceof Promise) { return &lt;PromiseRender&lt;T, K> ok={target} error={Exception} promise={authority} />; } // Function 处理 if (typeof authority === 'function') { const bool = authority(currentAuthority); // 函数执行后返回值是 Promise if (bool instanceof Promise) { return &lt;PromiseRender&lt;T, K> ok={target} error={Exception} promise={bool} />; } if (bool) { return target; } return Exception; } throw new Error('unsupported parameters'); }; 登录组件pages/user/login 查看 index.tsx Login页面有一个 包裹着两个 &lt;Tab&gt;, &lt;Tab&gt;下面又是一下Input组件，只是被重新包装了 // 我们可以看出 UserName, Password 等等都是LoginForm导出的 const { Tab, UserName, Password, Mobile, Captcha, Submit } = LoginForm; 我们看下 Login 这个页面的大体结构 用一个&lt;LoginForm /&gt; 包裹着两个&lt;Tab&gt;, &lt;Tab&gt; 底下是登录按钮还有其他的登录方式 其中一个&lt;Tab&gt;对应的是账号密码登录， 另一个是短信验证码登录 下面的status, loginType 是 redux的状态，表示登录失败后会有报错信息 &lt;LoginForm&gt; 的 activeKey 只有两个 account, mobile 代表账号登录跟短信登录 &lt;LoginForm activeKey={type} onTabChange={setType} onSubmit={handleSubmit}> &lt;Tab key=\"account\" tab=\"账户密码登录\"> {status === 'error' &amp;&amp; loginType === 'account' &amp;&amp; !submitting &amp;&amp; ( &lt;LoginMessage content=\"账户或密码错误（admin/ant.design）\" /> )} &lt;UserName/> &lt;Password/> &lt;/Tab> &lt;Tab key=\"mobile\" tab=\"手机号登录\"> {status === 'error' &amp;&amp; loginType === 'mobile' &amp;&amp; !submitting &amp;&amp; ( &lt;LoginMessage content=\"验证码错误\" /> )} &lt;Mobile/> &lt;Captcha/> &lt;/Tab> &lt;div> &lt;Checkbox checked={autoLogin} onChange={(e) => setAutoLogin(e.target.checked)}> 自动登录 &lt;/Checkbox> &lt;a>忘记密码&lt;/a> &lt;/div> &lt;Submit loading={submitting}>登录&lt;/Submit> &lt;div className={styles.other}> 其他登录方式 &lt;AlipayCircleOutlined className={styles.icon} /> &lt;TaobaoCircleOutlined className={styles.icon} /> &lt;WeiboCircleOutlined className={styles.icon} /> &lt;Link className={styles.register} to=\"/user/register\"> 注册账户 &lt;/Link> &lt;/div> &lt;/LoginForm> 首先先创建一个 Context， 这个context 主要是给 &lt;LoginTab&gt; 使用的 LoginTab 实现简单看就是 // antd 官网 &lt;Tabs defaultActiveKey=\"1\" onChange={callback}> &lt;TabPane tab=\"Tab 1\" key=\"1\"> Content of Tab Pane 1 &lt;/TabPane> &lt;TabPane tab=\"Tab 2\" key=\"2\"> Content of Tab Pane 2 &lt;/TabPane> &lt;TabPane tab=\"Tab 3\" key=\"3\"> Content of Tab Pane 3 &lt;/TabPane> &lt;/Tabs> const LoginTab: React.FC&lt;LoginTabProps> = (props) => { useEffect(() => { const uniqueId = generateId('login-tab-'); //治理生成唯一的tab id const { tabUtil } = props; if (tabUtil) { tabUtil.addTab(uniqueId); } }, []); const { children } = props; return &lt;TabPane {...props}>{props.active &amp;&amp; children}&lt;/TabPane>; }; const WrapContext: React.FC&lt;TabPaneProps> &amp; { typeName: string; } = (props) => ( &lt;LoginContext.Consumer> {(value) => &lt;LoginTab tabUtil={value.tabUtil} {...props} />} &lt;/LoginContext.Consumer> ); 我们看看provider 的用法 // 此时这里用上了hook然后加载的时候会加载一个tab，当切换的时候会添加另一个tab const [tabs, setTabs] = useState&lt;string[]>([]); // 这个active貌似没什么用 const [active, setActive] = useState({}); // 此时声明当前的tab是哪一个 是 account 还是 mobile const [type, setType] = useMergeValue('', { value: props.activeKey, onChange: props.onTabChange, }); &lt;LoginContext.Provider value={{ tabUtil: { addTab: (id) => { setTabs([...tabs, id]); }, removeTab: (id) => { setTabs(tabs.filter((currentId) => currentId !== id)); }, }, updateActive: (activeItem) => { if (!active) return; if (active[type]) { active[type].push(activeItem); } else { active[type] = [activeItem]; } setActive(active); }, }} > &lt;LoginContext.Provider>","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"antd","slug":"react/antd","permalink":"http://yoursite.com/categories/react/antd/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"antd","slug":"antd","permalink":"http://yoursite.com/tags/antd/"}]},{"title":"电话号码的字母组合","slug":"电话号码的字母组合","date":"2020-08-26T05:32:44.000Z","updated":"2023-02-14T15:19:27.743Z","comments":true,"path":"2020/08/26/电话号码的字母组合/","link":"","permalink":"http://yoursite.com/2020/08/26/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","excerpt":"","text":"电话号码的字母组合 题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例输入：\"23\" 输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. 思路 将 数字跟字母 建立映射关系 {2: &#39;abc&#39;}, 数字的长度，就是遍历的深度，递归时，深度减一，当深度为0的时候，停止递归，返回结果，当深度为1的时候，添加到结果 当需要继续递归的时候，保留之前的结果，此结果为了下一次遍历字母的时候，为每一个结果都要添加新的字符 以 &quot;23&quot; 为例子， 转换字母 array = [&#39;abc&#39;, &#39;def&#39;] prefix = [], result = [], 我们循环 array, 每次抽出 array[0], 对array[0]进行遍历 当 prefix 里面没东西的时候，我们直接将 array[0]的值丢进去， 此时 prefix = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 进入下一次递归 继续上面的操作， 此时我们的 array = [&#39;def&#39;], 抽array[0], 对他进行遍历，prefix = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], result = [], dept = 1 现在要对 def 遍历，跟 prefix 组合成 [&#39;ad&#39;, &#39;bd&#39;, &#39;cd&#39;, &#39;ae&#39;, &#39;be&#39;, &#39;ce&#39;, &#39;af&#39;, &#39;bf&#39;, &#39;cf&#39;], 此时dept = 1 可以将结果放到 result了，继续递归 此时dept = 0 退出递归 代码var letterCombinations = function(digits) { let length = digits.length; let result = []; let string = []; let map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz', } for(let i = 0; i &lt; length; i++) { string.push(map[digits[i]]) } contribute(result, string, [], length); return result; }; var contribute = function(result, array, prefix, dept) { if(dept == 0) { return prefix } let current = array[0]; let temp = [] let prefixLength = prefix.length; // current = \"def\"; prefix = [a, b, c] for(let i = 0; i &lt; current.length; i++) { if(prefixLength == 0) { temp.push(current[i]); if(dept == 1) { result.push(current[i]); } continue; } for(let j = 0; j &lt; prefixLength; j++) { let s = prefix[j] + current[i]; temp.push(s); if(dept == 1) { result.push(s); } } } contribute(result, array.slice(1), temp, --dept) }","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-深度遍历搜索","slug":"algorithm-深度遍历搜索","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2/"},{"name":"algorithm-全排列","slug":"algorithm-全排列","permalink":"http://yoursite.com/tags/algorithm-%E5%85%A8%E6%8E%92%E5%88%97/"}]},{"title":"奇偶链表","slug":"奇偶链表","date":"2020-08-25T10:21:04.000Z","updated":"2023-02-14T15:19:27.735Z","comments":true,"path":"2020/08/25/奇偶链表/","link":"","permalink":"http://yoursite.com/2020/08/25/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/","excerpt":"","text":"奇偶链表 题目描述给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例输入: 1->2->3->4->5->NULL 输出: 1->3->5->2->4->NULL 分析 先建立 odd 和 even 指针，分别指向的是奇链表, 偶链表 建立 p 和 q, 指向 odd 和 even 遍历 head 链表，odd.next 指向 head, even.next = head.next, 就是说一次遍历直接跳两个元素 修改 head 指向 head = head.next.next, 但此时需要判断 head.next是否为null 修改 odd 和 even, odd = odd.next; even = even.next; 最后修改 odd.next 指向 even 的开头即可 题解/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var oddEvenList = function(head) { let odd = new ListNode(\"head\", null); let even = new ListNode(\"head\", null); let p = odd; let q = even; while(head) { odd.next = head; even.next = head.next ? head.next : null head = head.next &amp;&amp; head.next.next ? head.next.next : null; odd = odd.next; even = even.next; } odd.next = q.next; return p.next; };","categories":[],"tags":[{"name":"algorithm-链表","slug":"algorithm-链表","permalink":"http://yoursite.com/tags/algorithm-%E9%93%BE%E8%A1%A8/"}]},{"title":"递增子序列","slug":"递增子序列","date":"2020-08-25T03:43:05.000Z","updated":"2023-02-14T15:19:27.746Z","comments":true,"path":"2020/08/25/递增子序列/","link":"","permalink":"http://yoursite.com/2020/08/25/%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"递增子序列 题目描述给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。 示例1输入: [4, 6, 7, 7] 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] 示例2输入: [4, 3, 2, 1] 输出: [] 题目分析我们以[4, 6, 7, 7]为例子 一开始我们的数组为array = [4,6,7,7], 结果集为result = [], 暂存结果集为 prefix = [], 遍历数组 遍历开始，值为4, 放入暂存结果集，此时prefix = [4], 我们暂时不考虑顺序和是否重复，把剩下的数组继续递归遍历 此时 array = [6, 7, 7], 把 6 取出来，prefix = [4, 6], 此时 prefix 的长度 &gt;= 2 放入 result，此时 result = [[4, 6]], 把剩下的[7,7]继续递归，回溯之后这层可以整 result = [[4,6],[4,7],[4,7]]， 不过这是回溯之后的结果 此时 array = [7, 7], prefix = [4, 6], reuslt = [[4, 6]]; 执行操作像上面一步 实现代码/** * @param {number[]} nums * @return {number[][]} */ var findSubsequences = function(nums) { let result = []; contribute(result, nums, []) return result }; var contribute = function(result, array, prefix) { let length = array.length; if(length == 0) { return result; } let isInlcude = []; for(let i = 0; i &lt; length; i++) { if(isInlcude.includes(array[i])) { // 去重 continue; } const last = prefix.length > 0 ? prefix[prefix.length - 1] : null; // 如果prefix 的最后一个数 比当前数要大，那就不符合，例如 prefix = [4, 5]; 此时last 应该是5，array[i] = 1, 5>1不符合题意 if(last !== null &amp;&amp; last > array[i]) { continue; } const temp = prefix.concat(array[i]); isInlcude.push(array[i]) if(temp.length > 1) { result.push(temp); } contribute(result, array.slice(i + 1, array.length), temp); } return result }","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-深度遍历搜索","slug":"algorithm-深度遍历搜索","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2/"},{"name":"algorithm-全排列","slug":"algorithm-全排列","permalink":"http://yoursite.com/tags/algorithm-%E5%85%A8%E6%8E%92%E5%88%97/"}]},{"title":"回文子串","slug":"回文子串","date":"2020-08-19T06:10:49.000Z","updated":"2023-02-14T15:19:27.735Z","comments":true,"path":"2020/08/19/回文子串/","link":"","permalink":"http://yoursite.com/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"回文子串 题目描述给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例示例1 输入：\"abc\" 输出：3 解释：三个回文子串: \"a\", \"b\", \"c\" 示例2 输入：\"aaa\" 输出：6 解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\" 解决思路方法1 暴力破解我们用ababa做例子, 对字符串做遍历，i 表示字符串的第n个数 i = 0, 字符 a, 判断一下是否是回文，是的话count + 1。 此时我们保留上一次的字符[&#39;a&#39;] i = 1, 字符 b, 此时我们对上一次字符数组的所有子串都添加b, 注意这里也要加上自身b, 也就是 [&#39;b&#39;, &#39;ab&#39;] 去判断一下是否是回文，此时再将上面数组保留下来。 i = 2, 字符 c, 我们继续做上面的操作, 先记录自身c, 再对上面保留下来的字符做c字符添加，也就是 [&#39;c&#39;, &#39;bc&#39;, &#39;abc&#39;], 对数组做回文判断，如此类推 我们总结一下，看下每次操作的数组 [&#39;a&#39;] [&#39;b&#39;, &#39;ab&#39;] [&#39;c&#39;, &#39;bc&#39;, &#39;abc&#39;] [&#39;b&#39;, &#39;cb&#39;, &#39;bcb&#39;, &#39;abcb&#39;], [&#39;a&#39;, &#39;ba&#39;, &#39;cba&#39;, &#39;bcba&#39;, &#39;abcb&#39;] // 完整代码 /** * @param {string} s * @return {number} */ var countSubstrings = function(s) { let count = 0; let length = s.length; if(length === 0) { return count } let prev = [s[0]]; count = 1; for(let i = 1; i &lt; length; i++) { let current = [s[i]]; count++; for(let j = 0; j &lt; prev.length; j++) { let temp = prev[j] + s[i]; if(ishuiwen(temp)) { count++; } current.push(temp); } prev = current; } return count; }; var ishuiwen = function(s) { let start = 0; let end = s.length - 1; while(start &lt; end) { let ss = s[start]; let es = s[end]; if(ss !== es) { return false } start++; end-- } return true } 方法二 动态规划题解 上面 s[i][j] 指的是 s[i:j] 的子串, 比如 i = 1, j = 3, 以ababa 例子, s[i:j] =&gt; s[1:3] 就是字符串中的bab","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"有序链表转换二叉搜索树","slug":"有序链表转换二叉搜索树","date":"2020-08-18T02:38:08.000Z","updated":"2023-02-14T15:19:27.743Z","comments":true,"path":"2020/08/18/有序链表转换二叉搜索树/","link":"","permalink":"http://yoursite.com/2020/08/18/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"有序链表转换二叉搜索树 这道题跟将有序数组转换为二叉搜索树有点相似 题目描述给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 示例1给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 分析 先把链表遍历出来，然后进行下面的操作 具体分析可以看 代码/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {ListNode} head * @return {TreeNode} */ var sortedListToBST = function(head) { let array = getSortedList(head); let res = toBST(array); return res; }; var getSortedList = function(head) { let result = []; let p = head; while(p != null) { result.push(p.val); p = p.next; } return result; } var toBST = function(array) { let length = array.length; if(length == 0) { return null } let mid = Math.floor(length / 2); let left = array.slice(0, mid); let right = array.slice(mid + 1, length); let root = new TreeNode(array[mid]); root.left = toBST(left); root.right = toBST(right); return root; }","categories":[],"tags":[{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"}]},{"title":"有效括号","slug":"有效括号","date":"2020-08-14T03:34:28.000Z","updated":"2023-02-14T15:19:27.743Z","comments":true,"path":"2020/08/14/有效括号/","link":"","permalink":"http://yoursite.com/2020/08/14/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"有效的括号 题目描述给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例示例1： 输入: \"()\" 输出: true 示例2： 输入: \"()[]{}\" 输出: true 示例3： 输入: \"([)]\" 输出: false 示例4： 输入: \"{[]}\" 输出: true 思路 遍历 s 当遇到[, (, { 这些括号的时候就入栈。 当遇到], ), } 这些括号的时候就出栈，出栈 判断与当前s[i] 是否匹配为闭合的括号, 即是否是一对。出栈(, 当前s[i]为)则为一对 代码/** * @param {string} s * @return {boolean} */ var isValid = function(s) { let length = s.length; // 做优化，看了答案后添加 if(length % 2 == 1) { return false; } // 建立字典， let map = { \"{\": \"}\", \"(\": \")\", \"[\": \"]\", } let inqueue = [\"{\", \"(\", \"[\"]; let stack = []; for(let i = 0; i &lt; s.length; i++) { const current = s[i]; // 判断以下是否属于开合 的括号 if(inqueue.includes(current)) { stack.unshift(current); continue; } // 出栈， 判断当前出栈的括号是否跟 s[i] 为一对， let pop = stack.shift(); if(current !== map[pop]) { return false } } // 最后判断以下栈里面还有没有数据，有的话那就代表还有没有匹配的括号 return stack.length == 0 ; };","categories":[],"tags":[{"name":"algorithm-栈","slug":"algorithm-栈","permalink":"http://yoursite.com/tags/algorithm-%E6%A0%88/"}]},{"title":"字符串相乘","slug":"字符串相乘","date":"2020-08-13T08:02:26.000Z","updated":"2023-02-14T15:19:27.736Z","comments":true,"path":"2020/08/13/字符串相乘/","link":"","permalink":"http://yoursite.com/2020/08/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/","excerpt":"","text":"字符串相乘 题目描述给定两个字符串 num1 和 num2 ,返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例： 输入: num1 = \"2\", num2 = \"3\" 输出: \"6\" 分析我们以 num1 = &quot;123&quot;, num2 = &quot;456&quot;做例子 1 2 3 4 5 6 -------------- 1 3 6 8 9 1 2 0 4 5 6 ------------------ 5 6 0 8 8 我们循环 123，分别乘以下面的 456, 3 * 456 得到的是 1368 2 * 456 得到的是 912， 但此时的2应该是20， 所以得到的结果是 9120 1 * 456 得到的是 456， 但此时的1应该是100，所以得到的结果是 45600 将这三个结果加起来即可 注意：我们每次相乘的结果都用数组存起来， 1368 =&gt; [1,3,6,8] 如此类推 后面就是大数相加了，将所有的数组都加起来，另外这里使用了分治 代码/** * @param {string} num1 * @param {string} num2 * @return {string} */ var multiply = function(num1, num2) { if(num1 == 0 || num2 == 0) { return \"0\"; } let length1 = num1.length; let length2 = num2.length; let multiplyAdd = 0; let times = 0; let resArr = [] for(let i = length1 - 1; i >= 0; i--) { let currentNum1 = num1[i] * 1 let resultArray = [] for(let j = length2 - 1; j >= 0; j--) { const tempRes = currentNum1 * (num2[j] * 1) + multiplyAdd; const div = tempRes % 10; multiplyAdd = Math.floor(tempRes / 10); resultArray.unshift(div) } if(multiplyAdd > 0) { resultArray.unshift(multiplyAdd); multiplyAdd = 0; } for(let k = 0; k &lt; times; k++) { resultArray.push(0) } times++; resArr.push(resultArray.join(\"\")) } if(resArr.length &lt;= 1) { return resArr.join(\"\") } const test = fenzhi(resArr); return test.join(\"\"); }; /** * [\"1386\", \"9120\", \"45600\"] * 递归分支 * 递归结束条件时，数组只剩下一个的时候, 直接返回 * 剩下的就是左右两个相加了 combine(left, right), // 简单说就是 left + right */ var fenzhi = function(arr) { let length = arr.length; if(length == 1) { return arr.join(\"\"); } const currentIndex = Math.floor(arr.length / 2); let left = arr.slice(0, currentIndex); let right = arr.slice(currentIndex, length); return combine( fenzhi(left) , fenzhi(right) ); } // 我这里使用大数相加 var combine = function(arr1, arr2) { let result = []; let length1 = arr1.length - 1; let length2 = arr2.length - 1; let add = 0; let i = 0; let j = 0; while(length1 >= 0 || length2 >= 0) { let num1 = length1 >= 0 ? arr1[length1] : 0; let num2 = length2 >= 0 ? arr2[length2] : 0 let res = num1 * 1 + num2 * 1 + add * 1; let div = res % 10; add = Math.floor(res / 10); result.unshift(div); length2--; length1--; } if(add > 0) { result.unshift(add); } // console.log(\"result\", result) return result; }","categories":[],"tags":[{"name":"algorithm-数组","slug":"algorithm-数组","permalink":"http://yoursite.com/tags/algorithm-%E6%95%B0%E7%BB%84/"},{"name":"algorithm-分治","slug":"algorithm-分治","permalink":"http://yoursite.com/tags/algorithm-%E5%88%86%E6%B2%BB/"}]},{"title":"剑指 Offer 55 - II. 平衡二叉树","slug":"剑指-Offer-55-II-平衡二叉树","date":"2020-08-12T08:27:13.000Z","updated":"2023-02-14T15:19:27.734Z","comments":true,"path":"2020/08/12/剑指-Offer-55-II-平衡二叉树/","link":"","permalink":"http://yoursite.com/2020/08/12/%E5%89%91%E6%8C%87-Offer-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"剑指 Offer 55 - II. 平衡二叉树 题目描述输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 。 分析 我们每次获取左右节点的最大深度，然后相减要是 &lt;= 1 在递归左右节点 代码var isBalanced = function(root) { if(!root) { return true } let left = dept(root.left); let right = dept(root.right); return Math.abs(left - right) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right) } var dept = function(root) { if(!root) { return 0; } return Math.max( dept(root.left), dept(root.right) ) + 1 }","categories":[],"tags":[{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"algorithm-深度遍历搜索","slug":"algorithm-深度遍历搜索","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2/"}]},{"title":"关于this","slug":"关于this","date":"2020-08-11T07:19:51.000Z","updated":"2023-02-14T15:19:27.734Z","comments":true,"path":"2020/08/11/关于this/","link":"","permalink":"http://yoursite.com/2020/08/11/%E5%85%B3%E4%BA%8Ethis/","excerpt":"","text":"参考 《你不知道的JavaScript上卷》 我们经常会对this的指向存在疑惑，搞不清楚是指向window，还是本身。 this 的解析 this是在运行时进行绑定的，并不是在编写时绑定， 它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式 this 规则我们要清楚知道在函数的执行过程中调用位置是如何确定this的绑定对象的。 我们分析 函数是属于以下四种规则的哪一种既可。 默认绑定 隐式绑定 显示绑定 硬绑定 默认绑定默认绑定是最常用的一种方式，可以把这条规则看作是无法应用其他规则时的默认规则。 // 例子 function foo() { console.log(this); // this 指向的是window } // 此时我们调用的位置在全局，那么foo 的this指向的是window foo(); 注意：默认绑定在严格模式下，会报错。 严格模式下，默认绑定会将this绑定到undefined 隐式绑定一般来说隐式绑定就是obj.func()这样子。但我们看看下面的注意事项 // 这里要注意foo的声明方式 function foo() { console.log(this.a) // 123 } const obj = { a: \"123\", foo: foo } //obj对象引用了foo, 调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象“拥有”或者“包含”它。 obj.foo(); 隐式调用： 当函数引用有上下文的时候，函数的this会绑定到上下文对象中。 但是对象属性引用链中只有上一层或者说最后一层在调用位置中起作用 // 例子 function foo() { console.log(this.a) } const obj = { a: \"123\", foo: foo } const obj2 = { a: \"2\", // obj: obj } // 这里是最后一层起作用了 obj2.obj.foo(); // 123 隐式丢失 简单说就是函数丢失了原来的绑定对象，然后函数使用默认绑定的方式，导致了this指向window或者是undefined function foo() { console.log(this.a) } const obj = { a: \"123\", foo: foo } var a = \"windows\"; // 虽然 obj.foo 引用的是foo 函数，但是它等同于使用foo(), 这样看的话他的调用方式是全局的，所以使用默认绑定 const test = obj.foo; test() // windows, 另外还有回调函数会造成this的丢失，所以我们一般用call或者apply去改变this的指向 // 例子 function foo() { console.log(this.a) } const obj = { a: \"123\", foo: foo } var a = \"windows\"; function doFoo(fn) { // fn => foo fn() } doFoo(obj.foo) 显示绑定显示绑定主要是使用了 call 和 apply, 我们可以理解 当函数调用是，this 的指向更改为call函数或者apply函数的第一个参数 var obj = { a: \"123\" } function foo() { console.log(this.a) } foo.call(obj); // 123， 我们理解成 当foo函数调用的时候 this 指向 obj 我们可以理解为 foo.call(obj) =&gt; foo(), 但是this指向了obj 我们看下一个最常用的操作 // 辅助函数 function bind(fn, obj) { return function() { return fn.apply(obj, arguments); } } function foo(params) { console.log(this.a, params) } var obj = { a: \"123\" } var test = bind(foo, obj); // bind函数返回的是function test(\"hahah\") // 输出： 123，hahah new 绑定使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行[[Prototype]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 我们先看看new的实现源码 function new(fn, ...args) { let obj = {}; obj._proto_ = fn.prototype; let res = fn.call(obj, ...args); let isObject = typeof res === 'object' &amp;&amp; typeof res !== null; let isFunction = typeof res === 'function'; return isObject || isFunction ? res : obj; } 看到上面第三步，call 改变了fn this的指向 function foo(a) { this.a = a } var obj = new foo(2) console.log(obj.a); // 2 优先级new &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 我们看看 如何实现 apply 和 call方法call// call 方法类似, call 方法实现方式跟下面一样 var foo = { value: 1, bar: function() { console.log(this.value) } } foo.bar() // 1 // fn.call(obj, 1, 2) Function.prototype.imitateCall = function (context) { // 这里的context 同等于上面的 foo， 如果context没有那么我们指定到window context = context || window // 当前this 指的是 function context.invokFn = this // 截取作用域对象参数后面的参数 let args = [...arguments].slice(1) // 执行调用函数，记录拿取返回值 let result = context.invokFn(...args) // 销毁调用函数，以免作用域污染 Reflect.deleteProperty(context, 'invokFn') return result } apply// fn.apply(obj, [1, 2]) Function.prototype.imitateApply = function (context) { // 这里的context 同等于上面的 foo， 如果context没有那么我们指定到window context = context || window // 当前this 指的是 function context.invokFn = this // 截取作用域对象参数后面的参数 let result if (arguments[1]) { result = context.invokFn(...arguments[1]) } else { result = context.invokFn() } // 销毁调用函数，以免作用域污染 Reflect.deleteProperty(context, 'invokFn') return result }","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"计数二进制子串","slug":"计数二进制子串","date":"2020-08-10T05:59:14.000Z","updated":"2023-02-14T15:19:27.745Z","comments":true,"path":"2020/08/10/计数二进制子串/","link":"","permalink":"http://yoursite.com/2020/08/10/%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/","excerpt":"","text":"计数二进制子串 题目描述给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例：输入: \"00110011\" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 请注意，一些重复出现的子串要计算它们出现的次数。 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 分析 我们直接用 1100 做分析例子，我们可以看出其实他的结果就是 2，就只有两种结果[1100, 10] 所以我们循环这个字符串，记录相同的的数字 1的个数 = 2；然后以当前i做起点，往后遍历两位，要是都相同那么就是2种（此时重复的数字还是2），要是只有一位就只有1种（此时重复的数字就变成1了） 代码/** * @param {string} s * @return {number} */ var countBinarySubstrings = function(s) { let length = s.length; if(length == 0) { return 0; } let count = 1; let prev = s[0]; let currentNum = null; let result = 0; // s = \"1100\" let i = 1; while(i &lt; length) { currentNum = s[i]; if(currentNum == prev) { // 为了找相同的数字 count++; // 相同数字的个数 i++; continue; } // prev = 1; count = 2 // currentNum 已经跟prev 不一样了， 就是 0 => 1 , 1 => 0， 然后以i为起点，遍历后面count个数 let j = i; while(j &lt; i + count &amp;&amp; j &lt; length) { // 这里表示 当前数字跟 前一个数字相同的话结果 + 1 ,即当前 prev = 1， s[j] = 0, 就是当前i为去起点，往后两位都是0的话就 + 2 if(s[j] == !(prev * 1)) { result++; } else { // 此时不一样时，重新计算重复的个数 count = j - i break; } j++; } i = i + count; prev = currentNum; } return result };","categories":[],"tags":[{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"}]},{"title":"相同的树","slug":"相同的树","date":"2020-08-07T02:17:43.000Z","updated":"2023-02-14T15:19:27.745Z","comments":true,"path":"2020/08/07/相同的树/","link":"","permalink":"http://yoursite.com/2020/08/07/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/","excerpt":"","text":"题目描述给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例：输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] 输出: true 分析 我们暂定左边的树为p, 右边的树为q 从根分析，要是 p 或 q ，一个为空，另一个不为空，那么我们返回false p 和 q 都为空，那么我们直接返回true p 和 q 都不为空，那么我们判断他们的值是否相同 p.val === q.val 递归操作， 判断 p的左子树 跟 q 的左子树 是否相同，执行上面的操作, 所以isSameTree(p.left, q.left)； p 的右子树 跟 q 的右子树是否相同，执行上面的操作, 所以 isSameTree(p.right, q.right) 代码/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */ var isSameTree = function(p, q) { if(!p &amp;&amp; q) { return false } if(p &amp;&amp; !q) { return false } if(!p &amp;&amp; !q) { return true } if(p.val !== q.val) { return false } return p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); };","categories":[],"tags":[{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"滑动验证码","slug":"滑动验证码","date":"2020-08-06T08:49:31.000Z","updated":"2023-02-14T15:19:27.743Z","comments":true,"path":"2020/08/06/滑动验证码/","link":"","permalink":"http://yoursite.com/2020/08/06/%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"","text":"前言一直想做一个滑动验证码的组件。 html 结构&lt;div className={styles.container}> &lt;div className={styles.slider}> &lt;!-- 滑块 --> &lt;div className={styles.sliderHandle} onMouseDown={mouseDown} style={sliderHandleStyle} > >> &lt;/div> &lt;!-- 轨道 --> &lt;div className={styles.sliderRail}> &lt;div className={styles.text}>向右滑动验证&lt;/div> &lt;/div> &lt;!-- 滑块路线 --> &lt;div className={styles.sliderTrack} style={{width: ((offset.x) / 250 * 100 + \"%\"), borderRadius: (offset.x &lt; 250) ? 'none' : '45px' }}>&lt;/div> &lt;/div> &lt;/div> less 结构主要是一些定位， 相对定位中的绝对定位 .container { width: 400px; height: 400px; margin: 50px auto; display: flex; flex-direction: column; align-items: center; justify-content: center; user-select: none; .slider { width: 250px; height: 45px; position: relative; border-radius: 45px; .sliderHandle { width: 45px; height: 45px; border-radius: 50%; display: flex; flex-direction: row; justify-content: center; align-items: center; background-color: #fff; z-index: 99; position: absolute; left: 0; top: 0; right: auto; transform: translateX(-50%); box-shadow: 1px 5px 2px #eee; cursor: pointer; } .sliderRail { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; border-radius: 45px; background-color: #f5f5f5; display: flex; flex-direction: row; justify-content: center; align-items: center; } .sliderTrack { position: absolute; width: 0%; top: 0; left: 0; z-index: 89; right: 0; bottom: 0; border-top-left-radius: 45px; border-bottom-left-radius: 45px ; background-color: #91d5ff; } } } 代码逻辑代码中主要使用的是 react Hook， 主要的逻辑是使用了 mouseup, mouseover, mouseDown const Block: React.FC = () => { const [dragging, setDragging] = useState(false); const [origin, setOrigin] = useState({ x: 0, y: 0 }); const [offset, setOffset] = useState({ x: 0, y: 0}); const mouseDown = useCallback(({clientX, clientY}) => { console.log(\"mouseDown\", clientX); setOrigin((state) => ({ x: clientX, y: clientY})) setDragging(true); }, []); const mouseMove = useCallback(({clientX, clientY}) => { let x = clientX - origin.x; if( x >= 250 ) { x = 250 } else if(x / 250 * 100 &lt;= 0 ) { x = 0; } const transition = { x, y: clientY - origin.y }; if(x >= 250) { setDragging(() => false) } setOffset(state => { return { ...state, ...transition } }); }, [origin]); const mouseUp = useCallback(() => { console.log(\"up\") setDragging(() => false) }, []); useEffect(() => { if (dragging) { window.addEventListener('mousemove', mouseMove); window.addEventListener('mouseup', mouseUp); } else { window.removeEventListener('mousemove', mouseMove); window.removeEventListener('mouseup', mouseUp); setOffset((state) => { let x = state.x if(x>= 250) { console.log(\"验证通过\") } else if(x&lt; 250) { x = 0 } return { x: x, y: state.y } }) } }, [dragging]); const sliderHandleStyle = useMemo(() => ({ left: (offset.x) / 250 * 100 + \"%\", transition: (!dragging ? 'left 500ms' : 'none' ) }), [offset, dragging]) return ( &lt;div> &lt;div className={styles.container}> &lt;div className={styles.slider}> &lt;div className={styles.sliderHandle} onMouseDown={mouseDown} style={sliderHandleStyle} >&lt;DoubleRightOutlined />&lt;/div> &lt;div className={styles.sliderRail}> &lt;div className={styles.text}>向右滑动验证&lt;/div> &lt;/div> &lt;div className={styles.sliderTrack} style={{width: ((offset.x) / 250 * 100 + \"%\"), borderRadius: (offset.x &lt; 250) ? 'none' : '45px' }}>&lt;/div> &lt;/div> &lt;/div> &lt;/div> ); } 线上仓库demo 这里记录一下在使用 react hook 的一些问题先谈谈 useCallback 这个函数吧 useCallbackuseCallback 提供了两个参数，一个个回调函数，另一个是依赖数组。当依赖数组不改变时，此时回调函数不改变，已达到缓存的效果，减少在re-render的时候重新生成函数 案例1// Child.js const Child = ({cb}) => { return ( &lt;div> &lt;button onClick={cb}>点击&lt;/div> &lt;/div> ) } const App = () => { // 此时 当App 重新渲染的时候，会重新生成 memoClick // const memoClick = () => console.log(\"click\"); // 用了useCallback 后 无论App 是否重新渲染，传给 Child 的 memoClick 都是之前的引用 const memoClick = useCallback(() => console.log(\"click\"), []) return ( &lt;div> &lt;Child cb={cb} /> &lt;/div> ) } 其他当useCallback 的依赖数组 在useCallback内设置变化会导致无限循环 const App = () => { const [a, setA] = useState(1); const memoClick = useCallback(() => { console.log(\"click\") setA((state) => { const after = state.a++; return after }) }, [a]) return ( &lt;div> &lt;div>{a}&lt;/div> &lt;Button onClick={memoClick}>点击&lt;/Button> &lt;/div> ) } 然后我找了很多文章，应该只有这篇是讲的比较清晰的， React Hooks(二): useCallback 之痛 后话验证码组件还没做好，但大体逻辑是这样","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"二叉树的最大深度","slug":"二叉树的最大深度","date":"2020-07-30T05:36:08.000Z","updated":"2023-02-14T15:19:27.734Z","comments":true,"path":"2020/07/30/二叉树的最大深度/","link":"","permalink":"http://yoursite.com/2020/07/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"二叉树的最大深度 题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 分析 题目用递归 递归终止条件： 当当前树节点为空时，返回0 要是根不为空，我们比较 左右节点，看左节点比较深还是右节点深 代码/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function(root) { if(!root) { return 0 } return (1 + Math.max( maxDepth(root.left), maxDepth(root.right) )) };","categories":[],"tags":[{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"}]},{"title":"整数拆分","slug":"整数拆分","date":"2020-07-30T02:54:46.000Z","updated":"2023-02-14T15:19:27.742Z","comments":true,"path":"2020/07/30/整数拆分/","link":"","permalink":"http://yoursite.com/2020/07/30/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/","excerpt":"","text":"整数拆分力扣上 题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例2： 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 思想 2 =&gt; 1 + 1 3 =&gt; 2 + 1 4 =&gt; 2 + 2 5 =&gt; 2 + 3 6 =&gt; 3 + 3 7 =&gt; 3 + 4 8 =&gt; 3 + 3 + 2 9 =&gt; 3 + 3 + 3 10 =&gt; 3 + 3 + 2 + 2 观察 10 跟 8, 还有 7 的关系， 观察9 跟 7 还有 6 的关系, 我这里直接用dp表示 dp[10] = max(dp[8] * 2, dp[7] * 3), =&gt; max(3 * 3 * 3 * 2, 3 * 4 * 3) dp[9] = max(dp[7] * 2, dp[6] * 3), =&gt; max(3 * 4 * 2, 3 * 3 * 3) 注意：但你会发现 从dp[6] 往上就不符合上面的方法了， dp[6] = max(dp[4] * 2, dp[3] * 3) 所以我直接做了暴力破解！直接赋值 代码/** * @param {number} n * @return {number} */ var integerBreak = function(n) { let dp = Array(n + 1).fill(1); dp[3] = 2; dp[4] = 4; dp[5] = 6 dp[6] = 9 for(let i = 7; i &lt;= n; i++) { dp[i] = Math.max(dp[i - 3] * 3, dp[i - 2] * 2); } return dp[n] }; 官方题解dp[i]=max(2×(i−2),2×dp[i−2],3×(i−3),3×dp[i−3]) class Solution { public: int integerBreak(int n) { if (n < 4) { return n - 1; } vector dp(n + 1); dp[2] = 1; for (int i = 3; i","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"xlsx 读取写入excel","slug":"xlsx-读取写入excel","date":"2020-07-27T01:38:24.000Z","updated":"2023-02-14T15:19:27.733Z","comments":true,"path":"2020/07/27/xlsx-读取写入excel/","link":"","permalink":"http://yoursite.com/2020/07/27/xlsx-%E8%AF%BB%E5%8F%96%E5%86%99%E5%85%A5excel/","excerpt":"","text":"js-xlsxnpm install xlsx --save 文档地址 读取这里记录一下最经常用的方法，到时候复杂处理再记录 以nodejs 的方式// nodejs 方式读取文件 const filePath = './test.xlsx'; const ws = xlsx.readFile(filePath, { type: 'binary'}); // 传文件路径读取文件 const sheet = ws.Sheets[\"Sheet1\"]; // 指定工作表 const data = xlsx.utils.sheet_to_json(sheet, {header:1}); // 对工作表的内容进行json 转化 const header = data.slice(0, 1); // 第一行就是我们的header const body = data.slice(1); // 数据body browser 方式，上传文件的形式读取excel&lt;input type=\"file\" @change=\"fileChange\" /> function fileChange(e) { var files = e.target.files; console.log(files) var fileReader = new FileReader(); fileReader.readAsBinaryString(files[0]); fileReader.onload = (ev) => { // 读取上传的文件，后面的跟上面类似 const file = ev.target.result; const wb = xlsx.read(file, { type: 'binary' }); const sheet = wb.Sheets[\"Sheet1\"]; const data = xlsx.utils.sheet_to_json(sheet, {header:1}); }; }, 写 Excelnodejs 方式直接导出excel/** * @params dataSource 简单的数据结构 * @params excelName 表名 */ type source { name: string, address: string, phone: number } function json2Excel(dataSource: source, excelName: string) { let wb = xlsx.utils.book_new() let ws = xlsx.utils.aoa_to_sheet(dataSource); // 将简单的数据对象写到工作表里 xlsx.utils.book_append_sheet(wb, ws, \"SheetJS\") xlsx.writeFile(wb, `${excelName}.xlsx`); } 创建a 链接方式导出excel参考 其他链接参考","categories":[{"name":"js-xlsx","slug":"js-xlsx","permalink":"http://yoursite.com/categories/js-xlsx/"}],"tags":[{"name":"js-xlsx","slug":"js-xlsx","permalink":"http://yoursite.com/tags/js-xlsx/"}]},{"title":"除数博弈","slug":"除数博弈","date":"2020-07-24T06:03:55.000Z","updated":"2023-02-14T15:19:27.747Z","comments":true,"path":"2020/07/24/除数博弈/","link":"","permalink":"http://yoursite.com/2020/07/24/%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/","excerpt":"","text":"除数博弈 题目描述爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例1： 输入：2 输出：true 解释：爱丽丝选择 1，鲍勃无法进行操作。示例2： 输入：3 输出：false 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。思想 题目要求能整除那么被除数 一定是 1，2，3，5 这几个数，所以我们只要关注dp[i-1], dp[i-2]和dp[i-3]还有dp[i-5]的值即可 另外题目也说 0 &lt; x &lt; N 所以 i 一定要大于 2, 或者3，或者 5 另外 假设 i = 4时， 可以整除2，所以可以关注dp[2]的值，和dp[3]的值， 如果我们关注dp[3]的话，也就是我先手，先取1，他取1，我再取1，他无法操作，我赢 如果我们关注dp[2]的话，也就是我先手，我先取2， 他取1，我无法操作，我输， 总结： 总体来说是赢的，但dp[4] 要取与dp[2]， dp[3]相反的值. 代码var divisorGame = function(N) { // 这既是一个博弈游戏，类似捡石子 let dp = Array(N + 1).fill(false); dp[0] = false; dp[1] = false; dp[2] = true; for(let i = 3; i &lt; N + 1; i++) { // 1, 2, 3, 5 dp[i] = (i > 5 &amp;&amp; i % 5 == 0 &amp;&amp; !dp[i - 5]) || (i > 2 &amp;&amp; i % 2 == 0 &amp;&amp; !dp[i - 2]) || (i > 3 &amp;&amp; i % 3 == 0 &amp;&amp; !dp[i - 3]) || (!dp[i - 1]); } console.log(dp); return dp[N]; }; 官方解答看了官方解答，我真的是吐了，就一样代码 var divisorGame = function(N) { return N % 2 == 0; };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"expo 极光推送","slug":"expo 极光推送","date":"2020-07-23T02:53:00.000Z","updated":"2023-02-14T15:19:27.730Z","comments":true,"path":"2020/07/23/expo 极光推送/","link":"","permalink":"http://yoursite.com/2020/07/23/expo%20%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81/","excerpt":"","text":"这里记录一下在用expo 接入极光推送时的坑貌似极光推送不能在ios模拟器中显示，推送的预估人数一直为0 注意：因为expo不支持第三方sdk, 即不支持react-native link 这种方式，所以需要expo eject的方式使用Bare workflow 这里我使用的是jpush-react-native 极光官方维护的sdk yarn add jpush-react-native yarn add jcore-react-native expo eject 在eject的时候建立包名， 我这里ios/react 都一样com.notice.test eject 之后我们可以在项目得到原始的react-native包, 即包含了ios 以及android 两个包 这里官方文档写的不好，我们直接使用pod 自动引入的方式， issues 有人提到如果两种方式一起引用的话会报错 cd ios &amp;&amp; pod deintegrate pod install ios需要进行证书设置, 这里直接看官方指南就可以了 接下来就是修改 AppDelegate.m， 用xcode 打开ios目录下的.xcworkspace文件， 展开项目名notice即可看到AppDelegate.m, 以下可以参考官方例子 在头部加入 #import #ifdef NSFoundationVersionNumber_iOS_9_x_Max #import #endif 在didFinishLaunchingWithOptions 方法加入, 同时修改appKey // JPush初始化配置 [JPUSHService setupWithOption:launchOptions appKey:@\"57012733695b98e936ada5b0\" channel:@\"default\" apsForProduction:YES]; // APNS JPUSHRegisterEntity * entity = [[JPUSHRegisterEntity alloc] init]; if (@available(iOS 12.0, *)) { entity.types = JPAuthorizationOptionAlert|JPAuthorizationOptionBadge|JPAuthorizationOptionSound|JPAuthorizationOptionProvidesAppNotificationSettings; } [JPUSHService registerForRemoteNotificationConfig:entity delegate:self]; [launchOptions objectForKey: UIApplicationLaunchOptionsRemoteNotificationKey]; // 自定义消息 NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter]; [defaultCenter addObserver:self selector:@selector(networkDidReceiveMessage:) name:kJPFNetworkDidReceiveMessageNotification object:nil]; // 地理围栏 [JPUSHService registerLbsGeofenceDelegate:self withLaunchOptions:launchOptions]; 在最后加入 //************************************************JPush start************************************************ //注册 APNS 成功并上报 DeviceToken - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken { [JPUSHService registerDeviceToken:deviceToken]; } //iOS 7 APNS - (void)application:(UIApplication *)application didReceiveRemoteNotification: (NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler { // iOS 10 以下 Required NSLog(@\"iOS 7 APNS\"); [JPUSHService handleRemoteNotification:userInfo]; [[NSNotificationCenter defaultCenter] postNotificationName:J_APNS_NOTIFICATION_ARRIVED_EVENT object:userInfo]; completionHandler(UIBackgroundFetchResultNewData); } //iOS 10 前台收到消息 - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(NSInteger))completionHandler { NSDictionary * userInfo = notification.request.content.userInfo; if([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) { // Apns NSLog(@\"iOS 10 APNS 前台收到消息\"); [JPUSHService handleRemoteNotification:userInfo]; [[NSNotificationCenter defaultCenter] postNotificationName:J_APNS_NOTIFICATION_ARRIVED_EVENT object:userInfo]; } else { // 本地通知 todo NSLog(@\"iOS 10 本地通知 前台收到消息\"); [[NSNotificationCenter defaultCenter] postNotificationName:J_LOCAL_NOTIFICATION_ARRIVED_EVENT object:userInfo]; } //需要执行这个方法，选择是否提醒用户，有 Badge、Sound、Alert 三种类型可以选择设置 completionHandler(UNNotificationPresentationOptionAlert); } //iOS 10 消息事件回调 - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler: (void (^)(void))completionHandler { NSDictionary * userInfo = response.notification.request.content.userInfo; if([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) { // Apns NSLog(@\"iOS 10 APNS 消息事件回调\"); [JPUSHService handleRemoteNotification:userInfo]; // 保障应用被杀死状态下，用户点击推送消息，打开app后可以收到点击通知事件 [[RCTJPushEventQueue sharedInstance]._notificationQueue insertObject:userInfo atIndex:0]; [[NSNotificationCenter defaultCenter] postNotificationName:J_APNS_NOTIFICATION_OPENED_EVENT object:userInfo]; } else { // 本地通知 NSLog(@\"iOS 10 本地通知 消息事件回调\"); // 保障应用被杀死状态下，用户点击推送消息，打开app后可以收到点击通知事件 [[RCTJPushEventQueue sharedInstance]._localNotificationQueue insertObject:userInfo atIndex:0]; [[NSNotificationCenter defaultCenter] postNotificationName:J_LOCAL_NOTIFICATION_OPENED_EVENT object:userInfo]; } // 系统要求执行这个方法 completionHandler(); } //自定义消息 - (void)networkDidReceiveMessage:(NSNotification *)notification { NSDictionary * userInfo = [notification userInfo]; [[NSNotificationCenter defaultCenter] postNotificationName:J_CUSTOM_NOTIFICATION_EVENT object:userInfo]; } //************************************************JPush end************************************************ 后记这里可以建议封装一个简单的hook, 来给我们注册用 运行 用usb将iphone跟mac 链接 这里有时候会遇到一个问题, 就是iphone跟mac一直连上又断开， 解决方法sudo killall -STOP -c usbd 最后运行 npx react-native run-ios --device &quot;Bill@iPhone&quot;","categories":[],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"},{"name":"expo","slug":"expo","permalink":"http://yoursite.com/tags/expo/"}]},{"title":"最小路径和","slug":"最小路径和","date":"2020-07-23T02:53:00.000Z","updated":"2023-02-14T15:19:27.742Z","comments":true,"path":"2020/07/23/最小路径和/","link":"","permalink":"http://yoursite.com/2020/07/23/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","excerpt":"","text":"最小路径和 这道题跟三角形最小路径和类似 题目描述给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例： 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 思想这是一道二维数组的动态规划题目， 左边表示输入， 右边表示dp 结果集 第一行只能够向右走， 所以 dp[i][j] = grid[i][j] + dp[i][j - 1]; 第一列只能向下走，所以 dp[i][j] = grid[i][j] + dp[i - 1][j] 其余符合 dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]); .minPathSum { display: flex; flex-direction: row; } .minPathSum-right { margin-left: 10px } @media screen and (max-width: 800px) { .minPathSum { display: flex; flex-direction: column; } .minPathSum-right { margin-left: 0px } } w 输入 i / k k = 0 k = 1 k = 2 i = 0 1 3 1 i = 1 1 5 1 i = 2 4 2 1 dp结果集 i / k k = 0 k = 1 k = 2 i = 0 1 4 5 i = 1 2 7 (上面dp值与左边dp值比较取最小 + grid) 6 i = 2 6 8 7 代码/** * 二维数组的动态规划 * 当前 dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]); * 第一行只能够向右走， 所以 dp[i][j] = grid[i][j] + dp[i][j - 1]; * 第一列只能向下走，所以 dp[i][j] = grid[i][j] + dp[i - 1][j] */ var minPathSum = function(grid) { let rows = grid.length; let columns = grid[0].length; let dp = []; for(let i = 0; i &lt; rows; i++) { let temp = []; for(let j = 0; j &lt; columns; j++) { if(i == 0 &amp;&amp; j == 0) { temp.push(grid[i][j]); } else if(j == 0) { temp.push(grid[i][j] + dp[i - 1][j]); } else if(i == 0) { temp.push(grid[i][j] + temp[j - 1]) } else { temp.push(grid[i][j] + Math.min(dp[i - 1][j], temp[j - 1])) } } dp.push(temp); } return dp[rows - 1][columns - 1] };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"React源码 调度","slug":"React-调度","date":"2020-07-21T02:11:25.000Z","updated":"2023-02-14T15:19:27.727Z","comments":true,"path":"2020/07/21/React-调度/","link":"","permalink":"http://yoursite.com/2020/07/21/React-%E8%B0%83%E5%BA%A6/","excerpt":"","text":"继上一遍React源码-ReactDom 我们查看了ReactDom 的render所构成的整个fiber 结构 我们重新看 legacyRenderSubtreeIntoContainer, 我们构建完fiber之后往下走 function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component&lt;any, any>, children: ReactNodeList, container: DOMContainer, forceHydrate: boolean, callback: ?Function, ) { // 一开始进来 container 上是肯定没有这个属性的 let root: Root = (container._reactRootContainer: any); // 没有 root 会执行 if 中的操作 if (!root) { // Initial mount // 创建一个 root 出来，类型是 ReactRoot root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate, ); // ... 这里直接省略callback, 因为我们不关注callback unbatchedUpdates(() => { // 大多数情况parentComponent 为null, 一遍不考虑，我们直接看else if (parentComponent != null) { root.legacy_renderSubtreeIntoContainer( parentComponent, children, callback, ); } else { // 调用的是 ReactRoot.prototype.render，我们直接看这里 root.render(children, callback); } }); } else { // ... 这里直接省略callback, 因为我们不关注callback // Update if (parentComponent != null) { root.legacy_renderSubtreeIntoContainer( parentComponent, children, callback, ); } else { root.render(children, callback); } } return getPublicRootInstance(root._internalRoot); } React.prototype.renderReactRoot.prototype.render = function( children: ReactNodeList, callback: ?() => mixed, ): Work { // 这里指 FiberRoot const root = this._internalRoot; // ReactWork 的功能就是为了在组件渲染或更新后把所有传入 // ReactDom.render 中的回调函数全部执行一遍 // 我们这里callback 为null, 所以其实不用考虑这个 const work = new ReactWork(); callback = callback === undefined ? null : callback; // 如果有 callback，就 push 进 work 中的数组 if (callback !== null) { work.then(callback); } // work._onCommit 就是用于执行所有回调函数的 updateContainer(children, root, null, work._onCommit); return work; }; updateContainer// packages\\react-reconciler\\src\\ReactFiberReconciler.js export function updateContainer( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component&lt;any, any>, callback: ?Function, ): ExpirationTime { // 取出容器的 fiber 对象. const current = container.current; // 计算时间 const currentTime = requestCurrentTime(); // expirationTime 代表优先级，数字越大优先级越高 // sync 的数字是最大的，所以优先级也是最高的 const expirationTime = computeExpirationForFiber(currentTime, current); return updateContainerAtExpirationTime( element, container, parentComponent, expirationTime, callback, ); } requestCurrentTimepackages\\shared\\ReactFeatureFlags.js 的 enableNewScheduler = false; 所以使用的是packages\\react-reconciler\\src\\ReactFiberScheduler.old.js let originalStartTimeMs: number = now(); let currentRendererTime: ExpirationTime = msToExpirationTime( originalStartTimeMs, ); let currentSchedulerTime: ExpirationTime = currentRendererTime; // 承接下面的currentSchedulerTime 和 currentRendererTime function requestCurrentTime() { // 调度程序调用requestCurrentTime来计算到期时间。 // 过期时间是通过将当前时间（开始时间）加起来得出的时间。 // 但是，如果在同一事件中安排了两次更新，即使实际时钟时间在第一次和第二次呼叫之间提前了，我们也应将它们的开始时间视为同时发生。 // 换句话说，由于到期时间决定了更新的批处理方式，因此我们希望在同一事件中发生的所有优先级相同的更新都收到相同的到期时间。。 // 我们跟踪两个不同的时间：当前的“渲染器”时间和当前的“调度器”时间。 渲染器时间可以随时更新。 它只是为了最大程度地降低通话性能。 // 但是，只有在没有待处理的工作，或者确定我们不在某个事件的中间时，才能更新调度程序时间。 if (isRendering) { // 此时在渲染中，直接返回当前作态 return currentSchedulerTime; } // Check if there's pending work. findHighestPriorityRoot(); if ( nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never ) { // 如果没有待处理的工作，那么返回当前的渲染时间 recomputeCurrentRendererTime(); // 此函数 直接修改了currentRendererTime currentSchedulerTime = currentRendererTime; return currentSchedulerTime; } // 有待处理的时间时, 返回上一次的计时器时间 return currentSchedulerTime; } recomputeCurrentRendererTimefunction recomputeCurrentRendererTime() { const currentTimeMs = now() - originalStartTimeMs; currentRendererTime = msToExpirationTime(currentTimeMs); } 过期时间计算 先来看看的当前计算过期时间的公式吧 // packages\\react-reconciler\\src\\ReactFiberExpirationTime.js export const NoWork = 0; export const Never = 1; export const Sync = MAX_SIGNED_31_BIT_INT; // 1073741823 const UNIT_SIZE = 10; const MAGIC_NUMBER_OFFSET = MAX_SIGNED_31_BIT_INT - 1; // ((ms / 10) | 0) 表示的是取整 2.5 | 0 = 2 // ms时间戳 到 expireationTime 的转换， 数值越大优先级越高 export function msToExpirationTime(ms: number): ExpirationTime { return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0); } export function expirationTimeToMs(expirationTime: ExpirationTime): number { return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE; } // 我们可以简单看成 num + 1 * precision， 也就是在一个precision 的范围内 function ceiling(num: number, precision: number): number { return (((num / precision) | 0) + 1) * precision; } //为了计算在某个bucket精度内的expirationTime，输入不同的expirationInMs,bucketSizeMs参数可以定义不同优先级的expirationTime function computeExpirationBucket( currentTime, expirationInMs, bucketSizeMs, ): ExpirationTime { return ( MAGIC_NUMBER_OFFSET - ceiling( MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE, ) ); } export const LOW_PRIORITY_EXPIRATION = 5000; export const LOW_PRIORITY_BATCH_SIZE = 250; // 计算异步事件过期时间，异步事件的优先级比较低 export function computeAsyncExpiration( currentTime: ExpirationTime, ): ExpirationTime { return computeExpirationBucket( currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE, ); } export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150; export const HIGH_PRIORITY_BATCH_SIZE = 100; // 计算交互事件过期时间，用户交互事件的优先级比较高 export function computeInteractiveExpiration(currentTime: ExpirationTime) { return computeExpirationBucket( currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE, ); } // 根据过期时间获取当前优先级， 立即执行，还是普通优先级还是用户交互优先级 export function inferPriorityFromExpirationTime( currentTime: ExpirationTime, expirationTime: ExpirationTime, ): ReactPriorityLevel { if (expirationTime === Sync) { return ImmediatePriority; } if (expirationTime === Never) { return IdlePriority; } const msUntil = msToExpirationTime(expirationTime) - msToExpirationTime(currentTime); if (msUntil &lt;= 0) { return ImmediatePriority; } if (msUntil &lt;= HIGH_PRIORITY_EXPIRATION) { return UserBlockingPriority; } if (msUntil &lt;= LOW_PRIORITY_EXPIRATION) { return NormalPriority; } return IdlePriority; } computeExpirationForFiber我们再回到 updateContainer 继续执行到 computeExpirationForFiber 传的参数是当前时间还有fiber function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) { let expirationTime; // 一开始 expirationContext = Nowork if (expirationContext !== NoWork) { expirationTime = expirationContext; } else if (isWorking) { if (isCommitting) { // 在提交阶段发生的更新应具有同步优先级 expirationTime = Sync; } else { // 更新阶段和渲染阶段的过期时间应该一样 expirationTime = nextRenderExpirationTime; } } else { // 计算新的过期时间 if (fiber.mode &amp; ConcurrentMode) { if (isBatchingInteractiveUpdates) { // 交互事件 expirationTime = computeInteractiveExpiration(currentTime); } else { // 异步事件，计算新的过期时间 expirationTime = computeAsyncExpiration(currentTime); } // 如果我们正在渲染树，请不要在已经渲染的到期时间进行更新。 if (nextRoot !== null &amp;&amp; expirationTime === nextRenderExpirationTime) { expirationTime -= 1; } } else { // 同步时间 expirationTime = Sync; } } if (isBatchingInteractiveUpdates) { // 跟踪最短的未执行互式到期时间。 if ( lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime &lt; lowestPriorityPendingInteractiveExpirationTime ) { lowestPriorityPendingInteractiveExpirationTime = expirationTime; } } return expirationTime; } updateContainerAtExpirationTimeexport function updateContainerAtExpirationTime( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component&lt;any, any>, expirationTime: ExpirationTime, callback: ?Function, ) { // 一样是fiber const current = container.current; // 获取 context 并赋值，这里肯定取不到值得，因为 parentComponent 为 null const context = getContextForSubtree(parentComponent); if (container.context === null) { container.context = context; } else { container.pendingContext = context; } return scheduleRootUpdate(current, element, expirationTime, callback); } scheduleRootUpdate 下面开始调度了 function scheduleRootUpdate( current: Fiber, element: ReactNodeList, expirationTime: ExpirationTime, callback: ?Function, ) { // 创建一个 update，就是内部有几个属性的对象 const update = createUpdate(expirationTime); // Caution: React DevTools currently depends on this property // being called \"element\". update.payload = {element}; // 我们的 callback 是null的所以直接不用考虑二楼 flushPassiveEffects(); // 把 update 入队，内部就是一些创建或者获取 queue（链表结构），然后给链表添加一个节点的操作 enqueueUpdate(current, update); scheduleWork(current, expirationTime); return expirationTime; }","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"React基础","slug":"react基础","date":"2020-07-21T02:11:25.000Z","updated":"2023-02-14T15:19:27.732Z","comments":true,"path":"2020/07/21/react基础/","link":"","permalink":"http://yoursite.com/2020/07/21/react%E5%9F%BA%E7%A1%80/","excerpt":"","text":"React 创建组件的方式 React.creactClass (已弃用) Class 的方式创建组件 纯函数的方式创建组件，即我们常说的Function Component 这里主要介绍Class 跟 Function Component 两种方式 Classclass 是有生命周期的概念的 挂载的时候的生命周期： constructor -&gt; render -&gt; componentDidMount 更新时的生命周期： getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render -&gt; componentDidUpdate import React, { Component, PureComponent } from 'react'; Class Home extends Component { constructor(props) { super(props); this.state = { count: 1 } } /** * 一般我们这里会做数据请求 */ componentDidMount() {} componentDidUpdate() {} /** * * 这里一般我们会做一些优化， 比如减少重复渲染。 * 父组件的state修改的话，会引起子组件的重新render, 但是当前子组件并没有依赖这个state，就可以用这个函数判断了 * 要是优化的话 可以使用 PureComponent , 她会会我们的props 进行浅比较 * @return boolean */ shouldComponentUpdate(nextProps, nextState) {} /** * 这个生命周期时组件准备卸载了 * 这里可以对一些定时器，订阅等等做取消 */ componentWillUnmount() {} /** * 这个方法无论是props 更新或者state更新都会进入到这个静态函数 * 返回一个对象， 当前的对象就是state， * 如果返回null，那不对state做任何操作 */ static getDerivedStateFromProps(nextProps, prevState) {} add = () => { // 要注意的是 这个setState 修改的state 并不是立刻修改的， this.setState({ count: this.state.count + 1 }) } render() { return ( &lt;> &lt;div>state: {this.state.count}&lt;/div> &lt;div onClick={this.add}>+&lt;/div> &lt;div>props: {this.props.value}&lt;/div> &lt;/> ) } } 注意： 在class 组件下 只能够用setState 去修改state的数据， 它不像vue 那样可以直接修改数据。 setStatesetState 有两个参数， 一般我们会这么写 // 一般我们会这么写 this.setState({ str: '123' }) // 但实际上callback 还有另一个参数, callback this.setState({ str: '123' }, () => { console.log(\"callback\") }} // 另外我们setState 也可以用方法 this.setState((prevState) => ({ count: prevState.count + 1 })) propsreact 的 props 跟 vue 的 props 的传递方式大致一样，也是从父组件传props &lt;Home value=\"hello world\"> 高级用法HOCHOC 就是一个高阶组件， 简单说就是传入一个组件， 返回一个组件的函数。它可以做到以下几点 劫持渲染 劫持props // 比如一个简单的loading组件， 当你要为你已经写过的组件增加一个loading状态的时候，此时可以用HOC const HOC = (Component) => { return class extends Component { render() { const { loading, ...rest } = this.props; if(!loading) return \"loading...\"; return &lt;WrappedComponent {...rest} /> } } } // 使用 const EnhanceHoc = HOC(Home); render Props用的比较多的一种方式是Mdoal 框 或者 Drawer ， 虽然有很多UI 框架帮我们封装好Modal框，但有时候还要写visible, 关闭方法等等，就有点烦，这时候就可以用render Props const CustomModal = ({visible, cancel}) => { return ( &lt;Modal visible={visible} onCancel={cancel} > Hello World &lt;/Modal> ) } // modalContainer实现 class ModalContainer extends Component { state = { visible: false } handleCancel = () => { this.setState({ visible: false }) } show = () => { this.setState({ visible: true }) } render() { const { visible } = this.state; const { children } = this.props; return ( children({ visible: visible, show: this.show, cancel: this.handleCancel }) ) } } //使用 class App extends Component { render() { return ( &lt;div> &lt;ModalContainer> ({visible, show, cancel}) => ( &lt;> &lt;CustomModal visible={visible} cancel={cancel}>&lt;/CustomModal> &lt;Button type=\"primary\" onClick={show}> Click &lt;/Button> &lt;/> ) &lt;/ModalContainer> &lt;/div> ) } } react HooksuseState简单说 类似class 组件上面的 this.setState const Home = () => { // useState 的参数可以是简单类型， 也可以是方法 const [count, setCount] = useState(0); const [toggle, setToggle] = useState(false); const increment = () => { setCount(count++); } const handleToggle = () => { // setToggled 参数也可以用function // setToggle((prevState) => nextState); setToggled(toggled => !toggled); } return ( &lt;> &lt;button onClick={increment}>&lt;/button> &lt;div>{count}&lt;/div> &lt;div onClick={handleToggle}>{toggle}&lt;/div> &lt;/> ) } useEffect在Function Component 中, 是没有 生命周期的概念的，那么请求数据的时候就用到了useEffect,但是useEffect 其实包含3个生命周期 componentDidMount, componentDidUpdate, componentWillUnmount注意： 不能在 if/else 或者是for循环中使用useEffect const Home = () => { const [loading, setLoading] = useState(false); /** * useEffect 提供两个参数， 一个是回调函数， 一个是依赖数组， * 当第二参数不填的时候， 一旦state变化的时候， 就会执行这个函数 * 当第二个参数为 [] 空数组时， 就等同于 class组件的 componentDidMount * 当第二个参数为[loading]， 代表只有loading 发生变化是，回调函数才会执行 */ useEffect(() => { // 函数执行 return () => {} }, []) return ( &lt;> &lt;button onClick={increment}>&lt;/button> &lt;div>{count}&lt;/div> &lt;div onClick={handleToggle}>{toggle}&lt;/div> &lt;/> ) } useCallBackuseCallback 简单来说就是对我们的方法，进行缓存，达到一个性能优化的效果用的最多场景的是从父组件传方法给子组件，这时就可以用useCallback 了 子组件onChange调用了父组件的handleOnChange父组件handleOnChange内部会执行setText(e.target.value)引起父组件更新父组件更新会得到新的handleOnChange，传递给子组件，对于子组件来说接收到一个新的props子组件进行不必要更新 const Child = React.memo((props) => { console.log(props); return ( &lt;div> &lt;input type=\"text\" onChange={props.onChange}/> &lt;/div> ) }) const Parent = () => { const [count, setCount] = useState(0) const [text, setText] = useState('') const handleOnChange = useCallback((e) => { setText(e.target.value) },[]) return ( &lt;div> &lt;div>count: {count}&lt;/div> &lt;div>text: {text}&lt;/div> &lt;button onClick={() => setCount(count + 1)}>+1&lt;/button> &lt;Child onChange={handleOnChange} /> &lt;/div> ) } demo 上面例子可以看到父组件虽然更新了，但子组件没有重新render 但注意的是 有时候useCallback 也会有可能触发无限循环。 用ruseReducer（解决） useMemo跟useCallback 差不多，但是useCallback 缓存函数， useMemo 缓存值， 有点像 vue的 computed useRef是一个一直会变的对象，他有一个.current 属性，可以保存dom, 可以是方法，等等 useReducer这个其实跟redux 的reducer 有点相似，在定义的state之后，只能通过dispatch 触发对应的reducer事件（Actions）更新state简单理解 ： state -> UI -> 用户触发事件 执行action ^ | | | ------------------ 看看官方的例子吧! useContextimport React, { createContext, useContext, useState } from \"react\"; const MenuContext = createContext({ index: 0 }); export default function App() { return ( &lt;div> &lt;Menu defaultIndex={0}> &lt;MenuItem index={0}>menu1&lt;/MenuItem> &lt;MenuItem index={1}>menu2&lt;/MenuItem> &lt;MenuItem index={2}> menu3&lt;/MenuItem> &lt;/Menu> &lt;/div> ); } const Menu = (props) => { const { defaultIndex, onSelect } = props; const [currentActive, setActive] = useState(defaultIndex); const handleClick = (index) => { setActive(index); if (onSelect) { onSelect(index); } }; const Icontext = { index: currentActive || 0, onSelect: handleClick }; return ( &lt;ul> &lt;MenuContext.Provider value={Icontext}> {props.children} &lt;/MenuContext.Provider> &lt;/ul> ); }; const MenuItem = (props) => { const { children, index } = props; const itemContext = useContext(MenuContext); const handleClick = () => { if (itemContext.onSelect) { itemContext.onSelect(index); } }; return ( &lt;li onClick={handleClick}> {itemContext.index === index ? &lt;a>active &lt;/a> : null} {children} &lt;/li> ); }; 测试一下 进阶 自动配置index就是 React.Children.map ，以及React.cloneElement import React, { createContext, useContext, useState } from \"react\"; const MenuContext = createContext({ index: 0 }); export default function App() { return ( &lt;div> &lt;Menu defaultIndex={0}> &lt;MenuItem>menu1&lt;/MenuItem> &lt;MenuItem>menu2&lt;/MenuItem> &lt;MenuItem> menu3&lt;/MenuItem> &lt;/Menu> &lt;/div> ); } const Menu = (props) => { const { defaultIndex, onSelect } = props; const [currentActive, setActive] = useState(defaultIndex); const handleClick = (index) => { setActive(index); if (onSelect) { onSelect(index); } }; const Icontext = { index: currentActive || 0, onSelect: handleClick }; const childrenRender = () => { return React.Children.map(props.children, (child, index) => { if (child.type.displayName === \"MenuItem\") { return React.cloneElement(child, { index: index }); } }); }; return ( &lt;ul> &lt;MenuContext.Provider value={Icontext}> {childrenRender()} &lt;/MenuContext.Provider> &lt;/ul> ); }; const MenuItem = (props) => { const { children, index } = props; const itemContext = useContext(MenuContext); const handleClick = () => { if (itemContext.onSelect) { itemContext.onSelect(index); } }; return ( &lt;li onClick={handleClick}> {itemContext.index === index ? &lt;a>active &lt;/a> : null} {children} &lt;/li> ); }; MenuItem.displayName = \"MenuItem\"; 测试一下; hooks学习 redux, mobx余着","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"两数之和 II - 输入有序数组","slug":"两数之和-II-输入有序数组","date":"2020-07-20T08:06:00.000Z","updated":"2023-02-14T15:19:27.734Z","comments":true,"path":"2020/07/20/两数之和-II-输入有序数组/","link":"","permalink":"http://yoursite.com/2020/07/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"两数之和 II - 输入有序数组 题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明： 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 代码/** * @param {number[]} numbers * @param {number} target * @return {number[]} */ var twoSum = function(numbers, target) { let start = 0; let end = numbers.length - 1; while(start &lt; end) { const temp = numbers[start] + numbers[end] if(temp === target) { return [start + 1, end + 1]; } // 2 + 15 > 9 因为是有序的所以, 应该从 end 减小 if(temp > target) { end--; } else { // 如果target = 22, // 2 + 15 &lt; 22 那么应该从start 往后移动 start++ } } return [start + 1, end + 1] };","categories":[],"tags":[{"name":"algorithm-双指针","slug":"algorithm-双指针","permalink":"http://yoursite.com/tags/algorithm-%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"删除链表的倒数第N个节点","slug":"删除链表的倒数第N个节点","date":"2020-07-20T07:10:32.000Z","updated":"2023-02-14T15:19:27.734Z","comments":true,"path":"2020/07/20/删除链表的倒数第N个节点/","link":"","permalink":"http://yoursite.com/2020/07/20/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"删除链表的倒数第N个节点 题目描述删除链表中倒数的第n个节点 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 分析 先遍历一次获得链表长度length 然后length - n 获取target, 当前target &lt; 0 时， p-&gt;next = p-&gt;next-&gt;next 源码/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ var removeNthFromEnd = function(head, n) { let root = new ListNode(\"head\"); root.next = head; let getLengthsPointer = head; let nums = 0; while(getLengthsPointer) { nums++; getLengthsPointer = getLengthsPointer.next; } let pointer = root; let target = nums - n; while(pointer) { target--; if(target &lt; 0) { pointer.next = pointer.next.next ? pointer.next.next : null; break; } pointer = pointer.next } return root.next; }; 进阶一次遍历, 思想： 用双指针，第一个指针与第二个指针 相隔n, 当第一个指针到达结尾时，那么第二个指针也到了倒数第n个数的前一个了。我们用上面 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 走一遍， n 为2 first 指向 3 , second 指向 head， 同时向后移动 当first 指向到 null的时候，second 走到了 3，此时可以将second.next 指向 second.next.next var removeNthFromEnd = function(head, n) { let root = new ListNode(\"head\"); root.next = head; let first = root; let second = root; for (let i = 1; i &lt;= n + 1; i++) { first = first.next; } while (first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; }","categories":[],"tags":[{"name":"algorithm-双指针","slug":"algorithm-双指针","permalink":"http://yoursite.com/tags/algorithm-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"algorithm-链表","slug":"algorithm-链表","permalink":"http://yoursite.com/tags/algorithm-%E9%93%BE%E8%A1%A8/"}]},{"title":"搜索插入位置","slug":"搜索插入位置","date":"2020-07-17T06:47:33.000Z","updated":"2023-02-14T15:19:27.742Z","comments":true,"path":"2020/07/17/搜索插入位置/","link":"","permalink":"http://yoursite.com/2020/07/17/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"35. 搜索插入位置 题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例： 输入: [1,3,5,6], 0输出: 0 思想 因为是有序的数组，所以我们可以使用二分法找到插入的位置 代码var searchInsert = function(nums, target) { // 二分查找 let left = 0; let right = nums.length - 1; while(left &lt; right) { let m = Math.floor( (right + left) / 2 ); if(nums[m] == target) { return m; } if(target &lt; nums[m]) { right = m - 1; } else { left = m + 1; } } let mid = Math.floor((right + left) / 2); mid = mid > 0 ? mid : 0; // 为了解决负数问题 // 最后我们已经知道了左边跟右边的边界了，然后我们用target 比对一下 nums[mid] 就知道是放在当前位置还是放在后面一个位置了 return target > nums[mid] ? mid + 1 : mid ; };","categories":[],"tags":[{"name":"algorithm-二分法","slug":"algorithm-二分法","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%88%86%E6%B3%95/"}]},{"title":"不同的二叉搜索树","slug":"不同的二叉搜索树","date":"2020-07-17T01:48:21.000Z","updated":"2023-02-14T15:19:27.733Z","comments":true,"path":"2020/07/17/不同的二叉搜索树/","link":"","permalink":"http://yoursite.com/2020/07/17/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"96. 不同的二叉搜索树 题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3搜索二叉树搜索二叉树： 左节点比根节点要小， 根节点永远比右节点要小。 左 &lt; 根 &lt; 右 思路 我们以 n = 5 为例子, [1, 2, 3, 4, 5] 当以3为根节点时， 根据左节点永远比根节点小， 那么左节点只能为 [1,2], 右节点为 [4, 5] 当 [1,2] 为左节点时, 又分成了两种情况， 当1为根节点时，2 为右节点；当 2 为根节点时， 1为左节点 当 [4,5] 为右节点时，跟上面类似 当以2 为根节点时，那么 左节点只有为 [1], 右节点为 [3,4,5] [3,4,5] 又可以以 3 或 4 或 5 做为根节点分析 3 为根节点 的时候为两种 4 为根节点的时候有一种 5 为根节点的时候又两种 所以你会发现节点有两个的时候 f(2) = 2; f(1) = 1, 左右节点相乘就可以得到总数了所以f(2) = f(0) * f(1) + f(1) * f(0)f(3) = f(0) * f(2) + f(1) * f(1) + f(2) * f(0)f[4] = f(0) * f(3) + f(1) * f(2) + f(2) * f(1) + f(3) * f(0) 代码var numTrees = function(n) { const dp = new Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i &lt;= n; ++i) { for (let j = 1; j &lt;= i; ++j) { dp[i] += dp[j - 1] * dp[i - j]; } } return dp[n]; };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"三角形最小路径和","slug":"三角形最小路径和","date":"2020-07-16T05:39:54.000Z","updated":"2023-02-14T15:19:27.733Z","comments":true,"path":"2020/07/16/三角形最小路径和/","link":"","permalink":"http://yoursite.com/2020/07/16/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","excerpt":"","text":"120. 三角形最小路径和 题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。我们用triangle 表示当前数组 i\\k k = 0 k = 1 k = 2 k = 3 i = 0 2 i = 1 3 4 i = 2 6 5 7 i = 3 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 思路这道题用动态规划，我一开始的想法是用一位数组的动态规划，后来提交发现失败了， 一开始想的递推公式是 dp[i + 1] = d[i] + Math.min(triangle[i][j], triangle[i][j + 1])后来发现是一个二维数组的动态规划 二维数组动态规划, 用dp 表示结果集 我们以 i 作为行, k 作为列， 注意题目的相邻节点 我们发现 当 k = 0 时, 那么他当前dp 值 应该是 dp[i][k] = dp[i-1][k] + triangle[i][k], dp[i][k] 因为 k = 0, 它只能从上往下走 我们看第三行即 i = 2时, 看 k = 1, dp[i][k] = triangle[i][k] + Math.min(dp[i - 1][k], dp[i - 1][k - 1]), 当 0 &lt; k &lt; column时我们dp[i][k] 应该 是用左上角的dp, 即dp[i - 1][k - 1]跟正上方的dp值，即dp[i - 1][k]取最小值 加上triangle[i][k] 同样是第三行即 i = 2时，看 k = 2, dp[i][k] = triangle[i][k] + dp[i - 1][k - 1], 此时 只能斜着走 即 2 -&gt; 4 -&gt; 这样走 dp 结果 i\\k k = 0 k = 1 k = 2 k = 3 i = 0 2 i = 1 5 6 i = 2 11 10（这里左上跟正上对比，取小的那个跟triangle相加） 13（这里只能斜着走，取6） i = 3 15 11 18 16 最后取最后一行的最小那个即可 代码var minimumTotal = function(triangle) { // dp[i + 1] = d[i] + Math.min(triangle[i][j], triangle[i][j + 1]) let i = 0; let dp = [] let row = triangle.length; while(i &lt; row) { let column = triangle[i].length; // 获取当前行的列数 let dpColumn = [] for(let k = 0; k &lt; column; k++) { if(k == 0) { // 列 = 0 时只能向下走， dpColumn.push(i == 0 ? triangle[i][k] : dp[i - 1][k] + triangle[i][k]) } else if(k &lt; column - 1) { // 列是中间列的话，就从正上方 或者左上方 dpColumn.push(Math.min(dp[i - 1][k], dp[i - 1][k - 1]) + triangle[i][k]); } else { // 最后一列的时候只能够斜着走 dpColumn.push(dp[i - 1][k - 1] + triangle[i][k]) } } dp.push(dpColumn); i++; } return Math.min.call(null, ...dp[i - 1]); };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"两个数组的交集 II","slug":"两个数组的交集-II","date":"2020-07-13T03:06:04.000Z","updated":"2023-02-14T15:19:27.734Z","comments":true,"path":"2020/07/13/两个数组的交集-II/","link":"","permalink":"http://yoursite.com/2020/07/13/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II/","excerpt":"","text":"两个数组的交集 II 题目描述就是给两个数组，求出他们的交集。 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 思路 使用map 记录其中一个数组数值出现的次数。 遍历另一个数组，判断当前数字是否在map中，是的话添加到结果集中，并且当前map[number] 的值减1， 不是的话，那代表不是交集 var intersect = function(nums1, nums2) { let result = []; let map = new Map(); for(let i = 0; i &lt; nums1.length; i++) { if(map.has(nums1[i])) { map.set(nums1[i], map.get(nums1[i]) + 1) } else { map.set(nums1[i], 1) } } for(let j = 0; j &lt; nums2.length; j++ ) { // 判断当前数字是否在map 中，并且当前map的值是否大于0， 大于0的意思是：map 中还有 没有取交集的数 if(map.has(nums2[j]) &amp;&amp; map.get(nums2[j]) > 0 ) { result.push(nums2[j]); map.set(nums2[j], map.get(nums2[j]) - 1) } } return result; }; 进阶 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 这里只给一个想法吧，既然数组已经排序好了， 那我们就使用双指针的方法去解决这个问题，一个数组一个指针，如果两个指针所指的数相等，那么两个指针向后移，不相等的话判断哪个数值比较大，小的那个向后移，如此类推","categories":[],"tags":[{"name":"algorithm-map","slug":"algorithm-map","permalink":"http://yoursite.com/tags/algorithm-map/"}]},{"title":"面试题 17.13. 恢复空格","slug":"面试题-17-13-恢复空格","date":"2020-07-11T02:51:30.000Z","updated":"2023-02-14T15:19:27.747Z","comments":true,"path":"2020/07/11/面试题-17-13-恢复空格/","link":"","permalink":"http://yoursite.com/2020/07/11/%E9%9D%A2%E8%AF%95%E9%A2%98-17-13-%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"面试题 17.13. 恢复空格 题目描述给定一个字典 dictionary 和 一串字符串sentence， 在这串字符串中尽可能多的从字典中找到相应的值，返回未识别的字符 输入：dictionary = [“looked”,”just”,”like”,”her”,”brother”]sentence = “jesslookedjustliketimherbrother”输出： 7解释： 断句后为”jess looked just like tim her brother”，共7个未识别字符。 解题思路 一开始想的是 根据我们现实生活中这样查字典这样，比如 looked, 先翻到L如果字典有l 开头的那再找 o 如果没有那直接退出，这时候就要构建字典树 我们直接遍历字符串sentence, 然后 跟字典里的那些 词对比一下，然后最小的那个就可以了 我们以 sentence = &#39;jelookedss&#39;, dictionary = [&quot;looked&quot;] 为例子 dp: i 0 1 2 3 4 5 6 7 8 9 10 sentence j e l o o k e d s s dp[] 0 1 2 3 4 5 6 7 2 3 4 请注意我们dp[0] = 0 所以dp[1] 对应的应该是 sentence[0], 就是后移了一位看上面的图，当我们i = 7 的时候 我们找到了looked，这是我们字典里的，所以我们dp[7+1] 的值应该是dp[2] =&gt; dp[7 - 6 + 1] 即 sentence[1] 的时候，因为前面的都是在字典中找不到的,替代公式： 要是找到的情况下 dp[i + 1] = Math.min(dp[i + 1], dp[i - 字典词长度 + 1]) 动态规划var respace = function(dictionary, sentence) { let dp = [0]; let length = sentence.length; if(dictionary.length == 0) { return length; } for(let i = 0; i &lt; length; i++) { dp[i + 1] = dp[i] + 1; for(let j = 0; j &lt; dictionary.length; j++ ) { const l = dictionary[j].length if(dictionary[j] == sentence.substring(i - l + 1 , i + 1 )) { dp[i + 1] = Math.min(dp[i + 1], dp[i - l + 1] ); } } } return dp[length]; }; 字典树var respace = function(dictionary, sentence) { let cache = [] for (let j = 0;j &lt; sentence.length + 1;j ++) { cache.push(new Map) } let dp = new Array(sentence.length+1).fill(0); let trie = {}; let n = sentence.length; if (sentence === \"\") return 0; // 构建字典树 for(let word of dictionary) { let node = trie; for(let c of word) { if (node[c] == undefined) { node[c] = {} } node = node[c]; } node[\"#\"] = \"#\"; } // 预处理出字典中存在的所有下标区间 cache[j].get[k] == true 表示[k,j]区间的单词在字典中能找到。 // 我们寻找字典开头，要是选找到开头的话继续往下找字典，要是遇到 # 那么就结束了，对于每个字符都是都一样，最后记录当前位置字符到字典结束的长度 for(let i = 1; i &lt;= n; i++) { let node = trie; for(let j = i; j &lt;= n; j++) { let c = sentence[j-1]; if (!node[c]) { break; } node = node[c]; if (node['#'] != undefined) { cache[j].set(i, true); } } } for (let j = 1;j &lt;= n;j ++) { dp[j] = dp[j-1] + 1; for(let [k,v] of cache[j]){ dp[j] = Math.min(dp[j], dp[k-1]) } } return dp[n]; };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Hexo自定义案例","slug":"hexo自定义","date":"2020-07-09T06:54:57.000Z","updated":"2023-02-14T15:19:27.731Z","comments":true,"path":"2020/07/09/hexo自定义/","link":"","permalink":"http://yoursite.com/2020/07/09/hexo%E8%87%AA%E5%AE%9A%E4%B9%89/","excerpt":"","text":"我使用的主题是chic 修改主题markdown的高亮代码我当前使用的主题是不支持jsx的，所以对于react代码不能友好支持。所以使用hexo-prism-plugin修改了高亮部分 坑: 我安装了 hexo-prism-plugin 之后发现还是无法高亮 jsx 代码， 后来发现还要要安装 hexo-inject 模块 npm install hexo-prism-plugin hexo-inject --save 修改_config.yml highlight: enable: false # 关闭默认的highlight prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'base16-ateliersulphurpool.light' # 主题 line_number: false # default false # custom_css: 'path/to/your/custom.css' 为主题图片添加大图主题无法对图片进行放大，图片最大也只是 780 * 562, 体验上不是很好，这里我使用了fancybox 进行修改 下载fancybox的文件 将 jquery.fancybox.min.js, jquery.min.js 放入 theme/chic/source/js 目录下 将 jquery.fancybox.min.css 放入 theme/chic/source/css/_lib/目录下 修改 chic/_config.yml, 添加代码 fancybox: enable: true jquery: /js/jquery.min.js fancyjs: /js/jquery.fancybox.min.js 修改 Chic/layout/_partial/head.ejs 添加以下代码 &lt;% if(theme.fancybox.enable!==null&amp;&amp;theme.fancybox.enable===true){ %> &lt;script type=\"text/javascript\" src=\"&lt;%- url_for(theme.fancybox.jquery) %>\">&lt;/script> &lt;script type=\"text/javascript\" src=\"&lt;%- url_for(theme.fancybox.fancyjs) %>\">&lt;/script> &lt;% } %> 在 Chic/source/css/style.styl 添加, @import \"_lib/jquery.fancybox.min.css\" 这里添加css 不知道为什么不可以直接 跟上面添加js 一样，我找了很久都没找到解决方案，只能够在style 下强行添加css 最后在 source/js/script.js 的document.ready()的回调回调函数添加 以下代码就可以 $(\"a.group\").fancybox({ 'transitionIn' : 'elastic', 'transitionOut' : 'elastic', 'speedIn' : 600, 'speedOut' : 200, 'overlayShow' : false }); 使用这里强行使用&lt;a class=&quot;group&quot;&gt;链接 包裹这img 表示使用fancybox &lt;a class=\"group\" rel=\"group1\" href=\"图片url\"> &lt;img src=\"图片url\" /> &lt;/a> 添加力扣页面 我这里是想自定义添加一个新的页面，主要放自己练习算法时的解题思路，叫力扣，但又不想跟原来发表的文章混在一起 添加文件夹 source/algorithm, 只有一个文件index.md # index.md --- title: 力扣 date: 2020-04-08 16:09:43 layout: algorithm --- 在Chic/layout 添加 algorithm.ejs &lt;%- partial('_page/algorithm', {pagination: config.archive, index: true}) %> 在Chic/layout/_page 添加 algorithm.ejs // Chic/layout/_page/algorithm.ejs &lt;div class=\"post-wrap algorithm-page archive\"> &lt;div class=\"tags-algorithm\"> // 这里就是算法 tag, 我只筛选出 tag包含 algorithm- 的那些 &lt;%site.tags.forEach(item=>{%> &lt;% if(item.name.includes(\"algorithm-\")) { %> &lt;a class=\"tags-item\" href=\"&lt;%-url_for(item.path)%>\">&lt;%- item.name.split(\"algorithm-\")[1] %>&lt;span class=\"nums\">&lt;%-item.length%>&lt;/%-item.length%>&lt;/span>&lt;/%->&lt;/a> &lt;% } %> &lt;%})%> 1 &lt; div> &lt;div class=\"\"archive\">\" 每页条数 &lt;% var perpage=\"config.algorithm_generator.per_page\" %> 这里我直接获取当前页面是第几页，没有page的话就是第一页 currentpage=\"url.match(/page\\/(.*)\\//)\" ? url.match( page\\ (.*)\\ )[1] : last_year=\"'';\" 然后我过滤掉 只是type=\"=\" 'algorithm'的那些文章， 这个type, 在我们新键文章的时候跟title，tag那些写在一起 posts=\"site.posts.filter((item)\" => item.type &amp;&amp; 'algorithm') 做一个排序, 按最新的排 posts.data=\"posts.data.sort((a,\" b)=\">\" b.date - a.date) 选择当前页面的文章 posts.slice((currentpage 1) * perpage, ).each(function (post) { cur_year=\"post.date.year();\" if(last_year !=\"=\" cur_year){ &lt;h3>&lt;%- %>&lt; h3> } &lt;article &lt;a href=\"\"&lt;%-\" url_for(post.path) %>\">&lt;%=\"post.title\" a> &lt;span date(post.date, theme.date_format) span> article> }) 分页 if(math.ceil(posts.length perpage) > &lt;nav &lt;%- paginator({ prev_next: false, end_size: 1, mid_size: 2, total: math.ceil(posts.length nav> div>&lt; code>&lt;/%})%>>&lt;/%>&lt;/%> 这里有个坑，我们点击 /algorithm/page/2 的时候会报当前页面存在，我通过 hexo-generator-category 找到类似的解决方案，我通过文档的生成器写了一个类似的解决方案 在 Chic/script 下添加 algorithm.js, 这里为了搞一个分页出来而已 var pagination = require('hexo-pagination'); // 要安装模块啊 hexo.extend.generator.register('algorithm', function(locals){ // 这里不能对locals.post 进行更改，一旦发生更改，网站变量 site.posts 的内容也会跟着更改，这里不知道是为什么，我纠结了很久 let allPost = locals.posts; return pagination('/algorithm', allPost, { perPage: this.config.algorithm_generator.per_page, // 在 _config.yml 添加 algorithm_generator: 配置 类似 category_generator layout: ['algorithm', 'archive', 'index'], // 如果algorith这个layout,没有就会用 archive， 如此类推 format: 'page' + '/%d/', data: { __index: true } }); }); 最后只要修改一下 Chic/layout/_page/archive.ejs 文件跟上面类似第三部就行了, 这里说一下 config ,可以从最外层 _config.yml进行配置 文章搜索 先执行 npm install hexo-generator-search -s, 这个插件是为了生成search.json, 他包含的是文章的基本信息 然后就是写 html 和 css了，我这里使用的是模态框，所以可以根据form 表单提交后唤出modal,然后进行ajax对search.json进行查询. 我们根据关键字对文章content进行匹配，匹配有的加入数组，然后对匹配成功的那些数据进行字符截取，另外对关键字做highlight操作 配置 _config.yml这里需要配置一下 root 下的 _config.yml, 添加以下代码 # search search: enable: true path: search.json field: post content: true 添加modal我这里直接写在了Chic/layout/layout.ejs, 我们只需要控制这个modal的display属性就好了 html&lt;!-- Chic/layout.ejs --> &lt;div id=\"u-search\"> &lt;div class=\"modal\"> &lt;div class=\"modal-header\"> &lt;div class=\"container\"> &lt;form id=\"u-search-modal-form\" class=\"u-search-modal-form\"> &lt;button type=\"submit\" class=\"form-submit-btn\"> &lt;img src=\"&lt;%- url_for(theme.searchImg) %>\" class=\"search-btn-img\" /> &lt;/button> &lt;input placeholder=\"搜索文章。。。\" class=\"form-input\" id=\"modal-form-input\"> &lt;/form> &lt;a class=\"modal-close\">x&lt;/a> &lt;/div> &lt;div class=\"search-loading\"> &lt;div class=\"search-loading-bar\">&lt;/div> &lt;/div> &lt;/div> &lt;div class=\"modal-body\"> &lt;!-- ul 格式如下 --> &lt;!-- &lt;ul class=\"modal-results\"> &lt;li class=\"result-item\"> &lt;a class=\"result-item-detail\"> &lt;span class=\"title\">页面配置&lt;/span> &lt;span class=\"content\"> content &lt;/span> &lt;/a> &lt;/li> &lt;/ul> --> &lt;/div> &lt;/div> &lt;div class=\"modal-overlay\">&lt;/div> &lt;/div> modal 样式我把他放在了Chic/source/css/_lib/search.css 这个要在 Chic\\source\\css\\style.styl 引用,添加代码 @import \"_lib/search.css\" 点击查看样式，这里是search.css 代码 #u-search { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; padding: 60px 20px; z-index: 1001; } #u-search .modal { position: fixed; height: 80%; width: 100%; max-width: 640px; left: 50%; top: 0; margin: 64px 0px 0px -320px; background: #fff; z-index: 3; border-radius: 4px; overflow: hidden; } #u-search .modal-header { position: relative; width: 100%; height: 64px; z-index: 3; border-top-left-radius: 4px; border-top-right-radius: 4px; font-size: 16px; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); background: #fff; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } #u-search .modal-header .container{ display: flex; flex-direction: row; align-items: center; padding: 0px; } #u-search .modal-header .container .u-search-modal-form { display: flex; flex-direction: row; align-items: center; flex: 1; } #u-search .u-search-modal-form .form-submit-btn { width: 50px; height: 64px; background: none; border: none; outline: none; margin: 0 5px 0 5px ; } #u-search .u-search-modal-form .form-submit-btn img { width: 33px; height: 33px; } #u-search .modal-header .container .u-search-modal-form .form-input { flex: 1; margin-right: 15px; border: none; padding: 10px 10px; outline: none; } #u-search .modal-header .modal-close { display: block; width: 55px; height: 64px; top: 0; right: 0; color: #2196f3; cursor: pointer; text-align: center; line-height: 64px; vertical-align: middle; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; z-index: 2; font-size: 22px; } #u-search .modal-header .search-loading { position: absolute; bottom: 0; left: 0; width: 100%; height: 2px; background: transparent; z-index: 1; } #u-search .modal-header .search-loading .search-loading-bar { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; position: relative; display: none; width: 0%; height: 100%; background: #2196f3; } #u-search .modal .modal-body { padding: 15px; height: calc(100% - 85px); overflow: auto; } #u-search .modal .modal-body::-webkit-scrollbar{ width: 5px; height: 5px; /**/ } #u-search .modal .modal-body::-webkit-scrollbar-track{ background: rgb(239, 239, 239); border-radius:2px; } #u-search .modal .modal-body::-webkit-scrollbar-thumb{ background: #bfbfbf; border-radius:10px; } #u-search .modal .modal-body::-webkit-scrollbar-thumb:hover{ background: #333; } #u-search .modal .modal-body::-webkit-scrollbar-corner{ background: #179a16; } #u-search .modal .modal-body .modal-results { list-style: none; padding-left: 0; margin: 0px; } #u-search .modal .modal-body .modal-results .result-item { padding: 15px; } #u-search .modal .modal-body .modal-results .result-item:hover { background: #e8f4fd; } #u-search .modal .modal-body .modal-results .result-item .result-item-detail { display: flex; flex-direction: column; } #u-search .modal .modal-body .modal-results .result-item .result-item-detail .title { color: #6e6e6e; font-weight: 700; font-size: 18px; margin-bottom: 10px; } #u-search .modal .modal-body .modal-results .result-item .result-item-detail .content { display: block; white-space: inherit; word-break: break-all; text-overflow: ellipsis; font-size: 14px; color: rgba(85,85,85,0.65); letter-spacing: 1px; user-select: none; } #u-search .search-keyword { color: #0c7cd5; text-decoration: underline; font-weight: bold; font-style:normal } #u-search .modal-body .no-result { display: flex; flex-direction: column; align-items: center; justify-content: center; } #u-search .modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1; } @media screen and (max-width: 680px) { #u-search { padding: 0px; display: none; } #u-search .modal { box-shadow: none; max-width: none; top: 0; left: 0; margin: 0; height: 100%; border-radius: 0; } #u-search .modal-header { border-radius: 0; padding: 0px; } } .modal-active { position: fixed; top: 0; left: 0; right: 0; bottom: 0; } /* 以下是搜索框 */ .search { margin-right: 6px; display: flex; flex-direction: row; align-items: center; } .search .form-search { padding: 10px 8px; } .search .form-search .input { display: block; line-height: 1.3; color: #555; background: #e8e8e8; padding: 5px 8px; box-shadow: none; box-sizing: border-box; font-size: 1rem; border-radius: 8px; border: none; outline: none; } .search .search-btn { width: 22px; height: 22px; line-height: 22px; margin-right: 5px; } .search .search-btn .search-btn-img { height: 100%; width: 100%; } @media screen and (max-width: 479px) { .navbar-mobile-right { display: flex; flex-direction: row; align-items: center; } .search .search-btn { cursor: pointer; } .search .form-search { display: none; } .mobile-search { position: absolute; top: 0px; left: 0px; right: 50px; padding-left: 15px; background: #fff; height: 80px; display: flex; flex-direction: row; margin-right: 15px; } .mobile-search .form-search { display: block; flex: 1; } .mobile-search .input { width: 100%; } } 增加搜索框我把该文件放在了 Chic/layout/_partial/search.ejs &lt;% if(config.search &amp;&amp; config.search.enable ) { %> &lt;div class=\"search \"> &lt;div class=\"search-btn\" onClick=\"searchToggle()\"> &lt;img src=\"&lt;%- url_for(theme.searchImg) %>\" class=\"search-btn-img\" /> &lt;/div> &lt;form class=\"form-search\"> &lt;input class=\"input\" placeholder=\"搜索文章\" autocomplete=\"off\" id=\"&lt;%= name %>-search-input\"/> &lt;/form> &lt;/div> &lt;% } %> 我们在 Chic\\layout\\_partial\\header.ejs 添加这个搜索框, 要在pc的menu, 和mobile的menu添加, &lt;% var defaultName = 'pc' %> &lt;%- partial('_partial/search', { name: defaultName }) %> // 这里是 mobile 的menu &lt;div class=\"navbar-mobile-right\"> &lt;% var type = 'mobile' %> &lt;%- partial('_partial/search', { name: type }) %> &lt;div class=\"menu-toggle\" onclick=\"mobileBtn()\">&amp;#9776; 目录&lt;/div> &lt;/div> 添加搜索框的js, 搜索代码创建搜索代码 点击查看代码 &lt;script> function searchToggle() { const width = $(document.body).width() if(width > 479) { return; } const search = $('.search'); const searchForm = $('.form-search') if(!search.hasClass(\"mobile-search\")) { search.addClass(\"mobile-search\"); } else { search.removeClass(\"mobile-search\"); } } function search(searchInputEl, formEl, flag) { const path = \"&lt;%= config.root %>\" + \"&lt;%= config.search.path %>\"; // 可以在public 下查看这个search.json $(formEl).submit(function(e){ e.preventDefault(); let target = null if(searchInputEl == null) { const screenWidth = $(document.body).width(); target = screenWidth > 479 ? $('#pc-search-input') : $('#mobile-search-input'); console.log(target); } else { target = $(searchInputEl) } if(!flag &amp;&amp; target.val() === '') { return ; } $(\"#u-search\").fadeIn(500, function() { $(\"body > .wrapper\").addClass(\"modal-active\"); $.ajax({ url: path, dataType: \"json\", beforeSend: function (xhr) { $input = target.val(); $(\".form-input\").val($input); const loadingBar = $('.search-loading-bar') loadingBar.css({ width:'100%', display: 'block' }); }, success: function( datas ) { // console.log(datas); const $resultPanel = $(\".modal-body\")[0]; let str = `&lt;ul class=\"modal-results\">`; var keywords = $(\".form-input\").val().trim().toLowerCase().split(/[\\s\\-]+/); $resultPanel.innerHTML = \"\"; let hasResult = false let text = `&lt;div class=\"no-result\">找不到与关键词相关的内容....&lt;/div>`; if ($(\".form-input\").val().trim().length &lt;= 0) { // 没有结果 $resultPanel.innerHTML = text; return; } datas.forEach(function (data) { var isMatch = true; if (!data.title || data.title.trim() === '') { data.title = \"Untitled\"; } var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^>]+>/g, \"\").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty contents if (data_content !== '') { keywords.forEach(function (keyword, i) { index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if (index_title &lt; 0 &amp;&amp; index_content &lt; 0) { isMatch = false; } else { hasResult = true if (index_content &lt; 0) { index_content = 0; } if (i == 0) { first_occur = index_content; } } }); } else { isMatch = false; } // show search results if (isMatch) { str += `&lt;li class='result-item'>&lt;a href='${data_url}' class='result-item-detail'> &lt;span class=\"title\">${data_title}&lt;/span>`; var content = data.content.trim().replace(/&lt;[^>]+>/g, \"\"); if (first_occur >= 0) { // cut out 200 characters var start = first_occur - 40; var end = first_occur + 160; if (start &lt; 0) { start = 0; } if (start == 0) { end = 200; } if (end > content.length) { end = content.length; } var match_content = content.substring(start, end); // highlight all keywords keywords.forEach(function (keyword) { var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, `&lt;em class=\"search-keyword\">${keyword}&lt;/em>`); }); str += `&lt;span class=\"content\"> ${match_content} ...&lt;/span>&lt;/a>`; } str += \"&lt;/li>\"; } }); str += \"&lt;/ul>\"; if(hasResult) { $resultPanel.innerHTML = str; } else { $resultPanel.innerHTML = text; } }, complete: function() { setTimeout(() => { const loadingBar = $('.search-loading-bar') loadingBar.css({ width:'0%', display: 'none' }); }, 300) } }); }) }); } $(document).ready(function() { $('.modal-close').click(function () { $(\"#u-search\").fadeOut(); $(\"body > .wrapper\").removeClass(\"modal-active\") }) $('.modal-overlay').click(function() { $(\"#u-search\").fadeOut(); $(\"body > .wrapper\").removeClass(\"modal-active\") }) search(null, \".form-search\", false) search(\"#u-search-modal-form .form-input\", \".u-search-modal-form\", true) }) &lt;/script> 在 themes\\Chic\\layout\\_partial\\head.ejs中添加上面的以下代码，表示启动js &lt;%# search %> &lt;% if(config.search &amp;&amp; config.search.enable ) { %> &lt;%- partial('_plugins/search.ejs') %> &lt;% } %> 以上就是创建搜索框的全过程了，当然了我上面写的有点乱，可以自行整理一下","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"路径总和","slug":"路径总和","date":"2020-07-07T03:02:09.000Z","updated":"2023-02-14T15:19:27.746Z","comments":true,"path":"2020/07/07/路径总和/","link":"","permalink":"http://yoursite.com/2020/07/07/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","excerpt":"","text":"题目描述1给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例1 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 [5,4,8,11,null,13,4,7,2, null, null,null,1]22 思想 注意：题目说了叶子节点是没有子节点的节点，那么我们只要判断一下当前节点有没有root.left 和 root.right 即可， 另外每次递归都减去当前target = sum - root.val, 然后递归左右子树就可以了 递归实现/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {number} sum * @return {boolean} */ var hasPathSum = function(root, sum) { if(root == null ) { return false; } const value = root.val; const target = sum - value; if(target == 0 &amp;&amp; (root.left == null &amp;&amp; root.right == null)) { return true; } return hasPathSum(root.left, target) || hasPathSum(root.right, target) };","categories":[],"tags":[{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"}]},{"title":"63. 不同路径 II","slug":"63-不同路径-II","date":"2020-07-06T06:53:49.000Z","updated":"2023-02-14T15:19:27.727Z","comments":true,"path":"2020/07/06/63-不同路径-II/","link":"","permalink":"http://yoursite.com/2020/07/06/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/","excerpt":"","text":"63. 不同路径 II 题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 分析题目说明每次 只能向下或者向右移动一步。那么我们分析每次走到a[m][n] 只能从上面那个格子a[m - 1][n] 或者从左边那个格子a[m][n - 1]过来，我们定义 a[m][n]是到当前格子的有多少种路径数。 所以我们的递推公式是： a[m][n] = a[m - 1][n] + a[m][n - 1]; 注意： 第一行我们只能向右走， 第一列只能向下走。 如果上面或者左边格子是障碍物， 那么当前格子应该是 0， 但其实也符合 a[m][n] = a[m - 1][n] + a[m][n - 1] 这个递推公式，这样我们判断格子是否是障碍物那么我们就设置为 0； 代码/** * @param {number[][]} obstacleGrid * @return {number} */ var uniquePathsWithObstacles = function(obstacleGrid) { let result = []; let row = obstacleGrid.length; let column = obstacleGrid[0].length // 递推公式是 result[i][j] = result[i][j - 1] + result[i - 1][j] for(let i = 0; i &lt; row; i++) { if(typeof result[i] == 'undefined') { result[i] = []; } for(let j = 0; j &lt; column; j++) { let temp = obstacleGrid[i][j] if(i === 0 &amp;&amp; j === 0) { result[i][j] = temp === 1 ? 0 : 1; } // 第一行只能向右走, 并且判断一下当前是不是障碍物，是的话那么走到当前路线的次数应该为0 if(i === 0 &amp;&amp; j > 0) { let tempLeft = obstacleGrid[i][j - 1]; result[i][j] = tempLeft || temp ? 0 : result[i][j - 1] ; } // 第一列只能向下走，并且判断一下当前是不是障碍物 if(j === 0 &amp;&amp; i > 0) { let tempUp = obstacleGrid[i - 1][j]; result[i][j] = (tempUp || temp ? 0 : result[i- 1][j]); } if(i > 0 &amp;&amp; j > 0) { const up = result[i - 1][j]; const left = result[i][j - 1]; result[i][j] = temp == 1 ? 0 : ( up + left); } } } return result[row - 1][column - 1] };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"108. 将有序数组转换为二叉搜索树","slug":"108-将有序数组转换为二叉搜索树","date":"2020-07-03T06:16:44.000Z","updated":"2023-02-14T15:19:27.727Z","comments":true,"path":"2020/07/03/108-将有序数组转换为二叉搜索树/","link":"","permalink":"http://yoursite.com/2020/07/03/108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"108. 将有序数组转换为二叉搜索树 题目描述将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例： 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / \\ / -10 n 5 我们再来看一个示例 示例2: nums = [1,2,3,4,5,6,7,8,9,10,11,12], length = 12 7 / \\ 4 10 / \\ / \\ 2 6 9 12 / \\ / \\ /\\ / 1 3 5 n 8 n 11 分析上面 n 代表的是null, 我们直接看示例2的根节点的排列情况 7 的index 为 Math.floor(nums.length / 2) 4 的index 为 1~7的一半， 我们称为左半边的一半 10 的index 为 8~12的一半，我们称为右半边的一半 所以我们总结上面获取根节点的情况是nums[Math.floor(nums.length / 2)],然后反复获取左右半数组进行截取，再获取根节点，这里是一次递归 当nums.length 为0 的时候，我们返回null 根节点的左边数组为左子节点，右数组为右子节点 我们模拟一下nums = [1,2,3]的时候 我们取root = new TreeNode(nums[Math.floor(nums.length / 2)])即为2当根节点。当前左数组为[1], 右半数组为[3] 左节点 应该是左半数组组成的左子树, 左半数组剩下[1], 当前子树root = new TreeNode(nums[Math.floor(nums.length / 2)]), 所以根节点为1, 而后当前左右数组都为[], 再来root.left = 回到第一步 当前数组的长度为0, 所以root.left = null, 所以整个流程是root = 2, root.left = 1, root.left.left = null 右节点跟左节点一样 源码/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ var sortedArrayToBST = function(nums) { //如果当前length 为奇数的话，那切一半，length / 2 + 1 为当前root，偶数为 length / 2 const root = half(nums) return root; }; var half = function(nums) { if(nums.length == 0) { return null } const currentIndex = Math.floor(nums.length / 2); const rootValue = nums[currentIndex]; const currentRoot = new TreeNode(rootValue) // 分治 let left = nums.slice(0, currentIndex); let right = nums.slice(currentIndex + 1); currentRoot.left = half(left); currentRoot.right = half(right); return currentRoot; }","categories":[],"tags":[{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"}]},{"title":"Z 字形变换","slug":"Z-字形变换","date":"2020-06-30T10:34:47.000Z","updated":"2023-02-14T15:19:27.729Z","comments":true,"path":"2020/06/30/Z-字形变换/","link":"","permalink":"http://yoursite.com/2020/06/30/Z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","excerpt":"","text":"Z 字形变换 其实这道题就是移到数学题 分析 以 LEETCODEISHIRING 为示例，分别对row = 3, row = 4, row = 5, 进行分析, 括号表示index row = 3 row/column c = 0 c = 1 c = 2 c = 3 c = 4 c = 5 c = 6 c = 7 r = 0 L(0) C(4) I(8) R(12) r = 1 E(1) T(3) O(5) E(7) S(9) I(11) I(13) G(15) r = 2 E(2) D(6) H(10) N(14) row = 4 row/column c = 0 c = 1 c = 2 c = 3 c = 4 c = 5 c = 6 r = 0 L(0) D(6) R(12) r = 1 E(1) O(5) E(7) I(11) I(13) r = 2 E(2) C(4) I(8) H(10) N(14) r = 3 T(3) S(9) G(15) row = 5 row/column c = 0 c = 1 c = 2 c = 3 c = 4 c = 5 c = 6 c = 7 r = 0 L(0) I(8) r = 1 E(1) E(7) S(9) G(15) r = 2 E(2) D(6) H(10) N(14) r = 3 T(3) O(5) I(11) I(13) r = 4 C(4) R(12) 我们看这三个 r = 0时，第一个数跟第二数的偏移， 我们称这个为总偏移量 row = 3时, 偏移为 4 - 0 = 4 row = 4时，偏移为 6 - 0 = 6 row = 5时，偏移为 8 - 0 = 8 总结： 偏移 = 2 * row - 2 再看 r = 1时，就是第二行数据， 第一个数跟第二个数以及第三个数的偏移 row = 3 时，偏移为 3 - 1 = 2， 5 - 3 = 2， 上面总偏移量为4，所以第3个数跟第2个数的偏移量为 4-2 =2 row = 4 时，偏移为 5 - 1 = 4， 7 - 5 = 2， 上面总偏移量为6，所以第3个数跟第2个数的偏移量为 6-4 =2。 这一行往后的偏移是 4, 2, 4, 2, 4, 2 这样走 row = 5 时，偏移为 7 - 1 = 6， 9 - 7 = 2， 上面总偏移量为8，所以第3个数跟第2个数的偏移量为 6-4 =2。 这一行往后的偏移是 6, 2, 6, 2, 6, 2 这样 直到前一个数 + 偏移量 &gt;= s.length换下一行。 总结：第一个数与第二个数偏移量为 2 * (row - (r + 1)), 而第二个数跟第三个数的偏移量为 （总偏移量 - 第一个数跟第二个数的偏移量） 往后如此类推，但最后一行跟第一行的偏移量应该一样 源码var convert = function(s, numRows) { let result = []; let length = s.length; if(numRows == 1) { return s; } let totalOffset = 2 * numRows - 2; // 总偏移量 let flag = true; // 标志位 let i = 0; // 表示数组中有几个数 let row = 1; // 表示 第几行 let start = 0; // 表示 当前index let offset = 2 * (numRows - row); while(i &lt; length) { result.push(s[start]); // 第一行的偏移量跟最后一行的偏移量一样 if(row == 1 || row == numRows) { start = start + totalOffset; } else { if(flag) { start = start + offset; flag = false; } else { start = start + (totalOffset - offset); flag = true; } } i++; // 换下一行，同时计算他的偏移值，把flag 重置 if(start >= length) { row++; start = row - 1; flag = true offset = 2 * (numRows - row); } } return result.join(\"\") };","categories":[],"tags":[{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"},{"name":"algorithm-数组","slug":"algorithm-数组","permalink":"http://yoursite.com/tags/algorithm-%E6%95%B0%E7%BB%84/"}]},{"title":"数组中的第K个最大元素","slug":"数组中的第K个最大元素","date":"2020-06-29T03:24:02.000Z","updated":"2023-02-14T15:19:27.742Z","comments":true,"path":"2020/06/29/数组中的第K个最大元素/","link":"","permalink":"http://yoursite.com/2020/06/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","excerpt":"","text":"数组中的第K个最大元素 题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 输入: [3,2,1,5,6,4] 和 k = 2输出: 5解释：排序后数组结果[1,2,3,4,5,6], 取第二大的那个数就是 5 分析 这个题目直接想就是数组通过排序后获取倒数第k个数 这里我使用快速排序 代码// 快速排序 function quicksort(nums, low, high) { let i; let j; let s; while (high > low) { i = low; j = high; s = nums[low]; while (i &lt; j) { while (nums[j] > s) { j--; } nums[i] = nums[j]; while (s >= nums[i] &amp;&amp; i &lt; j) { i++; } nums[j] = nums[i]; } nums[i] = s; quicksort(nums, low, i - 1); low = i + 1; } return nums; } var findKthLargest = function(nums, k) { const newNums = quicksort(nums, 0, nums.length - 1); return newNums[nums.length - k]; };","categories":[],"tags":[{"name":"algorithm-排序","slug":"algorithm-排序","permalink":"http://yoursite.com/tags/algorithm-%E6%8E%92%E5%BA%8F/"},{"name":"algorithm-快速排序","slug":"algorithm-快速排序","permalink":"http://yoursite.com/tags/algorithm-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"React源码-ReactDOM","slug":"React源码-ReactDOM","date":"2020-06-28T02:46:51.000Z","updated":"2023-02-14T15:19:27.728Z","comments":true,"path":"2020/06/28/React源码-ReactDOM/","link":"","permalink":"http://yoursite.com/2020/06/28/React%E6%BA%90%E7%A0%81-ReactDOM/","excerpt":"","text":"文件目录packages/react-dom/src/ReactDOM.js 用法ReactDOM.render(&lt;App />, document.getElementById(\"root\")); 源码ReactDOM.renderconst ReactDOM: Object = { /** * element => &lt;App /> * container => document.getElementById(\"root\") * callback => 回调函数 很少用 */ render( element: React$Element&lt;any>, container: DOMContainer, callback: ?Function, ) { // 下面第四个参数为false， 如果为true那么说明是服务端渲染 return legacyRenderSubtreeIntoContainer( null, element, container, false, callback, ); }; 先为container创建_reactRootContainer属性，其类型是ReactRoot, 同时在这一步中删除掉container中的所有子集 legacyRenderSubtreeIntoContainer/** * parentComponent => null * children => &lt;App> * container => document.getElementById(\"root\") * forceHydrate => false * callback => callback */ function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component&lt;any, any>, children: ReactNodeList, container: DOMContainer, forceHydrate: boolean, callback: ?Function, ) { let root: Root = (container._reactRootContainer: any); // 当前 container 没有 _reactRootContainer, 进去if操作执行legacyCreateRootFromDOMContainer if (!root) { // 初始化操作，创建_reactRootContainer属性， 类型是ReactRoot root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate, ); // 反正我从没传过 callback，不关心实现 if (typeof callback === 'function') { const originalCallback = callback; callback = function() { const instance = getPublicRootInstance(root._internalRoot); originalCallback.call(instance); }; } // Initial mount should not be batched. // 第一次加载的话不需要打包更新 unbatchedUpdates(() => { // 第一次不存在 parentComponent, 然后调用ReactRoot.prototype.render if (parentComponent != null) { root.legacy_renderSubtreeIntoContainer( parentComponent, children, callback, ); } else { root.render(children, callback); } }); } else { if (typeof callback === 'function') { const originalCallback = callback; callback = function() { const instance = getPublicRootInstance(root._internalRoot); originalCallback.call(instance); }; } // Update if (parentComponent != null) { root.legacy_renderSubtreeIntoContainer( parentComponent, children, callback, ); } else { root.render(children, callback); } } return getPublicRootInstance(root._internalRoot); } legacyCreateRootFromDOMContainer 该方法是删除container下的子节点，并且生成ReactRoot function legacyCreateRootFromDOMContainer( container: DOMContainer, forceHydrate: boolean, ): Root { // 这个变量跟服务端渲染有关，我们直接把他看成false const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); if (!shouldHydrate) { let rootSibling; // 这里直接把container的子节点删除，直到没有子节点 // &lt;div id=\"root\">&lt;/div> while ((rootSibling = container.lastChild)) { container.removeChild(rootSibling); } } // 默认情况下root不用异步 const isConcurrent = false; return new ReactRoot(container, isConcurrent, shouldHydrate); } ReactRoot 我们看ReactRoot这个结构函数 createContainer就是一行代码它的作用是创建FiberRoot, 而这个root 其实又是 FiberRootNode 然后创建Fiber, createFiber(HostRoot, null, null, mode);, 然后又返回了FiberNode, 此时container拥有_reactRootContainer属性, 而 _reactRootContainer 拥有 _internalRoot属性, 而_internalRoot又拥有current属性，这个属性类型就是FiberNode 我们可以在react 项目下 打印一下 document.getElementById(&quot;root&quot;)._reactRootContainer /** * container => &lt;div id=\"root\">&lt;/div> * isConcurrent => false * hydrate => false */ function ReactRoot( container: DOMContainer, isConcurrent: boolean, hydrate: boolean, ) { // 这个 root 指的是 FiberRoot // 文件路径 packages/react-reconciler/src/ReactFiberReconciler.js // createContainer 很简单就一行代码 // return createFiberRoot(containerInfo, isConcurrent, hydrate); const root = createContainer(container, isConcurrent, hydrate); this._internalRoot = root; } ReactRoot.prototype.render = function( children: ReactNodeList, callback: ?() => mixed, ): Work { // 这里就是之前的那个createFiberRoot创建的FiberRoot const root = this._internalRoot; // ReactWork 的功能就是为了在组件渲染或更新后把所有传入 // ReactDom.render 中的回调函数全部执行一遍 const work = new ReactWork(); callback = callback === undefined ? null : callback; // 如果有 callback，就 push 进 work 中的数组 if (callback !== null) { work.then(callback); } // work._onCommit 就是用于执行所有回调函数的 updateContainer(children, root, null, work._onCommit); return work; }; // 其实这里的名字已经表达了意思了，将subTree渲染进container ReactRoot.prototype.legacy_renderSubtreeIntoContainer = function( parentComponent: ?React$Component&lt;any, any>, children: ReactNodeList, callback: ?() => mixed, ): Work { const root = this._internalRoot; const work = new ReactWork(); callback = callback === undefined ? null : callback; if (callback !== null) { work.then(callback); } updateContainer(children, root, parentComponent, work._onCommit); return work; }; createContainerexport function createContainer( containerInfo: Container, isConcurrent: boolean, hydrate: boolean, ): OpaqueRoot { return createFiberRoot(containerInfo, isConcurrent, hydrate); } createFiberRootexport function createFiberRoot( containerInfo: any, isConcurrent: boolean, hydrate: boolean, ): FiberRoot { // FiberRootNode 内部创建了很多属性 const root: FiberRoot = (new FiberRootNode(containerInfo, hydrate): any); // document.getElementById(\"root\").._reactRootContainer._internalRoot 是 FiberRoot // document.querySelector('#root')._reactRootContainer._internalRoot.current 是 Fiber const uninitializedFiber = createHostRootFiber(isConcurrent); root.current = uninitializedFiber; uninitializedFiber.stateNode = root; return root; } createHostRootFiberexport function createHostRootFiber(isConcurrent: boolean): Fiber { let mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext; if (enableProfilerTimer &amp;&amp; isDevToolsPresent) { mode |= ProfileMode; } // HostRoot 指的是 classComponent, lazyComponent, functionCompoenent 等等 return createFiber(HostRoot, null, null, mode); } createFiber我们可以从 packages/react-reconciler/src/ReactFiber.js 查看Fiber 的属性 const createFiber = function( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ): Fiber { return new FiberNode(tag, pendingProps, key, mode); }; FiberRoot 的结构 点击查看FiberRoot type BaseFiberRootProperties = {| // Any additional information from the host associated with this root. // 就是 document.getElementById(\"root\") containerInfo: any, // 仅用于持久更新。 pendingChildren: any, // 当前应用对应的Fiber对象，是Root Fiber current: Fiber, // 以下优先级用于区分 // 1) 没有提交(committed)的任务 // 2) 没有提交的挂起任务 // 3) 没有提交的可能被挂起的任务 // 我们选择不追踪每个单独的阻塞登记，为了兼顾性能而是按交易粒度来衡量绩效。 earliestSuspendedTime: ExpirationTime, latestSuspendedTime: ExpirationTime, // The earliest and latest priority levels that are not known to be suspended. earliestPendingTime: ExpirationTime, latestPendingTime: ExpirationTime, // 最新通过的一个被reslove并且可以重新尝试的优先级 latestPingedTime: ExpirationTime, pingCache: | WeakMap&lt;Thenable, Set&lt;ExpirationTime>> | Map&lt;Thenable, Set&lt;ExpirationTime>> | null, // 如果抛出错误，并且队列中没有更多更新，则在处理该错误之前，我们尝试从根目录再次进行一次同步渲染。 didError: boolean, // 正在等待提交的任务的`expirationTime` pendingCommitExpirationTime: ExpirationTime, finishedWork: Fiber | null, // 超时的操作 timeoutHandle: TimeoutHandle | NoTimeout, // Top context object, used by renderSubtreeIntoContainer context: Object | null, pendingContext: Object | null, // Determines if we should attempt to hydrate on the initial mount +hydrate: boolean, // Remaining expiration time on this root. // TODO: Lift this into the renderer nextExpirationTimeToWorkOn: ExpirationTime, expirationTime: ExpirationTime, // List of top-level batches. This list indicates whether a commit should be // deferred. Also contains completion callbacks. // TODO: Lift this into the renderer firstBatch: Batch | null, // root之间关联的链表结构 nextScheduledRoot: FiberRoot | null, // New Scheduler fields callbackNode: *, callbackExpirationTime: ExpirationTime, firstPendingTime: ExpirationTime, lastPendingTime: ExpirationTime, pingTime: ExpirationTime, |}; type ProfilingOnlyFiberRootProperties = {| interactionThreadID: number, memoizedInteractions: Set&lt;Interaction>, pendingInteractionMap: PendingInteractionMap, |}; export type FiberRoot = { ...BaseFiberRootProperties, ...ProfilingOnlyFiberRootProperties, }; FiberRoot 的结构是上面两个合起来 Fiber 结构 点击查看Fiber export type Fiber = {| // 指的是functionComponent 还是 classComponent等等， lazyComponent tag: WorkTag, // Unique identifier of this child. key: null | string, // The value of element.type which is used to preserve the identity during // reconciliation of this child. elementType: any, // The resolved function/class/ associated with this fiber. type: any, // 本地相关联的Fiber stateNode: any, // 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回 return: Fiber | null, // 子节点，兄弟节点 child: Fiber | null, sibling: Fiber | null, index: number, // 就是ref ref: null | (((handle: mixed) => void) &amp; {_stringRef: ?string}) | RefObject, // 将要处理的props, 罪行的props pendingProps: any, // This type will be more specific once we overload the tag. // 上一次的props memoizedProps: any, // The props used to create the output. // A queue of state updates and callbacks. // 用来存放 update，也就是用来记录改变状态的 updateQueue: UpdateQueue&lt;any> | null, // 上一次的state memoizedState: any, // A linked-list of contexts that this fiber depends on contextDependencies: ContextDependencyList | null, mode: TypeOfMode, // Effect effectTag: SideEffectTag, // Singly linked list fast path to the next fiber with side-effects. nextEffect: Fiber | null, firstEffect: Fiber | null, lastEffect: Fiber | null, // Represents a time in the future by which this work should be completed. // Does not include work found in its subtree. expirationTime: ExpirationTime, // This is used to quickly determine if a subtree has no pending changes. childExpirationTime: ExpirationTime, alternate: Fiber | null, actualDuration?: number, actualStartTime?: number, selfBaseDuration?: number, treeBaseDuration?: number, |}; Fiber结构图 函数运行流程图 从demo查看","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"二进制求和","slug":"二进制求和","date":"2020-06-23T09:57:20.000Z","updated":"2023-02-14T15:19:27.734Z","comments":true,"path":"2020/06/23/二进制求和/","link":"","permalink":"http://yoursite.com/2020/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/","excerpt":"","text":"67. 二进制求和 题目描述给定两个二进制字符串，两个相加返回结果 输入: a = “1010”, b = “1011”输出: “10101” 解决方案将指针指向字符串最后一位，两两相加再加上仅为，注意处理进位，两字符串的当前值为1时 * 当前进位为0时，那么1 + 1 + 0 = 2 ，二进制要进位，当前值应该为2 % 2 = 0。进位变为1 * 当前仅为为1时，那么1 + 1 + 1 = 3 ，二进制要进位，当前值应为 3 % 2 = 1。 进位为1 * 将当前值放到数组头部 i = 0 i = 1 i = 2 i = 3 a数组 1 1 1 b数组 1 0 1 result 1 0 0 0 代码var addBinary = function(a, b) { let aLength = a.length; let bLength = b.length; let i = aLength - 1; let j = bLength - 1; let result = []; let add = 0; // 进位 while(i >= 0 || j >= 0) { let atemp = i >= 0 ? a[i] * 1 : 0; // 对i判定大于0为了防止数组溢出 let btemp = j >= 0 ? b[j] * 1 : 0; let current = atemp + btemp + add; if(current >= 2) { add = Math.floor(current / 2); } else { add = 0; } result.unshift(current % 2); // 将当前值放入到数组头 i--; j--; } // 退出循环后如果数组为1表示有进位，那也要加到数组头 if(add != 0) { result.unshift(add) } return result.join(\"\") };","categories":[],"tags":[{"name":"algorithm-双指针","slug":"algorithm-双指针","permalink":"http://yoursite.com/tags/algorithm-%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"盛最多水的容器","slug":"盛最多水的容器","date":"2020-06-23T08:12:00.000Z","updated":"2023-02-14T15:19:27.745Z","comments":true,"path":"2020/06/23/盛最多水的容器/","link":"","permalink":"http://yoursite.com/2020/06/23/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","excerpt":"","text":"11. 盛最多水的容器 题目描述给定一个数组，数组存放的是每个元素的高度，以数组的key做x轴， a[key]做y轴 计算出其中两条与x轴形成的最大面积。 以[1,8,6,2,5,4,8,3,7]为例子最大的面积为49， 以x1轴为1，y1轴为8， 和x2为8，y2为7构成的面积最大为49 暴力破解我们可以用两重循环的方式暴力破解，可是我可以看出我们其实做了一些没必要的计算， * i = 0时，j = 1, j = 2, j = 3, .....j = 7这些都是没必要计算的 * i = 1时，j = 2, j = 3, j = 4, ....j = 7, 这些都是没必要的 * 如此类推 var maxArea = function(height) { let start = 0; let end = height.length - 1; let max = 0; for(let i = 0; i &lt; height.length; i++) { for(let j = i + 1; j &lt; height.length; j++) { let x = j - i; let y = height[i] > height[j] ? height[j] : heigth[i]; max = Math.max(x * y, max) } } return max; }; 分析此题使用双指针，我们看上图，当前值为y, 当y一定时，那么x 尽可能的大，就可以找到最大值了。 定义 头尾指针 如果当前头指针 &lt; 尾指针，那么，头指针到尾指针的距离为 y, 头指针的值为x, 解释一下： 当前值头指针的值固定（y固定），x为最大。所以当前值高度为y的时候，面积最大 如果当前头指针 &gt; 尾指针，那么，头指针到尾指针的距离为 y, 尾指针的值为x, 解释如上 这个时候我们只需要修改头指针和尾指针就可以了。 头指针 &lt; 尾指针时，当前头指针的值y, 头指针到尾指针的距离为x, 当前面积已经最大了，所以头指针向后移 start++ 头指针 &gt; 尾指针时，当前尾指针的值y, 头指针到为指针的距离为x, 当前面积已经醉倒了，所以尾指针向前移 end– 注意：这里需要分析好y轴就可以了 以上面heigth = [1,8,6,2,5,4,8,3,7] 为例子， start = 0; end = heigth.length - 1 当start = 0的时候, 当前y值为 heigth[start]为1，height[end]为7, height[start] &lt; height[end], start到end的距离x 为最大，且y的距离只能为1, 当前y = 1的时候，面积最大为7， 然后start向后移 此时 start = 1, end = heigth.length - 1: height[start] = 8, height[end] = 7, 然而height[start] &gt; height[end], 那y的值只能够取小的那个，即height[end], 当前y=height[end]=7的时候，x = end - start，面积最大为49, end向前移动; 代码var maxArea = function(height) { let start = 0; let end = height.length - 1; let max = 0; while(start != end) { let x = end - start; let y = height[end] > height[start] ? height[start] : height[end]; max = Math.max(x * y, max); if(height[end] > height[start]) { start++; } else { end--; } } return max; };","categories":[],"tags":[{"name":"algorithm-双指针","slug":"algorithm-双指针","permalink":"http://yoursite.com/tags/algorithm-%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"React源码-ReactChildren","slug":"React源码-ReactChildren","date":"2020-06-19T02:57:16.000Z","updated":"2023-02-14T15:19:27.728Z","comments":true,"path":"2020/06/19/React源码-ReactChildren/","link":"","permalink":"http://yoursite.com/2020/06/19/React%E6%BA%90%E7%A0%81-ReactChildren/","excerpt":"","text":"文件目录/packages/react/src/ReactChildren 文档文档地址 ReactChildren 主要用于组合模式，详细可以去看看ant-design的Radio.Group, CheckBox.Group; childrenthis.props.children 其实是一个 ReactElement对象或者是一个数组它的值也是ReactElement, 查看demo可以看到控制台的输出。 React.Children.mapReact.Children.map(this.props.children, (item) =&gt; [item, [item, [item]]])可以看到一个挺有趣的现象，多层嵌套的数组平铺成一维数组，即[item, [item, [item]]] =&gt; [item, item, item], 但可以注意一下各item的key 源码先看看 mapChildren/** * @param {?*} children * @param {function(*, int)} func 遍历的方式 * @param {*} context 上下文 * @return {object} 遍历完后的结果 */ function mapChildren(children, func, context) { if (children == null) { return children; } // 遍历出来的元素会丢到 result 中最后返回出去 const result = []; mapIntoWithKeyPrefixInternal(children, result, null, func, context); return result; } mapIntoWithKeyPrefixInternal/** * @param {?*} children &lt;p>123&lt;p> * @param {Array} array [] * @param {string} prefix \"\" * @param {func} func item => [item, [item, [item]]] * @param {*} context undefined */ function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) { // 这里是处理 key, 看下面 let escapedPrefix = ''; if (prefix != null) { escapedPrefix = escapeUserProvidedKey(prefix) + '/'; } // getPooledTraverseContext 和 releaseTraverseContext 是配套的函数 // 用处其实很简单，就是维护一个大小为 10 的对象重用池 // 每次从这个池子里取一个对象去赋值，用完了就将对象上的属性置空然后丢回池子 const traverseContext = getPooledTraverseContext( array, escapedPrefix, func, context, ); traverseAllChildren(children, mapSingleChildIntoContext, traverseContext); // 将当前 traverseContext 都的属性置空，然后丢回池子 releaseTraverseContext(traverseContext); } escapeUserProvidedKeyeg. &quot;.0/.0&quot;, &quot;.0/.1:0&quot;, &quot;.0/.1:1:0&quot; 将 / 匹配，然后在/加一个/ =&gt; &quot;.0//.0&quot;, replace 的 第二个参数 &#39;$&amp;&#39; 表示匹配的内容 const userProvidedKeyEscapeRegex = /\\/+/g; function escapeUserProvidedKey(text) { return ('' + text).replace(userProvidedKeyEscapeRegex, '$&amp;/'); } getPooledTraverseContext 和 releaseTraverseContextgetPooledTraverseContext 和 releaseTraverseContext 是配套使用的，他们主要是维护一个长度为10对象池，getPooledTraverseContext 就是从对象池中拿一个对象出来然后赋值，releaseTraverseContext 就是将 traverseContext 的属性赋值为空，然后重新放会到池子里面。这样做是因为减少 创建对线和释放对象的性能消耗。 /** * 从池中拿一个对象然后赋值，要是池子没有那直接返回一个对象 * @param {Array} mapResult 遍历后的结果存放 * @param {string} keyPrefix key 值 * @param {func} maoFunction (item) => {} * @param {*} mapContext undefined * @returns {result, keyPrefix, func, context, count = 0} */ function getPooledTraverseContext( mapResult, keyPrefix, mapFunction, mapContext, ) { if (traverseContextPool.length) { const traverseContext = traverseContextPool.pop(); traverseContext.result = mapResult; traverseContext.keyPrefix = keyPrefix; traverseContext.func = mapFunction; traverseContext.context = mapContext; traverseContext.count = 0; return traverseContext; } else { return { result: mapResult, keyPrefix: keyPrefix, func: mapFunction, context: mapContext, count: 0, }; } } // 将对象置空然后放回池子 function releaseTraverseContext(traverseContext) { traverseContext.result = null; traverseContext.keyPrefix = null; traverseContext.func = null; traverseContext.context = null; traverseContext.count = 0; if (traverseContextPool.length &lt; POOL_SIZE) { traverseContextPool.push(traverseContext); } } traverseAllChildren/** * @param {*} children &lt;p>123&lt;/p> 或者是 [&lt;p>123&lt;/p>, &lt;p>456&lt;/p>] * @param callback mapSingleChildIntoContext * @param {result, keyPrefix, func, context, count = 0} traverseContext */ function traverseAllChildren(children, callback, traverseContext) { if (children == null) { return 0; } return traverseAllChildrenImpl(children, '', callback, traverseContext); } traverseAllChildrenImple/** * @param {?*} children &lt;p>123&lt;/p> 或者是 [&lt;p>123&lt;/p>, &lt;p>456&lt;/p>] * @param {!string} nameSoFar 名字路径 * @param {!function} callback mapSingleChildIntoContext * @param {?*} traverseContext {result, keyPrefix, func, context, count = 0} * @return {!number} The number of children in this subtree. */ function traverseAllChildrenImpl( children, nameSoFar, callback, traverseContext, ) { // 这个函数核心作用就是通过把传入的 children 数组通过遍历摊平成单个节点 // 然后去执行 mapSingleChildIntoContext // 开始判断 children 的类型 const type = typeof children; if (type === 'undefined' || type === 'boolean') { // All of the above are perceived as null. children = null; } let invokeCallback = false; if (children === null) { invokeCallback = true; } else { switch (type) { case 'string': case 'number': invokeCallback = true; break; case 'object': switch (children.$$typeof) { case REACT_ELEMENT_TYPE: case REACT_PORTAL_TYPE: invokeCallback = true; } } } // 如果 children 是可以渲染的节点的话， 比如是&lt;Demo>123&lt;/Demo>, 这种情况下，children 是“123”, 就直接调用 callback, // 如果 children 是 [&lt;p>123&lt;/p>, &lt;p>&lt;/p>] 就跳过往下走 // callback 是 mapSingleChildIntoContext if (invokeCallback) { callback( traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar, ); return 1; } // nextName 和 nextNamePrefix 都是在处理 key 的命名 let child; let nextName; let subtreeCount = 0; // Count of children found in the current subtree. const nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR; // 节点是数组的话，就开始遍历数组，并且把数组中的每个元素再递归执行 traverseAllChildrenImpl // 如果children 是数据的话，遍历children数组， 然后在对每个元素进行 // mapSingleChildIntoContext if (Array.isArray(children)) { for (let i = 0; i &lt; children.length; i++) { child = children[i]; nextName = nextNamePrefix + getComponentKey(child, i); subtreeCount += traverseAllChildrenImpl( child, nextName, callback, traverseContext, ); } } else { // 不是数组的话，就看看 children 是否可以支持迭代 // 就是通过 obj[Symbol.iterator] 的方式去取 const iteratorFn = getIteratorFn(children); // 只有取出来对象是个函数类型才是正确的 if (typeof iteratorFn === 'function') { // 然后就是执行迭代器，重复上面 if 中的逻辑了 const iterator = iteratorFn.call(children); let step; let ii = 0; while (!(step = iterator.next()).done) { child = step.value; nextName = nextNamePrefix + getComponentKey(child, ii++); subtreeCount += traverseAllChildrenImpl( child, nextName, callback, traverseContext, ); } } else if (type === 'object') { let addendum = ''; const childrenString = '' + children; } } return subtreeCount; } 该函数用于平铺节点 我们要记住callback 是 mapSingleChildIntoContext 判断children类型 为数字，字符串，还有单个节点的时候直接执行mapSingleChildIntoContext 要是为数组的话遍历数组，再执行traverseAllChildrenImpl 不是数组的话判断一下children 是不是可迭代的，要是是对象的话就抛出对象 mapSingleChildIntoContext/** * 这个函数只有当传入的 child 是单个节点是才会调用 * @param bookKeeping traverseContext * @param child 传入的节点 * @param childKey 节点的 key */ function mapSingleChildIntoContext(bookKeeping, child, childKey) { const {result, keyPrefix, func, context} = bookKeeping; // func => (item) => [item, [item, [item]]] let mappedChild = func.call(context, child, bookKeeping.count++); // 判断函数返回值是否为数组 // mappedChild 的结果是 [item, [item, [item]]] // 我们说 (item) => [item, [item, [item]]] 会平铺成 [item, item, item] if (Array.isArray(mappedChild)) { // 是数组的话就回到最先调用的函数中 // 然后回到之前 traverseAllChildrenImpl 摊平数组的问题 // 假如 c => [item, [item, [item]]]，当执行这个函数时，返回值应该是 [item, [item, [item]]] // 然后 [item, [item, [item]]] 会被当成 children 传入 // traverseAllChildrenImpl 内部逻辑判断是数组又会重新递归执行 mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c); } else if (mappedChild != null) { // 不是数组且返回值不为空，判断返回值是否为有效的 Element // 是的话就把这个元素 clone 一遍并且替换掉 key if (isValidElement(mappedChild)) { mappedChild = cloneAndReplaceKey( mappedChild, // Keep both the (mapped) and old keys if they differ, just as // traverseAllChildren used to do for objects as children keyPrefix + (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey, ); } result.push(mappedChild); } } 看看流程eg. React.Children.map(this.props.children, (item) =&gt; [item, [item, [item]]]) children =&gt; [&lt;p&gt;123&lt;/p&gt;, &lt;p&gt;456&lt;/p&gt;], func =&gt; (item) =&gt; [item, [item, [item]], result = [] 先进行 mapIntoWithKeyPrefixInternal, 传入上面三个值， 我们直接忽略key 然后从池里赋值 func 和result, prefix， 此时 traverseContext result: [], keyPrefix: '', func: (item) => [item, [item, item]], context: undefined count: 0 然后执行 traverseAllChildren 再执行 traverseAllChildrenImpl, 判断 当前children 是不是可以直接渲染 是的话：那直接执行 mapSingleChildIntoContext， 将当前节点放到result 但现在我们的 children 是数组， 所以我们要逐个遍历， 再执行traverseAllChildrenImpl eg.此时我们拿到children[0], 然后执行traverseAllChildrenImpl,然后进入 mapSingleChildIntoContext， // mapSingleChildIntoContext // bookKeeping：{ result: [], keyPrefix: \"\", func: (item) => [item, [item, [item]]] } // child: &lt;p>123&lt;/p> 在mapSingleChildIntoContext内执行了func, 所以得到的结果是mappedChild = [item, [item, [item]]]， 然后判断mappedChild是否是数组，是的话把 mappedChild 当成children 从第一步开始, 但递归后此时func是c =&gt; c, 从 traverseAllChildrenImpl 判断 mappedChild 是数组，然后遍历他，拿出第一个item，再执行了一次 traverseAllChildrenImpl,然后是ReactElement,就执行了mapSingleChildIntoContext, 但注意此时的func 是 c =&gt; c, 判定结果不是数组，将结果push 进result，mapSingleChildIntoContext结束。回到traverseAllChildrenImpl, 然后执行 mappedChild[1], 又在traverseAllChildrenImpl方法判定是数组，再取mappedChild[1][0] 去做 mapSingleChildIntoContext, 然后执行 func c =&gt; c,再push进result，mapSingleChildIntoContext结束, 再一次回到traverseAllChildrenImpl，直到mapChildren遍历完。 以上如此类推 流程图","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"React源码--ReactElement","slug":"React源码-ReactElement","date":"2020-06-18T06:21:43.000Z","updated":"2023-02-14T15:19:27.729Z","comments":true,"path":"2020/06/18/React源码-ReactElement/","link":"","permalink":"http://yoursite.com/2020/06/18/React%E6%BA%90%E7%A0%81-ReactElement/","excerpt":"","text":"文件目录packages/react/src/ReactElement ReactElement指定当前元素是 ReactElement, 但该元素是由 createElement 创建的, 来看一下ReactElement 源码 const ReactElement = function(type, key, ref, self, source, owner, props) { const element = { $$typeof: REACT_ELEMENT_TYPE, // 指Element元素 // 下面几个都是我们 元素的属性， // eg. &lt;div key=\"1\" ref=\"string\" value=\"123\">&lt;/div> type: type, key: key, ref: ref, props: props, // 记录负责创建此元素的组件。 _owner: owner, // 其实是一个FiberNode }; return element; }; createElement文档 根据type 创建一个ReactElement。同时处理ref, key, props, 还有children, 另外对defaultProps 赋值。 我们看一下babel 的转化吧！ &lt;div key=\"1\" ref=\"string\" value=\"123\"> &lt;p>children1&lt;/p> &lt;p>children2&lt;/p> &lt;/div> 会转换成 React.createElement( \"div\", { ref: \"string\", value: \"123\", key: \"1\" }, React.createElement( \"p\", null, \"children1\", ) React.createElement( \"p\", null, \"children12\", ) ) 源码：export function createElement(type, config, children) { // type => div // config => {ref: \"string\",value: \"123\",key: \"1\"} // children => &lt;p>children1&lt;/p>, &lt;p>children2&lt;/p> let propName; const props = {}; let key = null; let ref = null; let self = null; let source = null; // 验证config, 把key 和 ref 从config 单独抽离出来放到props 中 if (config != null) { // 验证 ref 和 key if (hasValidRef(config)) { ref = config.ref; } if (hasValidKey(config)) { key = '' + config.key; } // self 正确获取this, 检测this与 ReactElement.owner是否相等，不相等就发出警告 // source 一个注释对象（由编译器或其他方式添加），指示文件名，行号和/或其他信息。 self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // 遍历配置，把除了key, ref, _self, _source这些以外的数据放到props for (propName in config) { if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) { props[propName] = config[propName]; } } } // 处理children, arguments 后面的参数都是children // 如果children 数大于1个，那么放入到数组中 const childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } props.children = childArray; } // 判断是否有给组件设置 defaultProps，有的话判断是否有给 props 赋值， // 只有当值为 undefined 时，才会设置默认值 if (type &amp;&amp; type.defaultProps) { const defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, ); } cloneElement文档 cloneElement 克隆元素， 大致跟createElement 的处理方式一样 。","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"最佳观光组合","slug":"最佳观光组合","date":"2020-06-17T06:50:13.000Z","updated":"2023-02-14T15:19:27.742Z","comments":true,"path":"2020/06/17/最佳观光组合/","link":"","permalink":"http://yoursite.com/2020/06/17/%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/","excerpt":"","text":"最佳观光组合题目 题目描述给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。返回一对观光景点能取得的最高分。 示例： 输入：[8,1,5,2,6]输出：11解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 暴力破解var maxScoreSightseeingPair = function(A) { let max = 0; const length = A.length; for(let i = 0; i &lt; length; i++) { for(let j = i + 1; j &lt; length; j++) { max = Math.max((A[i] + A[j] + i - j), max); } } return max }; 分析我们可以看方程 A[i] + A[j] + i - j =&gt; A[i] + i + A[j] - j, 我们遍历数组 可以知道 A[j] - j 是可以知道的并且是固定的，所以只要把 A[i] + i 变为最大即可，所以 max + A[j] - j 动态规划 max = A[i] + A[j] + i - j = A[i] + i + A[j] - j var maxScoreSightseeingPair = function(A) { let len = A.length; let dp = []; let max = 0; dp[0] = 0; for(let i = 1; i &lt; len; i++){ dp[i] = Math.max(dp[i - 1], A[i - 1] + i - 1); max = Math.max(max, dp[i] + A[i] - i); } return max; } 优化var maxScoreSightseeingPair = function(A) { let res = 0; let max = 0; const length = A.length; debugger; // A[i] + A[j] + i - j => A[i] + i + A[j] - j // 我们知道A[j] - j 是固定的, 只要维护 A[i] + i 为最大即可，所以就遍历一次 => max + A[j] - j for(let i = 0; i &lt; length; i++) { res = Math.max(max + A[i] - i, res); max = Math.max(max, A[i] + i) } return res; };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"}]},{"title":"React源码--React API","slug":"React源码-React API","date":"2020-06-16T07:00:31.000Z","updated":"2023-02-14T15:19:27.728Z","comments":true,"path":"2020/06/16/React源码-React API/","link":"","permalink":"http://yoursite.com/2020/06/16/React%E6%BA%90%E7%A0%81-React%20API/","excerpt":"","text":"源码版本 16.8.6地址 看看API我们进到packages/src, 看到React.js, 其实这个文件时返回一些基本的API, 比如我们常用的Children, createRef, Component, PureComponent, createContext, forwardRef, lazy, memo 还有 hooks 等等，但我们先不看hooks Children这个Children方法其实是给我们处理props.children的, props.children其实就是一个类数组的东西，Children的用法有遍历React.Children.map 或者 React.Children.forEach，一般情况下我们会配合组合模式cloneElement使用， 有返回children个数 React.Children.count，另外两个不常用toArray和 only 文档 源码解析 createRef我们看看用法 class Demo extends React.Component { constructor() { this.ref = React.createRef() } render() { return ( &lt;div> &lt;Input ref={this.ref} /> // 或者 &lt;Input ref={(inputRef) => this.ref = inputRef } /> &lt;/div> ) } } Component 和 PureComponentComponent 和 PureComponent 就是后者多了一个state 和 props 的浅比较， 也就是相当于在 Component 执行了 shouldComponentUpdate, 简单类型下，可以用PureCompnent 做组件的性能优化 createContext在 react 16后，context 做了改变 const ThemeContext = React.createContext('light'); class App extends React.Component { render() { // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。 // 无论多深，任何组件都能读取这个值。 // 在这个例子中，我们将 “dark” 作为当前的值传递下去。 return ( &lt;ThemeContext.Provider value=\"dark\"> &lt;Toolbar /> &lt;/ThemeContext.Provider> ); } }; // 中间的组件再也不必指明往下传递 theme 了。 function Toolbar() { return ( &lt;div> &lt;ThemedButton /> &lt;/div> ); } class ThemedButton extends React.Component { render() { return ( &lt;ThemeContext.Consumer> { (theme) => ( &lt;Button theme={theme} /> ) } &lt;/ThemeContext.Consumer> ); } } forwardRef其实就是ref 的转发, 一般情况下我们不能用ref 当做props 传递给组件的，但可以通过forwardRef 做强制转发，用的最多的是解决HOC组件传递ref的问题的 const FancyButton = React.forwardRef((props, ref) => ( &lt;button ref={ref} className=\"FancyButton\"> {props.children} &lt;/button> )); // 你可以直接获取 DOM button 的 ref： const ref = React.createRef(); &lt;FancyButton ref={ref}>Click me!&lt;/FancyButton>; lazy简单说就是懒加载 memo简单说就是 PureComponent","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"面试题46. 把数字翻译成字符串","slug":"面试题46-把数字翻译成字符串","date":"2020-06-09T07:58:39.000Z","updated":"2023-02-14T15:19:27.747Z","comments":true,"path":"2020/06/09/面试题46-把数字翻译成字符串/","link":"","permalink":"http://yoursite.com/2020/06/09/%E9%9D%A2%E8%AF%95%E9%A2%9846-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"面试题46. 把数字翻译成字符串 题目描述给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例： 输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi” 分析 一开始想的也是 滑动窗口, 但后来想了一下不太正确，应该用动态规划 过程以 nums = &quot;12258&quot; 为例子 i = 0, nums[0] =&gt; 1, 结果为b,那么结果只有一种， 解释： 只取第一个数1的时候，结果肯定只有一种， 1 转成 b i = 1, nums[1] =&gt; 2, 结果为bc, m, 那么结果有两种，解释： 当数字为12的时候，它可以为 1 =&gt; b, 2 =&gt; c, 为一种：bc 12 =&gt; m, 为一种：m i = 2, nums[2] =&gt; 2, 结果为bcc, mc, bw, 结果有三种，解释：当数字为122的时候,它可以为 1 =&gt; b, 2 =&gt; c, 2 =&gt; c 为一种, bcc 12 =&gt; m, 2 =&gt; c 为一种, mc 1 =&gt; b, 22 =&gt; w 为一种, bw i = 3, nums[3] =&gt; 5, 结果为bccf, mcf, bwf, mz, bcz, 解释： 当数字为1225的时候，他可以为 1 =&gt; b, 2 =&gt; c, 2 =&gt; c, 5 =&gt; f 为一种, bccf 12 =&gt; m, 2 =&gt; c, 5 =&gt; f 为一种, mcf 1 =&gt; b, 22 =&gt; w, 5 =&gt; f 为一种, bwf 1 =&gt; b, 2 =&gt; c, 25 =&gt; z 为一中, bcz 12 =&gt; m, 25 =&gt; z, 为一种：mz i = 4, nums[4] =&gt; 8, 结果为bccfi, mcfi, bwfi, mzi, bczi, 解释： 当数字为12258的时候，他可以为 1 =&gt; b, 2 =&gt; c, 2 =&gt; c, 5 =&gt; f, 8 =&gt; i 为一种, bccfi 12 =&gt; m, 2 =&gt; c, 5 =&gt; f, 8 =&gt; i 为一种, mcfi 1 =&gt; b, 22 =&gt; w, 5 =&gt; f, 8 =&gt; i 为一种, bwfi 1 =&gt; b, 2 =&gt; c, 25 =&gt; z, 8 =&gt; i 为一中, bczi 12 =&gt; m, 25 =&gt; z, 8 =&gt; i, 为一种：mzi 上面我们看 i = 1, i = 2, i = 3 的时候，的结果，我们用dp表示他们的结果 * i = 3的结果bccf, mcf, bwf, mz, bcz, * i = 2的结果bcc, mc, bw, * i = 1的结果m, bc 发现没，其实dp[3] 就是从 dp{2] 和dp[1]的结果过来的, dp[2]的字符串结果都加个f就等于dp[3]的前3个, dp[1]的字符串结果加个z就是dp[3]后三个所以递推公式 dp[i] = dp[i - 1] + dp[i - 2], 但此时递推公式明显不符合i = 4的时候的值, dp[i] 明显等于 dp[i-1], 但前提是nums[i - 1] + nums[i] = 58 &gt; 25 代码var translateNum = function(num) { let numString = num + \"\"; let length = numString.length; if(length &lt; 1) { return 0 } let dp = []; // 递推公式 dp[i] = d[i - 1] + dp[i - 2], 和 dp[i] = dp[i - 1] dp[0] = 1; for(let i = 1; i &lt; length; i++) { const temp = numString[i - 1] + numString[i]; // 当temp = 06 的时候 其实也跟dp[i - 1]一样 if(temp > 25 || numString[i - 1] == '0') { dp[i] = dp[i - 1] } else { dp[i] = dp[i - 1] + (i - 2 &lt; 0 ? 1 : dp[i - 2]) ; // i - 2 &lt; 0 这里是为了解决 dp[i-2]防止溢出问题, 12 结果为2, } } return dp[length - 1] };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"algorithm-面试题","slug":"algorithm-面试题","permalink":"http://yoursite.com/tags/algorithm-%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题29. 顺时针打印矩阵","slug":"面试题29-顺时针打印矩阵","date":"2020-06-09T07:08:16.000Z","updated":"2023-02-14T15:19:27.747Z","comments":true,"path":"2020/06/09/面试题29-顺时针打印矩阵/","link":"","permalink":"http://yoursite.com/2020/06/09/%E9%9D%A2%E8%AF%95%E9%A2%9829-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","excerpt":"","text":"面试题29.顺时针打印矩阵 题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 分析示例1： i/j j = 0 j = 1 j = 2 i = 0 1 2 3 i = 1 4 5 6 i = 2 7 8 9 i = 2 10 11 13 示例2： i/j j = 0 j = 1 j = 2 j = 3 i = 0 1 2 3 4 i = 1 5 6 7 8 i = 2 9 10 11 12 i = 2 13 14 15 16 可以看一下结果，题目说是顺时针打印，可以想象一下 i 跟 j 的变化 循环遍历 结束条件是： 当结果数组的长度 == matrix数组的高 * 宽， 即所有子集都遍历过了 再来分析一下边界问题, 分析一下 i, j 的变化， 这里以 示例2 为例子 开始： 向右走， 那么 j++，i不变， 到 j == 3的时候向下， 所以这里要考虑右边的边界问题 向下走： 那么 i++, j 不变，到 i == 3的时候向左， 所以考虑下边界问题 向左走： 那么 j--, i 不变，到 j == 0的时候向上，所以考虑左边界问题 向上走： 那么 i--, j 不变，到 i == 1的时候再一次重复， 1,2,3,4这四步， 但这里要考虑上边界的问题 我这里用 direction 表示方向， 1 =&gt; 向右， 2 =&gt; 向下， 3 =&gt; 向左， 4 =》 向上 这时候就是想什么时候得到边界，在边界的时候改变方向，所以有 先设置边界 left = 0, right = colums - 1, up = 0, down = rows - 1, 这里表示左右上下的边界，我们只要操作这个边界就可以了另外rows表示有多少行，colums表示有多少列 i == up &amp;&amp; j == left, 我们可以看 i == 0, j == 0的时候，这时候就是向右走 i == up &amp;&amp; j == right, 这时候就是 i == 0， j == 3的时候，那么我们就改变方向，向下走 i == down &amp;&amp; j == right, 这时候就是 i == 3, j == 3，那么又改变方向，向左走 i == down &amp;&amp; j == left, 这时候就是 i == 3, j == 0, 又改变方向，向上走 注意： 此时向上走之后，等 i == up + 1 &amp;&amp; j == left, 即 i == 1, j ==0, 即5这个地方，那么就向右走，同时，更改边界, left++, right--, up++, down-- 再重复上面的事情 整个过程是： 1 =&gt; 2 =&gt; 3 =&gt; 4 =&gt; 8 =&gt; 12 =&gt; 16 =&gt; 15 =&gt; 14 =&gt; 13 =&gt; 9 =&gt; 5 这是一圈 6 =&gt; 7 =&gt; 11 =&gt; 10 这又是一圈 当输入的matrix = [[1],[2],[3]]就只有一列的时候， 另外看示例1, 走完外圈，剩下内圈，只剩下5,8这两个元素的时候也向下走，所以总结 left == right的时候，direction = 2, i++ 代码var spiralOrder = function(matrix) { let rows = matrix.length; let result = []; if(rows == 0) { return result } let columns = matrix[0].length; let count = 0; let i = 0; let j = 0; let direction = 1; // 1 => 向右 2 => 向下 3=> 向左 4 => 向上 let left = 0; // 左边界 let right = columns - 1; // 右边界 let up = 0; let down = rows - 1; while(count &lt; rows * columns) { const current = matrix[i][j]; result.push(current); count++; if(left == right) { // 当剩下的元素只有一列的时候，只能向下走了 direction = 2; i++; continue; } if(i == up &amp;&amp; j == left) { // 拐点向右 direction = 1 } else if(i == up &amp;&amp; j == right) { // 拐点向下 direction = 2 } else if(i == down &amp;&amp; j == right) { // 拐点向左 direction = 3; } else if(i == down &amp;&amp; j == left) { // 拐点向上 direction = 4 } if(i == up + 1 &amp;&amp; j == left) { // 完成一圈后，重设定边界 left = left + 1; right = right - 1; up = up + 1; down = down - 1; direction = 1; } // 根据方向，改变i, j的值 if(direction == 1) { j++; } else if(direction == 2) { i++; } else if(direction == 3) { j--; } else { i--; } } return result };","categories":[],"tags":[{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"},{"name":"algorithm-数组","slug":"algorithm-数组","permalink":"http://yoursite.com/tags/algorithm-%E6%95%B0%E7%BB%84/"},{"name":"algorithm-面试题","slug":"algorithm-面试题","permalink":"http://yoursite.com/tags/algorithm-%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"高德地图滑动验证","slug":"高德地图滑动验证","date":"2020-06-05T09:34:27.000Z","updated":"2023-02-14T15:19:27.747Z","comments":true,"path":"2020/06/05/高德地图滑动验证/","link":"","permalink":"http://yoursite.com/2020/06/05/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/","excerpt":"","text":"高德地图滑动验证 用dispatch 模拟dom的mousedown, mousemove，还有mouseUp 事件 再用 setInterval 执行mouseMove事件即可 但这里有时候会滑动失败，所以要刷新验证码，然后重新滑动， 有时候又是滑动验证码验证成功后。 再一次弹出验证码 注意：滑动验证码请注意滑动的速度和滑动的距离，要是太慢、滑动距离太短的话，滑动验证多数会不通过。 检查验证码// 检查验证码 function checkYzm() { const dom = document.querySelector(\".sufei-dialog\"); if(dom &amp;&amp; dom.style.display == \"block\") { return true; } return false } 滑动验证码async function sliderYzm() { await sleep(1500); const iframe = document.getElementById(\"sufei-dialog-content\"); const btn = iframe.contentWindow.document.getElementById(\"nc_1_n1z\"); const mousedown = document.createEvent(\"MouseEvents\"); const rect = btn.getBoundingClientRect(); var x = rect.x; var y = rect.y; mousedown.initMouseEvent(\"mousedown\", true, true, window, 0, x, y, x, y, false, false, false, false, 0, null); btn.dispatchEvent(mousedown); let dx = 0; let dy = 0; const mousemove = document.createEvent(\"MouseEvents\"); return new Promise((resolve) => { const interval = setInterval(async () => { const _x = x + dx; const _y = y + dy; mousemove.initMouseEvent(\"mousemove\", true, true, window,0 ,_x, _y, _x, _y, false, false, false, false, 0, null); btn.dispatchEvent(mousemove); if(_x - x >= 300){ clearInterval(interval); const mouseup = document.createEvent(\"MouseEvents\"); mouseup.initMouseEvent(\"mouseup\", true, true, window, 0, _x, _y, _x, _y, false, false, false, false, 0, null); btn.dispatchEvent(mouseup); await sleep(2500); if(btn.className.indexOf('btn_ok') > -1){ console.log(btn.className); sleep(1000) resolve({status: 1}); } if(iframe.contentWindow.document.querySelector(\"#nocaptcha > .errloading\")) { console.log(\"error\") sleep(1000) resolve({status: 0}) } } else{ dx += Math.ceil(Math.random() * 300); } }, 30); }) } 上面只是滑动验证 循环检查时候是否有验证码/** * 循环检查是否有验证码 * 1. 要是有验证码窗口，那么滑动验证， 但滑动验证有失败或者成功，失败返回0， 成功返回1 * 2. 滑动成功后，防止验证码再一次出现，我们延迟1500毫秒，再查看一下验证码窗口是否存在，存在就再一次执行loopSlideYzm(), 不存在就直接结束函数了 * 3. 滑动失败后，会有刷新标志，那这时候应该点击刷新后，再一次执行loopSlideYzm(); */ async function loopSlideYzm() { await sleep(1200); const hasYzm = checkYzm(); await sleep(1000); if(hasYzm) { const { status } = await sliderYzm(); await sleep(1500); if(status) { console.log(\"再找一次是否有验证码\") const hasYzmAgain = checkYzm(); await sleep(1500); if(hasYzmAgain) { return await loopSlideYzm(); } else { return Promise.resolve() } } else { console.log(\"给我刷新验证码\"); freshYzm(); await sleep(1500); return await loopSlideYzm(); } } return Promise.resolve() } 刷新验证码function freshYzm() { const iframe = document.getElementById(\"sufei-dialog-content\"); iframe.contentWindow.document.querySelector(\"#nocaptcha > .errloading > .nc-lang-cnt > a\").click() } 以上就是自动跳过高德地图的滑动验证码全过程","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"记录一下react的一些用法","slug":"记录一下react的一些用法","date":"2020-06-03T08:18:46.000Z","updated":"2023-02-14T15:19:27.745Z","comments":true,"path":"2020/06/03/记录一下react的一些用法/","link":"","permalink":"http://yoursite.com/2020/06/03/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Breact%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/","excerpt":"","text":"高阶组件HOC HOC 其实就是一个函数， 接收参数是一个组件，但返回值是一个组件 看一个简单的高阶组件 function visibleHOC(WrappedComponent) { return class extends Component { render() { const { visible } = this.props; if(!visible) return null; return &lt;WrappedComponent {...this.props}> } } } Render Propsconst CustomModal = ({visible, cancel}) => { return ( &lt;Modal visible={visible} onCancel={cancel} > Hello World &lt;/Modal> ) } class ModalContainer extends Component { state = { visible: false } handleCancel = () => { this.setState({ visible: false }) } show = () => { this.setState({ visible: true }) } render() { const { visible } = this.state; const { children } = this.props; return ( children({ visible: visible, show: this.show, cancel: this.handleCancel }) ) } } class App extends Component { render() { return ( &lt;div> &lt;ModalContainer> ({visible, show, cancel}) => ( &lt;> &lt;CustomModal visible={visible} cancel={cancel}>&lt;/CustomModal> &lt;Button type=\"primary\" onClick={show}> Click &lt;/Button> &lt;/> ) &lt;/ModalContainer> &lt;/div> ) } } demo","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"原型与继承","slug":"原型与继承","date":"2020-06-01T09:10:32.000Z","updated":"2023-02-14T15:19:27.735Z","comments":true,"path":"2020/06/01/原型与继承/","link":"","permalink":"http://yoursite.com/2020/06/01/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/","excerpt":"","text":"prototype我们知道每个函数都有一个prototype指向他的原型对象。我们可以这么理解： 每个对象在创建时就与另一个对象产生关联，其实就是对另一个对象的引用。而js 再找对象属性时会顺着原型链一直往上找，直到无法找到为止 来看一下 function Person(name) { this.name = name } // 控制台打印一下， => 是结果 Person.prototype => { constructor: f } // 而 Person.prototype.constructor 又指向与构造函数自己 Person.prototype.constructor == Person // true 用下图表示： proto每个对象都有一个__proto__属性，除了null外，而这个属性又指向他的原型对象 验证一下 function Person(name) { this.name = name } var person = new Person(\"Bill\"); // 控制台打印一下， person.__proto__ person.__proto__ => { constructor: f } // 我们从上面[prototype]看 Person.prototype 也是指向 { constructor: f }, 那么他们是否是同一个东西呢? person.__proto__ == Person.prototype // 结果是 true 的 // 上面一样的话，那么 person.__proto__.contructor == Person // true 用图表示一下就是 new 操作符 这里解释一下new 操作符，其实跟原型有关 首先搞清楚new 做了什么 创建对象 将对象的原型指向函数的原型 改变 this 上下文 返回这个对象 function newObj(fn, ...args) { var obj = {}; obj.__proto__ = fn.prototype; let res = fn.call(obj, ...args); let isObject = typeof res === 'object' &amp;&amp; typeof res !== null; let isFunction = typeof res === 'function'; return isObject || isFunction ? res : obj; // 这里其实可以直接返回obj // 但防止 fn 这个方法直接返回this, 以下这种情况 // function fn(name) { // this.name = name; // return this; // } } function Person(name) { this.name = name; } // 测试一下 person = newObj(Person, \"Bill\") // 打印一下 person // Person {name: Bill} Fn.prototype.proto 我们说Fn.prototype 是一个原型对象，我们上面说只要是对象都有__proto__, 那么Fn.prototype.__proto指向的是什么呢？ 答案是： Object.prototype Object.prototype == Person.prototype.__proto__ // true 所以有了下图 到此原型基本已经讲完了 继承下面写继承 原型链继承function Parent(){ this.role = \"parent\" this.list = [1,2,3] } Parent.prototype.getRole = function() { return this.role } function Child(name) { this.name = name } Child.prototype = new Parent(); Child.prototype.getName = function() { return this.name; } var children = new Child(\"admin\"); children.getName() children.getRole() var parent = new Parent(); console.log(parent.role) // parent Child.prototype.value = \"123\" console.log(parent.value); // \"undefined\" console.log(children.value) // “123” // 以下是原型链的缺点 var children2 = new Child(\"child2\"); console.log(children.list, children2.list) // [1,2,3], [1,2,3,4] children.list.push(4); console.log(children.list, children2.list) // [1,2,3,4], [1,2,3,4] 看下图 当执行了 Child.prototype = new Parent(), 我们说找属性的话,会顺着原型链去找, 比如children要找getRole,那么他会一直找，Child.prototype.__proto__下有getRole, 这就是继承 当执行了 Child.prototype.value = &quot;123&quot;, children实例也拥有了value 。 缺点: 只要在某个子类下改变了父类的引用类型的值，那么子类都会改变，这样做就不能做到相互独立了 无法实现父类构造函数属性的赋值 使用call，改变this 作用域function Parent() { this.role = \"parent\" } function Child(role, name) { Parent.call(this, role) this.name = name; } var children = new Child(\"children\", \"哈哈哈\"); // 注意 Parent.prototype.getRole = function() { return this.role; } // 上面原型方法，子类是无法继承的，即children没有getRole 方法 优点： 解决了原型继承无法向父类赋值的问题 可以继承多个构造函数属性（call多个）； 缺点： 只能继承父类构造函数的属性。原型链新创建的无法被继承 无法实现构造函数的复用。（每次用每次都要重新调用） 每个新实例都有父类构造函数的副本，臃肿。 组合模式将call方式和原型链方式组合起来 function Parent(role) { this.role = role } Parent.prototype.value = \"test\"; function Child(role, name) { Parent.call(this, role); this.name = name; } Child.prototype = new Parent(); var children = new Child(\"child\", \"admin\") 优点： 可以继承父类原型上的属性，可以传参，可复用； 每个新实例引入的构造函数属性是私有的； 缺点： 调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数； 寄生式继承function Parent(role) { this.role = role; this.list = [1,2,3]; } Parent.prototype.value = \"123\" // 原型式继承 function _extend(obj) { function F(){}; F.prototype = obj; // F.prototype = new Parent() -> 还是回到原型链继承 return new F(); // 这里像不像 原型链继承上面的 new Child(); } var parent = new Parent(); // 获取父类实例 // 以上是原型式继承，以下给原型继承在套个壳子传递参数 function wrap(obj, name, role){ var child = _extend(obj); child.role = role; child.name = name; return child; } var child = wrap(parent, 'test', \"child\"); console.log(child.role) // \"test\" console.log(child.value) // \"123\" var child1 = wrap(parent, \"Bill\", \"child1\"); console.log(child1.list) // [1,2,3] child1.list.push(456); console.log(child1.list) // [1,2,3,456] console.log(child.list) // [1,2,3,456] 看上面 又回到了原型链继承的缺点之一了，对于父类引用类型的，一旦做了修改，子类的都会发生改变 寄生组合式继承function Parent(role) { this.role = role; this.list = [1,2,3]; } Parent.prototype.value = \"123\" function Child(name, role) { Parent.call(this, role) // 等于有了父类构造函数的副本 this.name = name; } function _extend(obj) { function F(){}; F.prototype = obj; // F.prototype = new Parent() -> 还是回到原型链继承 return new F(); // 这里像不像 原型链继承上面的 new Child(); } var extendFn = _extend(Parent.prototype); Child.prototype = extendFn; extendFn.constructor = Child; var children = new Child(\"test\", \"child\"); 我们看下图 上面与下面其实大致一样, function F(){}; F.prototype = Parent.prototype; function Child() { Parent.call(this); } Child.prototype = new F(); // 是不是有点像组合模式 // 寄生组合模式理想版 function inheritPrototype(subType, superType){ var prototype = Object.create(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象 } function SuperType(name){ this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function(){ alert(this.name); }; function SubType(name, age){ SuperType.call(this, name); this.age = age; } inheritPrototype(SubType, SuperType);//实现继承 SubType.prototype.sayAge = function(){ alert(this.age); }","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"打家劫舍","slug":"打家劫舍","date":"2020-05-29T15:45:17.000Z","updated":"2023-02-14T15:19:27.742Z","comments":true,"path":"2020/05/29/打家劫舍/","link":"","permalink":"http://yoursite.com/2020/05/29/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","excerpt":"","text":"198. 打家劫舍 题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 尝试 一开始以为是 i奇数的值相加，与偶数的值相加，最后比最大值，提交发现是错误的 然后一想就知道是一位数组的动态规划 题解 定义数组含义： dp[i] 设定第i房间时，所偷的钱为最大 找出数组元素间的关系式 =&gt; 递推公式。 题目规定：小偷不能连续偷窃相邻的房子，至少隔一个房间，那么当我偷到第i房间的时候，我只要求出第i-2房间时跟第i-3房间时的最大值即可，i-2表示隔了一间房间， i-3表示隔了2个房间所以递推公式为 dp[i] = nums[i] + Math.max(dp[i - 3], dp[i - 2]) 找出初始条件： 第0间自然是nums[0], 但我们递推公式 i-3和i-2 理论上没有非正整数的房间，我们手动输入为0吧 var rob = function(nums) { // dp[i] = nums[i] + Max(dp[i-3], dp[i-2]) let dp = new Map(); dp[0] = nums[0]; dp[-1] = 0; dp[-2] = 0; // dp(1) = nums[1] + max(dp(1-3), dp[1-2]) for(let i = 1; i &lt; nums.length; i++) { dp[i] = nums[i] + Math.max(dp[i-3], dp[i-2]); } let result = 0; for(let i = 0; i &lt; nums.length; i++) { result = Math.max(result, dp[i]); } return result };","categories":[],"tags":[{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"字符串解码","slug":"字符串解码","date":"2020-05-29T02:25:49.000Z","updated":"2023-02-14T15:19:27.736Z","comments":true,"path":"2020/05/29/字符串解码/","link":"","permalink":"http://yoursite.com/2020/05/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/","excerpt":"","text":"394. 字符串解码 题目描述编码规则为：k[encoded_string], 即中括号前表示重复的次数，中括号里面的是重复的字符串 例子： s = \"3[a]2[bc]\", 返回 \"aaabcbc\". s = \"3[a2[c]]\", 返回 \"accaccacc\". s = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\". 尝试 用栈的方式去解决问题 用递归的方式 递归解决 以3[a2[c]]为例子, 变量为s 遍历字符串s, 如果是数字, /\\d/.test(s[i]), i++, 如果直接是字母,那直接往后扫, i++ 遇到[进入递归 遇到]结束递归，同时返回[encode_string]中括号里面的内容, 同时返回当前index，即当前]在s[]中第几位 将第6步返回的值和第3步的重复次数，做个for循环就好了 代码实现var decodeString = function(s) { let res = \"\"; const sub = generate(s, 0); res += sub.sub; return res } // 3[a2[c]] function generate(string, start) { let index = start; let temp = \"\"; let tempNum = \"\"; while(index &lt; string.length) { const current = string[index]; if(current == \"[\") { const sub = generate(string, index + 1 ); let res = \"\"; index = (sub.index) for(let i = 0 ; i &lt; tempNum ; i++) { res += sub.sub } temp += res; tempNum = \"\"; } else if(current == \"]\") { let res = temp; return {index: index + 1, sub: res} } else if(/\\d/.test(current)) { tempNum += current index++; } else { temp += current index++ } } return {index: index, sub: temp} }","categories":[],"tags":[{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"}]},{"title":"和为k的子数组","slug":"和为k的子数组","date":"2020-05-27T15:16:32.000Z","updated":"2023-02-14T15:19:27.735Z","comments":true,"path":"2020/05/27/和为k的子数组/","link":"","permalink":"http://yoursite.com/2020/05/27/%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"","text":"力扣上第560题 题目描述给定一个数组 nums 跟一个 和为k 的值，找到该数组中和为 k 的连续的子数组的个数。 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 尝试 暴力破解, 即每个数跟与他以后的数相加 等于k，那么 res + 1 function subarraySum(nums, k) { let res = 0; for(let i = 0; i &lt; nums.length; i++) { let current = nums[i]; if(current == k) { res += 1; } for(let j = i + 1; j &lt; nums.length; j++) { current += nums[j]; if(current == k) { res += 1; } } } return res; } 滑动窗口，滑动窗口不太好处理，窗口向右扩展的时候，那其实是跟上面算法好像差不多，然后放弃了 看了题解，发现了一个前缀和算法 前缀和算法 将数组中的每一项在遍历时都加起来，然后加入到新的数组中，我们用s[i]表示 定义s[0] = 0 s[1] = a[0] s[2] = s[1] + a[1] 所以得到 s[i + 1] = s[i] + nums[i] 所以移动等式 nums[i] = s[i + 1] - s[i] 所以有以下代码 function subarraySum(nums, k) { let res = 0; let s = [0]; // 多了这一层，结果更慢了 for(let i = 0; i &lt; nums.length; i++) { s[i + 1] = s[i] + nums[i]; } for(let i = 0; i &lt; nums.length; i++) { for(let j = i; j &lt;= nums.length; j++) { if(s[j + 1] - s[i] == k) { res++; } } } return res } 可以看到以上代码其实跟第一种方法是大同小异的，只是使用了前缀和的思想，但这个方法比上面那个还要慢，因为多 前缀和添加这一组循环 优化 看到题解是用前缀和还有哈希表做优化的 思想： 将当前前缀和的值当做哈希表的key。 将当前前缀和出现的次数 当做哈希表的value 具体操作如下: 当遍历 nums时，计算当前前缀和, 存入map 如果 map 中已存在 key 为 当前前缀和 - k, 因为一直遵守 【当前前缀和】-【之前求出的前缀和】 === k, 那么取出哈希表的值，res += value, 如果 map 中， 没有当前前缀和的值 那么把前缀和添加到哈希表中，值为1， 如果有，那么改变哈希表的值: map[prefix]++ function subarraySum(nums, k) { let res = 0; let map = { 0:1 }; let prefixSum = 0; for(let i = 0; i &lt; nums.length; i++) { prefixSum += nums[i]; if(map[prefixSum - k]) { res += map[prefixSum - k] } if(map[prefixSum]) { map[prefixSum]++ } else { map[prefixSum] = 1 } } return res }","categories":[],"tags":[{"name":"algorithm-前缀和","slug":"algorithm-前缀和","permalink":"http://yoursite.com/tags/algorithm-%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"验证回文字符串 Ⅱ","slug":"验证回文字符串 Ⅱ","date":"2020-05-19T09:13:34.000Z","updated":"2023-02-14T15:19:27.747Z","comments":true,"path":"2020/05/19/验证回文字符串 Ⅱ/","link":"","permalink":"http://yoursite.com/2020/05/19/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E2%85%A1/","excerpt":"","text":"验证回文字符串 Ⅱ力扣上第680题 核心思想使用双指针，即使用前后两个指针，同时对前指针和后指针的值做对比，要是相同，那么前指针向后移动，后指针向前移动但这道题说可以删除一个字符, 那么当我们遇到不相等的值的时候，只要前指针向后移动，或者后指针向前移动，然后剩下的做对比即可 终止条件为： 前指针 比 后指针要大，或者说是前指针后于后指针 解释 上图，我们只要判断左指针和右指针的值是否相等，直到终止条件，要是全部都相同，那么就是回文了 但这题说可以删除一个字母，那么等字符不相等的时候，左指针向后移动或者右指针向前移动，将剩下的再做一次回文即可，看下图 代码// \"ebcbb ececabbacec bbcbe\" // \"ebcbb cecabbacece bbcbe\" var validPalindrome = function(s) { let left = 0; let right = s.length - 1; let flag = false; // 标志位 表示要是遇到一个前指针与后指针不相同的值, 退出循环。 while(left &lt; right) { const leftTemp = s[left]; const rightTemp = s[right]; if(leftTemp == rightTemp) { left++; right--; } else { flag = true; break; } } if(flag >= 1) { const tempString = s.slice(left + 1, right + 1); return validChilren(left+1, right, s) || validChilren(left, right - 1, s); } return true; }; function validChilren(left, right, s) { while(left &lt; right) { const leftTemp = s[left]; const rightTemp = s[right]; if(leftTemp == rightTemp) { left++; right--; } else { return false; } } return true; }","categories":[],"tags":[{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"}]},{"title":"大众点评文字数字解密","slug":"大众点评文字数字解密","date":"2020-05-08T02:54:10.000Z","updated":"2023-02-14T15:19:27.735Z","comments":true,"path":"2020/05/08/大众点评文字数字解密/","link":"","permalink":"http://yoursite.com/2020/05/08/%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84%E6%96%87%E5%AD%97%E6%95%B0%E5%AD%97%E8%A7%A3%E5%AF%86/","excerpt":"","text":"原理百度发现大众点评网上面的文字数字加密是通过字体文件加密的，也就是说用css 的class 用不同的类对应的字体文件，再加下面的特殊字符跟字体文件上面的编码一一对应起来 先看一下大众点评吧 我们从上图可以看到，大众点评的地址是加密的，所以我们不能直接从html中获取 发现发现上图 .num 类和 .address 类用的 ba****.css, 打开此css发现这些类使用的字体文件都是不同的，看下图： 我们可以下载FontCreator 打开上图链接的.woff, 或者用百度的FontEditor(之前可以用，后来不行了) 我们用北做例子，在大众点评上加密的字符是 , 我们发现.woff 文件用forntCreator 上面的16进制码是 efa8, js 解析字体文件工具 fonteditor-core它会把.woff 文件中某个 字体转成十进制然后一一对应起来 var Font = require('fonteditor-core').Font; var fs = require('fs'); var buffer = fs.readFileSync('4.woff'); // 不加这个文件会报错 // https://cdn.bootcdn.net/ajax/libs/pako/1.0.10/pako_inflate.min.js let inflate_daddy = require(\"./pako_inflate.min\"); var font = Font.create(buffer, { type: 'woff', // support ttf,woff,eot,otf,svg inflate: inflate_daddy.inflate }); console.log(font.data.cmap); // font.data.cmap // key值代表十进制, value代表的是第几个字体 { '120': 1, '57346': 81, '57348': 275, ... '61352': 125 } 上面北字为例，加密字符 ,转成十进制就是 61352 也就是在.woff 文件第125个字,但机器是不知道上面第125个字是什么字，所以我们做一个.woff文件的所有字体人工抽取出来然后一一对应就好了 woffString = ` 1234567890店中美家馆 小车大市公酒行国品发电金心业商司 超生装园场食有新限天面工服海华水 房饰城乐汽香部利子老艺花专东肉菜 学福饭人百餐茶务通味所山区门药银 农龙停尚安广鑫一容动南具源兴鲜记 时机烤文康信果阳理锅宝达地儿衣特 产西批坊州牛佳化五米修爱北养卖建 材三会鸡室红站德王光名丽油院堂烧 江社合星货型村自科快便日民营和活 童明器烟育宾精屋经居庄石顺林尔县 手厅销用好客火雅盛体旅之鞋辣作粉 包楼校鱼平彩上吧保永万物教吃设医 正造丰健点汤网庆技斯洗料配汇木缘 加麻联卫川泰色世方寓风幼羊烫来高 厂兰阿贝皮全女拉成云维贸道术运都 口博河瑞宏京际路祥青镇厨培力惠连 马鸿钢训影甲助窗布富牌头四多妆吉 苑沙恒隆春干饼氏里二管诚制售嘉长 轩杂副清计黄讯太鸭号街交与叉附近 层旁对巷栋环省桥湖段乡厦府铺内侧 元购前幢滨处向座下臬凤港开关景泉 塘放昌线湾政步宁解白田町溪十八古 双胜本单同九迎第台玉锦底后七斜期 武岭松角纪朝峰六振珠局岗洲横边济 井办汉代临弄团外塔杨铁浦字年岛陵 原梅进荣友虹央桂沿事津凯莲丁秀柳 集紫旗张谷的是不了很还个也这我就 在以可到错没去过感次要比觉看得说 常真们但最喜哈么别位能较境非为欢 然他挺着价那意种想出员两推做排实 分间甜度起满给热完格荐喝等其再几 只现朋候样直而买于般豆量选奶打每 评少算又因情找些份置适什蛋师气你 姐棒试总定啊足级整带虾如态且尝主 话强当更板知己无酸让入啦式笑赞片 酱差像提队走嫩才刚午接重串回晚微 周值费性桌拍跟块调糕 ` 以上获取北字 就是 woffString[font.data.cmap[&#39;61352&#39;]] =&gt; woffString[125] 字符串转进制function stringToEntity(str, radix = 10) { let arr = str.split('') let tmp = arr.map(item => item.charCodeAt(0).toString(radix) ).join(''); // console.log(`'${str}' 转实体为 '${tmp}'`) return tmp } 以上就是解密全过程","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"webpack+vue+electron开发环境搭建","slug":"webpack-vue-electron开发环境搭建","date":"2020-04-23T02:05:49.000Z","updated":"2023-02-14T15:19:27.733Z","comments":true,"path":"2020/04/23/webpack-vue-electron开发环境搭建/","link":"","permalink":"http://yoursite.com/2020/04/23/webpack-vue-electron%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"设置electron 安装路径npm set config ELECTRON_MIRROR=&quot;https://npm.taobao.org/mirrors/electron/&quot; 核心思想electron 分主进程和渲染进程，在这里，我们直接把主进程看成是创建主体窗口，而渲染进程看成是 页面的渲染。 渲染进程当成一般的webpack配置即可， vue-loader, less-loader, style-loader等等照常配置即可, 主进程： 主进程我们只当他是创建主体窗口的，那么我们只需要配置 babel-loader, 当主进程发生改变时，那么就重启窗口， 简单来说就是直接使用 electron .这个命令， 但是我们使用nodejs 的方式启动 当渲染进程文件发生改变时，我们的electron 也跟着刷新，那么就要使用devServer + webpack-hot-middleware, 但我觉得直接使用devServer 也没问题 在主进程中要监听localhost的变化 win.loadURL(&quot;http://localhost:9000&quot;),才能达到 实时更新 配置渲染进程 我们根据 vue-cli 目录文件去配，vue-cli 渲染进程的目录路径：src/render/ 目录下 ├─assets // 资源文件 ├─components // vue 组件 ├─pages // 路由页面 ├─App.vue // vue 主体文件 ├─index.js // 入口文件 └─router.js // 路由文件，配置路由的 渲染进程webpack 配置： // configs/webpack.render.config.js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const VueLoaderPlugin = require('vue-loader/lib/plugin'); const webpack = require('webpack') // loader 自行npm install module.exports = { mode: 'development', entry: './src/render/index.js', devtool: 'eval-source-map', // target: 'electron-renderer', // 加了反而报错 output: { filename: '[name].js', path: path.resolve(__dirname, '../dist/render') }, module: { rules: [ // babel-loader, less-loader 等等 { test: /\\.vue$/, // 编译vue loader: 'vue-loader' } // ... 图片字体文件等等的文件配置 ] }, plugins: [ new VueLoaderPlugin(), // 编译vue new HtmlWebpackPlugin({template: path.resolve(__dirname, '../public/index.html')}), new webpack.HotModuleReplacementPlugin() ], // 往后devServer 会改成nodejs 的方式启动 devServer: { contentBase: path.resolve(__dirname, '../dist/render'), hot: true, compress: true, port: 9000, open: true } } 要是执行命令webpack-dev-server --config ./configs/webpack.dev.config.js 没报错，那没渲染进程基本没问题了，另外我们往后 会把devServer 改成 nodejs的方式启动 配置主进程我们会把主进程的js 放入src/main/目录下， 但其实只有index.js const path = require('path'); module.exports = { entry: './src/main/index.js', mode: 'development', output: { filename: '[name].js', path: path.resolve(__dirname, \"../dist/main\") }, target: 'electron-main' } 用nodejs 的方式启动这些配置// 渲染进程 //https://webpack.docschina.org/guides/development // 因为webpack-hot-middleware 只能检测到文件发生变化时重新加载，但不能刷新浏览器，所以我们加入 webpack-dev-server， 让浏览器自动刷新 function createRendererServer() { return new Promise((resolve, reject) => { // 直接添加 wenpack-hot-middleware/client.js, rendererConfig.entry = ['webpack-hot-middleware/client?noInfo=true&amp;reload=true'].concat(rendererConfig.entry); const compiler = webpack(rendererConfig); hotMiddleware = webpackHotMiddleware(compiler, { log: false, heartbeat: 2500 }) compiler.hooks.done.tap('done', stats => { console.log(\"完成\");}) const server = new webpackDevServer(compiler, { contentBase: path.resolve(__dirname, '..'), quiet: true, before (app, ctx) { // express, 可获取 node 服务 app 实例，执行中间件操作 app.use(hotMiddleware) ctx.middleware.waitUntilValid(() => { resolve() }) } }); server.listen(9000); }) } // 因为主进程的index.js 文件不常改，我们直接使用watch 的方式，监听文件变化，文件一变化，那么我们就重新启动electron function createMainServer() { return new Promise((resolve, reject) => { const compiler = webpack(mainConfig); // 主进程监听文件变化， webpack watch 模式，那么就从起electron, 即调用electron . compiler.watch({ aggregateTimeout: 300, poll: 1000 }, (err, stats) => { if (err) { console.log(err) return } if (electronProcess &amp;&amp; electronProcess.kill) { manualRestart = true process.kill(electronProcess.pid) electronProcess = null startElectron() // 用 nodejs spawn的方式启动electron , 启动加载的js 应该是在 /dist/main/main.js ,该方法就不写了 setTimeout(() => { manualRestart = false }, 5000) } resolve() }) }) } 我们用Promise.all([createRendererServer(), createMainServer()]) 这两个都编译好之后再启动electron .then(() =&gt; startElectron()); 效果 最后浏览器打开localhost:9000 一样也可以，另外就是 nwjs 的开发环境也大致一样吧","categories":[{"name":"electron","slug":"electron","permalink":"http://yoursite.com/categories/electron/"},{"name":"vue","slug":"electron/vue","permalink":"http://yoursite.com/categories/electron/vue/"},{"name":"webpack","slug":"electron/vue/webpack","permalink":"http://yoursite.com/categories/electron/vue/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"electron","slug":"electron","permalink":"http://yoursite.com/tags/electron/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"长列表实践","slug":"长列表实践","date":"2020-04-15T06:33:51.000Z","updated":"2023-02-14T15:19:27.747Z","comments":true,"path":"2020/04/15/长列表实践/","link":"","permalink":"http://yoursite.com/2020/04/15/%E9%95%BF%E5%88%97%E8%A1%A8%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"场景描述当在一些展示性页面的时候，会经常性使用一些列表进行渲染，但是当数据太多的时候，dom 节点不断累加，会造成滚动时页面的卡顿，影响用户体验 解决方案：虚拟列表 核心思想虚拟列表只对可视区域中的列表进行渲染, 滚动时改变渲染的数组 子列表元素高度固定时 整个列表高度固定 可视区域渲染条数固定 可根据滚动距离，得到渲染的数组 移动可视区域到滚动的距离位置 当有10000条数据，屏幕高度为500时, 子元素高度为50，那么可渲染区域应该渲染为10条数据, 整个列表高度为50 * 10000 当我们发生滚动的时候，比如滚动了150px，那么我们可见区域的渲染列表就变成了下图 第4项到第13项了 结构&lt;div className={styles.page} style={{height: pageHeight + \"px\"}} ref=\"container\"> {/* 屏幕高度 */} &lt;div className={styles.infiniteListGhost} style={{height: infiniteListGhostHeight + \"px\"}} >&lt;/div> {/* list 高度 */} &lt;div className={styles.renderList} style={{ transform: `translate3d(0, ${translate}px, 0)`}} > {/* 可见list 高度 */} { renderList.map((item, index) => { return ( &lt;div className={styles.item} key={index} style={{height: itemHeight + \"px\"}}> {/* 子列表元素高度 */} { item } &lt;/div> ) }) } &lt;/div> &lt;/div> .page { overflow-y: auto; width: 100%; position: relative; .infiniteListGhost { position: absolute; left: 0; right: 0; top: 0; z-index: -1; } .renderList { position: absolute; left: 0; right: 0; top: 0; z-index: 1; .item { color: #000; border: 1px solid #ccc; display: flex; flex-direction: row; align-items: center; justify-content: center; } } } 子列表项的高度为 itemHeight = 50, 滚动高度 为 scrollTop 屏幕高度： pageHeight = document.body.clientHeight; 列表高度： infiniteListGhostHeight = list.length * itemHeight 渲染条数： const itemCount = Math.ceil(clientHeight / itemHeight ); startIndex: startIndex = Math.floor(scrollTop / itemHeight) endIndex: endIndex = startIndex + itemCount 列表渲染数组： list.slice(startIndex, endIndex); startOffset: startOffset = scrollTop - (scrollTop % itemHeight); 滚动倍数 state = { pageHeight: 0, //屏幕高度 infiniteListGhostHeight: 0, // 列表总高度 renderList: [], // 渲染列表 itemHeight: 80, translate: 0, // 可视区域偏移 } componentDidMount() { const { itemHeight } = this.state this.refs.container.addEventListener('scroll', this.handleScroll); const clientHeight = document.body.clientHeight; const itemCount = Math.ceil(clientHeight / itemHeight ); this.setState({ pageHeight: clientHeight, infiniteListGhostHeight: result.length * itemHeight, renderList: result.slice(0, itemCount) }) } componentWillUnmount() { this.refs.container.removeEventListener('scroll', this.handleScroll); } handleScroll = (e) => { const { itemHeight, pageHeight, infiniteListGhostHeight } = this.state const scrollTop = e.srcElement.scrollTop || e.srcElement.scrollTop; // 从scrollTop 计算出偏移startIndex const itemCount = Math.ceil(pageHeight / itemHeight ); //可视区域高度 / 子项高度 = 子项个数 const startIndex = Math.floor(scrollTop / itemHeight); const endIndex = startIndex + itemCount; const list = result.slice(startIndex, endIndex ); const startOffset = (scrollTop - (scrollTop % itemHeight)); this.setState({ translate: startOffset, renderList: list }) } 效果 可以看出，只渲染可视区域内的数据 设置上下缓存区 当滚动太块的时候，往下会有一段空白， 往上也有一段空白，那么这时候设置上下缓冲区可以解决此问题 handleScroll = (e) => { // .... const above = Math.min(startIndex, itemCount); const below = Math.min(result.length - endIndex, itemCount);; const start = startIndex - above; const end = endIndex + below; const list = result.slice(start, end); // 注意此时list的渲染会加上缓存区，所以导致了偏移向下了，但实际上应该减掉 上方缓冲区才能渲染中间的 const startOffset = (scrollTop - (scrollTop % itemHeight) - above * itemHeight); } 此时效果：","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"导航栏吸顶","slug":"导航栏吸顶","date":"2020-04-09T08:06:17.000Z","updated":"2023-02-14T15:19:27.741Z","comments":true,"path":"2020/04/09/导航栏吸顶/","link":"","permalink":"http://yoursite.com/2020/04/09/%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%90%B8%E9%A1%B6/","excerpt":"","text":"导航栏吸顶 当页面滚动超过导航栏时，导航栏依附固定在页面顶端 下面介绍两种方式吧， 一种是 position: sticky, 另一种是getBoundingClientRect() position: sticky 实现.stickyPostion { postion: sticky; top: 0; } 使用条件： 父元素不能overflow:hidden或者overflow:auto属性。 必须指定top、bottom、left、right4个值之一，否则只会处于相对定位 父元素的高度不能低于sticky元素的高度 sticky元素仅在其父元素内生效 sticky 坑 兼容性不太好 不能触发 BFC getBoundingClientRect()getBoundingClientRect用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。getBoundingClientRect是DOM元素到浏览器可视范围的距离（不包含文档卷起的部分）。 获取当前 nav 到浏览器顶端的距离。 直接监听scroll 事件， 用div包裹住nav导航栏，我们只需要获取当前div到顶端的距离即可，等到时 top值为0的时候，设置子级的position:fixed, 还原只需取消掉子级的position即可 如果没有用div 包裹 nav导航栏的话，等top 值为0，就无法还原了，position 一直为fix, getBoundingClientRect.top值一直为0; 结构应该如下： &lt;div ref={this.stickyRef} id=\"sticky\"> &lt;div className={isFixed ? styles.fix : styles.static}> // 这个为nav &lt;div>吸顶效果&lt;/div> &lt;/div> &lt;/div> componentDidMount() { const top = this.stickyRef.current.getBoundingClientRect().top; this.setState({ initPostionTop: top }) window.addEventListener('scroll', this.handleScroll); } handleScroll = (e) => { const { isFixed, initPostionTop } = this.state const scrollTop = e.srcElement.body.scrollTop || e.srcElement.documentElement.scrollTop; // 这里做了个优化，防止频繁setState, 如果一开始为吸顶，以及滚动距离大于 nav 到顶部的距离的时候， // 或者 （不吸顶同时当前滚动距离小于nav到顶部的距离时)我们操作 if(isFixed &amp;&amp; scrollTop >= initPostionTop || !isFixed &amp;&amp; scrollTop &lt;= initPostionTop) { return ; } else { this.setState({ isFixed: scrollTop > initPostionTop }) } } 小程序 (我使用的是Taro) 小程序不支持 window.addEventListener(&#39;scroll&#39;, this.handleScroll);，只有onPageScroll 下面是官方说明注意：请只在需要的时候才在 page 中定义此方法，不要定义空方法。以减少不必要的事件派发对渲染层-逻辑层通信的影响。注意：请避免在 onPageScroll 中过于频繁的执行 this.setState() 等引起逻辑层-渲染层通信的操作。尤其是每次传输大量数据，会影响通信耗时。 taro获取节点有点坑 componentDidMount() { // 注意this.$scope const query = Taro.createSelectorQuery().in(this.$scope); query.select('#sticky').boundingClientRect((rect) => { this.setState({ initPostionTop: rect.top }) }).exec(); } onPageScroll 代码基本一样 坑 这种方式有个坑，当吸顶的一瞬间，会发生抖动，这是因为 position变成fixed 的时候脱离了文档流。解决方案是 在postion:fixed;的元素里添加transform: translateZ(0);,我想应该是开启gpu 渲染，所以变得顺滑了吧 关于优化 h5 优化，可以用另一种方式，就是用 监听滚动的时候使用 节流， 可以用 lodash.throttle window.addEventListener(&#39;scroll&#39;, _.throttle(self.handleScrollThree, 50)); 效果","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"一行代码使网站变灰","slug":"一行代码使网站变灰","date":"2020-04-08T08:00:48.000Z","updated":"2023-02-14T15:19:27.733Z","comments":true,"path":"2020/04/08/一行代码使网站变灰/","link":"","permalink":"http://yoursite.com/2020/04/08/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%BD%91%E7%AB%99%E5%8F%98%E7%81%B0/","excerpt":"","text":"先看看效果吧 分析 网站变灰用到的是 css3 的 filter 属性，其实就是滤镜 代码html { filter: grayscale(0.95) } filter 还能做 高斯模糊，色相旋转， 色相透明，调整对比度等等， filter: blur(5px); // 高斯模糊 filter: contrast(200%); // 调整对比度 filter: opacity(30%); // 调整透明度","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-08T03:33:51.000Z","updated":"2023-02-14T15:19:27.731Z","comments":true,"path":"2020/04/08/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"taro","slug":"taro","permalink":"http://yoursite.com/categories/taro/"},{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/categories/typescript/"},{"name":"jenkins","slug":"jenkins","permalink":"http://yoursite.com/categories/jenkins/"},{"name":"react-router","slug":"react-router","permalink":"http://yoursite.com/categories/react-router/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"},{"name":"正则","slug":"正则","permalink":"http://yoursite.com/categories/%E6%AD%A3%E5%88%99/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"antd","slug":"react/antd","permalink":"http://yoursite.com/categories/react/antd/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"},{"name":"js-xlsx","slug":"js-xlsx","permalink":"http://yoursite.com/categories/js-xlsx/"},{"name":"react源码系列","slug":"react/react源码系列","permalink":"http://yoursite.com/categories/react/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"},{"name":"electron","slug":"electron","permalink":"http://yoursite.com/categories/electron/"},{"name":"vue","slug":"electron/vue","permalink":"http://yoursite.com/categories/electron/vue/"},{"name":"webpack","slug":"electron/vue/webpack","permalink":"http://yoursite.com/categories/electron/vue/webpack/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"taro","slug":"taro","permalink":"http://yoursite.com/tags/taro/"},{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"},{"name":"jenkins","slug":"jenkins","permalink":"http://yoursite.com/tags/jenkins/"},{"name":"react-router","slug":"react-router","permalink":"http://yoursite.com/tags/react-router/"},{"name":"antd","slug":"antd","permalink":"http://yoursite.com/tags/antd/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"代理","slug":"代理","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%90%86/"},{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"algorithm-二叉树","slug":"algorithm-二叉树","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"algorithm-深度搜索优先","slug":"algorithm-深度搜索优先","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E4%BC%98%E5%85%88/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"algorithm-递归","slug":"algorithm-递归","permalink":"http://yoursite.com/tags/algorithm-%E9%80%92%E5%BD%92/"},{"name":"algorithm-深度遍历搜索","slug":"algorithm-深度遍历搜索","permalink":"http://yoursite.com/tags/algorithm-%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2/"},{"name":"algorithm-全排列","slug":"algorithm-全排列","permalink":"http://yoursite.com/tags/algorithm-%E5%85%A8%E6%8E%92%E5%88%97/"},{"name":"algorithm-链表","slug":"algorithm-链表","permalink":"http://yoursite.com/tags/algorithm-%E9%93%BE%E8%A1%A8/"},{"name":"algorithm-动态规划","slug":"algorithm-动态规划","permalink":"http://yoursite.com/tags/algorithm-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"algorithm-栈","slug":"algorithm-栈","permalink":"http://yoursite.com/tags/algorithm-%E6%A0%88/"},{"name":"algorithm-数组","slug":"algorithm-数组","permalink":"http://yoursite.com/tags/algorithm-%E6%95%B0%E7%BB%84/"},{"name":"algorithm-分治","slug":"algorithm-分治","permalink":"http://yoursite.com/tags/algorithm-%E5%88%86%E6%B2%BB/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"algorithm-基础","slug":"algorithm-基础","permalink":"http://yoursite.com/tags/algorithm-%E5%9F%BA%E7%A1%80/"},{"name":"js-xlsx","slug":"js-xlsx","permalink":"http://yoursite.com/tags/js-xlsx/"},{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"},{"name":"expo","slug":"expo","permalink":"http://yoursite.com/tags/expo/"},{"name":"react源码系列","slug":"react源码系列","permalink":"http://yoursite.com/tags/react%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"},{"name":"algorithm-双指针","slug":"algorithm-双指针","permalink":"http://yoursite.com/tags/algorithm-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"algorithm-二分法","slug":"algorithm-二分法","permalink":"http://yoursite.com/tags/algorithm-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"algorithm-map","slug":"algorithm-map","permalink":"http://yoursite.com/tags/algorithm-map/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"algorithm-排序","slug":"algorithm-排序","permalink":"http://yoursite.com/tags/algorithm-%E6%8E%92%E5%BA%8F/"},{"name":"algorithm-快速排序","slug":"algorithm-快速排序","permalink":"http://yoursite.com/tags/algorithm-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"algorithm-面试题","slug":"algorithm-面试题","permalink":"http://yoursite.com/tags/algorithm-%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"algorithm-前缀和","slug":"algorithm-前缀和","permalink":"http://yoursite.com/tags/algorithm-%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"electron","slug":"electron","permalink":"http://yoursite.com/tags/electron/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}